<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JianHong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Note">
<meta property="og:type" content="website">
<meta property="og:title" content="JianHong">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="JianHong">
<meta property="og:description" content="Note">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JianHong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="JianHong" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JianHong</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Note/区块链开发/源码/Uniswap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81/Uniswap/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.663Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	UniswapV2ERC20 --继承--&gt; UniswapV2Pair --引用--&gt; UniswapV2Factory</span><br><span class="line">	项目方 --创建流动性--&gt; UniswapV2Router --调用--&gt; UniswapV2Factory --部署--&gt; UniswapV2Pair</span><br><span class="line">	用户 --交易--&gt; UniswapV2Router --调用--&gt; UniswapV2Pair</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>IUniswapV3Factory 工厂接口</p>
<h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>UniswapV3Factory 工厂合约</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81/Uniswap/" data-id="clrj8k01c00564wuwf4nzc3e7" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/源码/EVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81/EVM/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.662Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3/">Web3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81/EVM/">EVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>类似JVM虚拟机，是一个基于栈的虚拟机</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/../../../../images/image-20240116203733311.png" alt="image-20240116203733311"></p>
<h3 id="Storage结构"><a href="#Storage结构" class="headerlink" title="Storage结构"></a>Storage结构</h3><ul>
<li>以太坊中采用的是插槽 slot 存储，KV映射，k是slot，有32个字节，v也是32个字节</li>
<li>slot 空间不足时会自动存入下一个slot</li>
<li>操作的时候也是对整个slot进行操作</li>
<li>基本数据类型是从slot中的低位向高位存储数据</li>
<li>结构体和定长数组的存储会单独创建一整块slot进行存储</li>
<li>映射mapping会通过占位符占据整块slot数组，然后value存储在keccak256(slot下标.key)</li>
<li>动态数组会用数组长度占据1块slot数组，然后数据存储keccak256(slot下标.value)</li>
<li>bytes和string<ul>
<li>数据长度 &lt;&#x3D; 31字节：数据存高31位，最低一位存数据长度 * 2</li>
<li>数据长度 &gt;&#x3D; 31字节：会存储一个数据长度 * 2 + 1，数据会另外存储</li>
</ul>
</li>
<li>EVM会将有空余空间的slot填充到32位，这增加了gas费</li>
<li>编译器会将多个元素合并到一个slot，所以需要保证这些元素是可以紧密存储的<ul>
<li>变量和结构体存储时可以考虑占满一个slot</li>
</ul>
</li>
</ul>
<h3 id="Memory结构"><a href="#Memory结构" class="headerlink" title="Memory结构"></a>Memory结构</h3><p><img src="/../../../../images/image-20240117033920821.png" alt="image-20240117033920821"></p>
<ul>
<li>0x40指向的是现在能操作的空闲的地址</li>
<li>只能创建定长数组</li>
<li>创建数组时要指定长度，创建的数组不能进行大小的变更操作</li>
<li>在返回值中使用memory的话，是不会存在函数的默认内存空间中的，会开辟一块新的内存空间</li>
<li>不定长的数据类型作为返回值需要加上memory<ul>
<li>Solidity中的函数默认返回值存储在堆栈上，而堆栈空间是有限的。如果函数返回的数据类型是不定长的，并且长度超过堆栈的大小限制，那么将会导致栈溢出错误</li>
</ul>
</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><img src="/../../../../images/12-3-06b5d454b3752b96000f8a9477fa31de.png" alt="img"></p>
<ul>
<li>日志用来存储Solidity中的事件</li>
<li>结构<ul>
<li>topics 主题<ul>
<li>是一个数组，长度不超过4</li>
<li>第一个元素是事件的签名，此外最多可以包含三个indexed参数</li>
<li>indexed标注的参数可以看作是事件的索引键</li>
</ul>
</li>
<li>data 数据<ul>
<li>普通参数会保存在data中</li>
<li>可以看作是事件的值</li>
<li>不可以被直接检索，可以存储任意大小的数据</li>
<li>data存储数据消耗的gas比topics少</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="汽油费"><a href="#汽油费" class="headerlink" title="汽油费"></a>汽油费</h2><ul>
<li>智能合约是一个图灵完备的编程模型</li>
<li><h2 id="如果出现死循环（停机问题）"><a href="#如果出现死循环（停机问题）" class="headerlink" title="如果出现死循环（停机问题）"></a>如果出现死循环（停机问题）</h2></li>
<li>执行合约中的指令需要收取汽油费，由发起交易的人支付<ul>
<li>不同指令消耗的汽油费是不同的</li>
<li>简单的指令汽油费低，复杂或者需要存储数据的指令就很贵</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81/EVM/" data-id="clrj8k01c00534wuwajem4a82" data-title="EVM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web3/" rel="tag">web3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/基础/区块链知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.658Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3/">Web3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/">区块链基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="WEB3"><a href="#WEB3" class="headerlink" title="WEB3"></a>WEB3</h3><ul>
<li>WEB1：只读，静态内容，信息聚合</li>
<li>WEB2：可读写，可交互，数据存储在中心化服务器，受监管</li>
<li>WEB3：可读写，可拥有，去中心化，不可篡改</li>
</ul>
<h3 id="平台对比"><a href="#平台对比" class="headerlink" title="平台对比"></a>平台对比</h3><table>
<thead>
<tr>
<th></th>
<th>以太坊</th>
<th>Fabric</th>
<th>Corda</th>
</tr>
</thead>
<tbody><tr>
<td>节点许可</td>
<td>基于智能合约的规则，将基于文件的每个节点的规则作本地覆盖（override）</td>
<td>可在节点(node)，通道(channel)和联盟(consortium)级别上配置</td>
<td>可信网络映射服务，由每个节点上基于文件的配置进行补充。Corda网络被划分为由单独的证书颁发机构(Certificate Authorities)管理的兼容区域</td>
</tr>
<tr>
<td>身份</td>
<td>公钥-分布式的，可在以太坊的链之间可互操作。通过证明(proofs)与PKI耦合</td>
<td>基于具有本地组织身份的PKI。在共识和许可中始终使用组织身份，而不是个人身份</td>
<td>基于个人和组织身份的PKI</td>
</tr>
<tr>
<td>加密算法</td>
<td>secp256k1</td>
<td>可插拔 (内置有 secp256r1 和 secp384r1的椭圆算法).</td>
<td>ed25519 secp256r1 secp256k1 RSA (3072bit) PKCS#1 SPHINCS-256 (experimental 试验阶段)</td>
</tr>
<tr>
<td>交易共识</td>
<td>排序(Order)-&gt;执行(Execute)&#x2F;验证(Validate)</td>
<td>执行-&gt;排序-&gt;验证</td>
<td>执行&#x2F;验证-&gt;排序&#x2F;公证(Notarize)</td>
</tr>
<tr>
<td>应用的责任</td>
<td>将签名的交易发送到网络中的一个节点</td>
<td>直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking)</td>
<td>直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking)</td>
</tr>
<tr>
<td>共识算法</td>
<td>Proof-of-Authority 权威证明 (BFT). Raft (CFT with trusted leader，有可信领导). Istanbul BFT (BFT with deterministic leader rotation 有确定性领导轮换). Tendermint</td>
<td>Kafka&#x2F;Zab (CFT with trusted leader 有可信领导). Raft (CFT with trusted leader有可信领导)</td>
<td>Raft (CFT with trusted leader有可信领导) BFT</td>
</tr>
<tr>
<td>智能合约引擎</td>
<td>EVM, 进程内沙盒(in-process sandbox)</td>
<td>容器隔离(Docker isolation)</td>
<td>确定性JVM(Deterministic JVM)</td>
</tr>
<tr>
<td>智能合约语言</td>
<td>DSL (Solidity, Serpent), 保证确定性</td>
<td>多语言 (Go, Node.js, Java), 可容忍的非确定性</td>
<td>Java, Kotlin, 通过推荐的库来实现确定性</td>
</tr>
<tr>
<td>智能合约生命周期</td>
<td>不可篡改，部署容易，链上储存</td>
<td>需要细致的过程(elaborate process)来部署&#x2F;更改。链下存储</td>
<td>需要节点级管理操作才能部署&#x2F;更新。链下存储。 正在进行的工作是将共识关键代码与非共识关键代码拆分为不同的存储策略（分别在链上和链下）</td>
</tr>
<tr>
<td>智能合约升级</td>
<td>通过编程模式来扩展&#x2F;迁移代码和数据</td>
<td>通过管理程序和升级交易来替换链下代码</td>
<td>具有基于哈希约束的合同通过节点级管理程序和协调流程进行显式升级和授权。只要根据约束条件和哈希匹配项进行签名，具有签名约束条件的合同就会自动允许执行新版本</td>
</tr>
<tr>
<td>资产数字化&#x2F;通证化</td>
<td>原生带有多标准功能: ERC20&#x2F;ERC721&#x2F;ERC777 etc.</td>
<td>无原生通证，定制化方案</td>
<td>定制化方案，通过Corda通证SDK更容易实现</td>
</tr>
<tr>
<td>多链</td>
<td>每个链都是唯一的，并且需要单独的节点运行时（最少或3或4个，取决于共识）</td>
<td>具有共享对等runtime和共享顺序器的本机功能（通道）。用于创建具有隔离状态的侧链的内置治理</td>
<td>没有链的概念（共享账本）。交易始终明确地针对特定节点。状态的范围仅限于指定的公证节点，可以将其重新定向到其他公证</td>
</tr>
<tr>
<td>私有交易</td>
<td>公共哈希代表输入</td>
<td>公共哈希代表输入和私有结束状态</td>
<td>继承的所有交易都是私有的。所有的交易对对验证公正节点</td>
</tr>
<tr>
<td>社区贡献者（至2019年10月）</td>
<td>Go-Ethereum: 429 Quorum: 383 Besu: 60 Autonity: 360</td>
<td>Fabric: 185</td>
<td>Corda: 146</td>
</tr>
<tr>
<td>社区活跃度(Month of Nov. 2019)</td>
<td>Go-Ethereum: 15 authors, 98 PRs Quorum: 9 authors, 13 PRs Besu: 23 authors, 66 PRs Autonity: 6 authors, 6 PRs</td>
<td>Fabric: 31 authors, 220 PRs</td>
<td>Corda: 33 authors, 91 PRs</td>
</tr>
</tbody></table>
<h3 id="链种对比"><a href="#链种对比" class="headerlink" title="链种对比"></a>链种对比</h3><table>
<thead>
<tr>
<th></th>
<th>公有链</th>
<th>联盟链</th>
<th>私有链</th>
</tr>
</thead>
<tbody><tr>
<td>中心化程度</td>
<td>完全</td>
<td>部分</td>
<td></td>
</tr>
<tr>
<td>可控性</td>
<td>弱</td>
<td>强</td>
<td></td>
</tr>
<tr>
<td>数据隐秘性</td>
<td>弱</td>
<td>强</td>
<td></td>
</tr>
<tr>
<td>交易速度</td>
<td>慢</td>
<td>快</td>
<td></td>
</tr>
<tr>
<td>场景</td>
<td></td>
<td>溯源、慈善、<br />金融、保险</td>
<td></td>
</tr>
</tbody></table>
<h3 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h3><ul>
<li><p>是区块链底层安全机制的保障 </p>
</li>
<li><p>对消息签名使用的是非对称加密的签名算法，运用到了 <a target="_blank" rel="noopener" href="https://unfalltable.github.io/2023/12/26/Note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E5%AF%86%E7%A0%81%E5%AD%A6/">RSV</a> </p>
</li>
<li><p>柯尔霍夫原则</p>
<ul>
<li>密钥是保密的，算法和参数是公开的</li>
<li>不需要数学上不可解，现实不可解即可</li>
</ul>
</li>
<li><p>加密</p>
<ul>
<li>对称加密<ul>
<li>DES、AES、伪随机数生成</li>
</ul>
</li>
<li>非对称加密<ul>
<li>公私钥</li>
<li>安全性来源都是基于数学难题</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希算法</p>
<ul>
<li>collisiom resistance：输入转hash结果不变，但存在哈希碰撞</li>
<li>hiding：根据哈希值无法预测输入</li>
<li>puzzle friendly：根据输入无法预测哈希值</li>
</ul>
</li>
<li><p>默克尔树</p>
<ul>
<li>依靠hash来快速确认某个值是否在集合中</li>
</ul>
</li>
</ul>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>区块链提供了一种让多个参与方在没有一个唯一可信方的情况下达成合作</p>
</li>
<li><p>区块链上的数据是不可篡改的</p>
</li>
<li><p>区块链的安全性是通过使用hash和签名的方式进行加密，使用的是 <code>sha-256</code> 加密算法</p>
</li>
<li><p>创建账户原理</p>
<ul>
<li>因为是去中心化的，所以个人即可创建账户，无需审核</li>
<li>创建账户的过程就是创建一个公私钥<ul>
<li>公钥就是账号</li>
<li>私钥就是操作账号的权限</li>
<li>对交易进行加密，用私钥加密，公钥解密，也就是一个签名的过程</li>
</ul>
</li>
</ul>
</li>
<li><p>挖矿</p>
<ul>
<li>挖矿是无记忆的，即和已经挖矿的时长无关</li>
</ul>
</li>
<li><p>在互不信任的对象之间建立联系</p>
</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h4><ul>
<li>保存指向区块的哈希值和区块地址</li>
<li>每个区块有一个指针指向前一个区块<ul>
<li>这个指针的hash值为前一个区块的数据+前一个区块的hash值</li>
<li>即前一个区块的数据如果发生变化，后一个区块的hash指针就找不到前一个区块了</li>
</ul>
</li>
</ul>
<h4 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h4><ul>
<li>不同的加密货币中区块的内容不同</li>
</ul>
<h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><ul>
<li>交易现在本地上执行完成，再进行挖矿<ul>
<li>因为要先确认块头中的信息</li>
<li>要验证交易的合法性、智能合约的正确执行</li>
</ul>
</li>
</ul>
<h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul>
<li>区块链1.0</li>
<li>区块链中的第一个区块为创世区块</li>
<li>一个节点最大1mb，一个交易250字节，最多有4000个交易，每秒处理大概7个交易</li>
<li>是一个基于栈的语言</li>
<li>很大程度的保证数据不可篡改</li>
<li>使用非对称加密椭圆曲线ECC中的secp256k1曲线</li>
<li>转账操作都需要签名（转账发起人的私钥）<ul>
<li>转账需要说明币的来源</li>
</ul>
</li>
<li>节点分为全节点和轻节点<ul>
<li>全节点<ul>
<li>一直在线，维护完整的区块信息</li>
<li>监听区块链网络上的交易信息，验证每个交易的合法性</li>
<li>决定哪些交易会被打包到区块里</li>
<li>监听其他矿工挖出的区块，验证其合法性</li>
</ul>
</li>
<li>轻节点<ul>
<li>包含block header</li>
<li>不是一直在线的</li>
<li>只保存与自己相关的交易，并只能检验与自己相关的交易的合法性</li>
<li>无法检测其他人发布的区块的正确性</li>
<li>可以验证挖矿难度</li>
<li>能检测最长链，但不能检测最长合法链</li>
</ul>
</li>
</ul>
</li>
<li>由于网络带宽限制和算力分布限制，比特币限制了单个节点可接收信息和主动链接其他节点的上限。对于接受信息，单个节点最多只能接收117个节点的信息，对于主动链接其他节点，单个节点只能主动联系其他8个节点</li>
</ul>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><h4 id="区块结构-1"><a href="#区块结构-1" class="headerlink" title="区块结构"></a>区块结构</h4><ul>
<li>block header 区块头<ul>
<li>存储merkle tree的根hash值，可以检测出整棵树任何位置的修改</li>
<li>比特币协议版本</li>
<li>指向前一个区块区块头的指针（其实是一个哈希）</li>
<li>挖矿难度目标阈值target（256byte），被编码成4byte的nBits</li>
</ul>
</li>
<li>block body 区块体<ul>
<li>存储了具体的交易列表</li>
</ul>
</li>
<li>UTXO<ul>
<li>UTXO存储的是没花出去的交易的输出集合</li>
</ul>
</li>
</ul>
<h4 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h4><ul>
<li>一个矿主+很多的矿工</li>
<li>矿主负责全节点的工作，矿工负责计算hash值</li>
<li>分红<ul>
<li>按劳分配，通过工作量证明</li>
<li>降低工作难度，矿工提交难度低的区块作为工作证明</li>
</ul>
</li>
<li>私吞情况<ul>
<li>不可能的，矿工的任务由矿主分配</li>
<li>收款地址是矿主的，无法私吞</li>
</ul>
</li>
<li>存在恶意竞争的情况<ul>
<li>其他矿池安排一些矿工到其他矿池工作</li>
<li>参与其他矿池的分红，但是当这些矿工挖到区块后会选择放弃区块</li>
</ul>
</li>
<li>有危害，当矿池算力达到51%攻击后<ul>
<li>可以实现分叉攻击 </li>
<li>可以实现封锁账户</li>
</ul>
</li>
</ul>
<h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><ul>
<li>出块时间十分钟，同时出块的可能性较小</li>
<li>解决恶意节点，防止女巫攻击（sybil attack）<ul>
<li>女巫攻击：制造大量的账号进行攻击</li>
</ul>
</li>
<li>比特币使用算力投票</li>
<li>最长链原则</li>
<li>挖矿奖励机制<ul>
<li>每隔2016个区块要重新调整目标阈值，大约两星期</li>
<li>target &#x3D; target * 实际产生2016个区块的时间 &#x2F; (2016*10)</li>
<li>target的上调和下调的上限不会超过四倍 </li>
<li>当该区块被其他矿工挖出后，会停止当前区块，组装新的候选区块<ul>
<li>不可惜，因为每次挖矿的概率都是一样的</li>
</ul>
</li>
</ul>
</li>
<li>确认交易机制<ul>
<li>交易写入区块后为了防止双花攻击，可以多等6个区块产出后再确认，差不多一小时</li>
</ul>
</li>
<li>应用层、P2P</li>
<li>tcp通信</li>
</ul>
<h3 id="交易-1"><a href="#交易-1" class="headerlink" title="交易"></a>交易</h3><h4 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h4><ul>
<li>记录的是当前区块中所有的交易信息<ul>
<li><p>交易id、交易的hash值、版本号、大小、</p>
</li>
<li><p>所在区块hash值，交易确认信息数、交易产生时间、区块产生时间</p>
</li>
<li><p>锁定时间 locktime</p>
<ul>
<li>一般都是0，即立即生效</li>
</ul>
</li>
<li><p>输入 vin</p>
<ul>
<li><p>txid：之前交易的hash值，也就是币的来源</p>
</li>
<li><p>vout：这个交易的第几个输出</p>
</li>
<li><p>ScriptSig：输入脚本，签名</p>
<ul>
<li>asm：操作</li>
<li>hex：</li>
</ul>
</li>
</ul>
</li>
<li><p>输出 vout</p>
<ul>
<li>value：交易的金额</li>
<li>n：这个交易的第几个输出</li>
<li>scriptPubKey：输出脚本<ul>
<li>asm：操作</li>
<li>hex：</li>
<li>reqSigs：需要的签名数</li>
<li>type：输出的类型</li>
<li>address：输出的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="merkle-tree"><a href="#merkle-tree" class="headerlink" title="merkle tree"></a>merkle tree</h4><ul>
<li><p>交易的结构是一颗二叉树，叶子节点是交易的数据，非叶子节点是左右孩子节点的hash</p>
<ul>
<li>非叶子节点的hash指针有两个，分别指向左右子树</li>
<li>通过左右孩子可以计算得出上一个节点（父节点）的hash值</li>
</ul>
</li>
<li><p>提供merkle proof，即交易到merkle tree的根hash值的路径</p>
</li>
<li><p>当一个轻节点想知道交易是否包含在对应的区块中的merkle tree时，它需要</p>
<ul>
<li>计算当前交易的hash值，通知全节点取得另一个hash值</li>
<li>计算得出上一个节点的hash次，循环往复直到根节点</li>
<li>轻节点将计算得出的根节点hash值和当前区块的block header中的根节点hash值进行比较即可</li>
</ul>
</li>
<li><p>可以证明交易存在merkle tree中，proof of membership</p>
<ul>
<li>如果merkle tree的叶子节点是有序的话，就可以证明某个交易是否在树上</li>
<li>比特币的merkle tree的叶子节点是无序的</li>
</ul>
</li>
<li><p>铸币交易的输出会有目标用户的hash</p>
</li>
<li><p>目标用户转账时会校验这个hash是否正确，这样可以避免伪造交易</p>
</li>
</ul>
<h4 id="交易合法性"><a href="#交易合法性" class="headerlink" title="交易合法性"></a>交易合法性</h4><ul>
<li>早期脚本是将当前交易的输入和币的来源的输出拼接在一起验证</li>
<li>后出于安全因素改为分别验证<ul>
<li>先执行输入脚本，在执行输出脚本</li>
</ul>
</li>
<li>P2PK<ul>
<li>输入<ul>
<li>支付人的签名</li>
</ul>
</li>
<li>输出<ul>
<li>收款人公钥</li>
<li>检查签名</li>
</ul>
</li>
<li>流程<ul>
<li>将输入的签名压入栈</li>
<li>将输出中的公钥压入栈</li>
<li>验证栈中的公钥和签名是否合法</li>
</ul>
</li>
</ul>
</li>
<li>P2PKH（最常用）<ul>
<li>输入<ul>
<li>支付人的签名</li>
<li>收款人公钥</li>
</ul>
</li>
<li>输出<ul>
<li>DUP 复制栈顶元素</li>
<li>HASH160 将栈顶元素取hash值</li>
<li>收款人公钥的hash</li>
<li>检查签名</li>
</ul>
</li>
<li>流程<ul>
<li>将输入脚本中的支付人的签名压入栈</li>
<li>将输入脚本中的收款人公钥压入栈</li>
<li>复制栈顶元素压入栈（收款人公钥）</li>
<li>将栈顶元素弹出并取hash值压入栈（收款人公钥哈希）</li>
<li>将输出脚本的收款人公钥的hash压入栈</li>
<li>比较栈顶两个元素是否一致（比较两个收款人hash是否一致）</li>
<li>检查签名</li>
</ul>
</li>
</ul>
</li>
<li>P2SH<ul>
<li>输入<ul>
<li>支付人的签名</li>
<li>赎回脚本<ul>
<li>收款人公钥</li>
<li>检查签名</li>
</ul>
</li>
</ul>
</li>
<li>输出<ul>
<li>HASH160 将栈顶元素取hash值</li>
<li>赎回脚本<ul>
<li>收款人公钥hash</li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li>将输入脚本中的支付人的签名压入栈</li>
<li>将输入脚本中的赎回脚本压入栈</li>
<li>将栈顶元素弹出并取hash值压入栈<ul>
<li>得到赎回脚本的hash，其实就是收款人公钥的hash</li>
</ul>
</li>
<li>将输出脚本的赎回脚本压入栈<ul>
<li>其实就是将收款人公钥的hash压入栈</li>
</ul>
</li>
<li>验证收款人公钥的hash值是否一致</li>
<li>验证输入的签名和输入的赎回脚本中的签名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多重签名"><a href="#多重签名" class="headerlink" title="多重签名"></a>多重签名</h4><ul>
<li>需要多个人的签名才可以进行转账</li>
<li>p2sh实现<ul>
<li>封装了公钥</li>
</ul>
</li>
<li>有bug，会多压一个冗余数据入栈</li>
</ul>
<h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><ul>
<li>产生的原因<ul>
<li>同时发布区块</li>
<li>分叉攻击</li>
<li>比特币协议发生改变<ul>
<li>硬分叉（hard fork）<ul>
<li>永久的</li>
<li>向前不兼容</li>
<li>部分节点不更新协议就会出现，而且不会消除</li>
<li>会出现回访攻击和重放攻击<ul>
<li>通过chain ID 解决</li>
</ul>
</li>
</ul>
</li>
<li>软分叉（soft fork）<ul>
<li>暂时的</li>
<li>向前兼容的是软分叉</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Taproff"><a href="#Taproff" class="headerlink" title="Taproff"></a>Taproff</h3><ul>
<li>可以在BTC编写高级脚本</li>
</ul>
<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul>
<li>区块链2.0</li>
<li>出块时间10几秒</li>
<li>运行的是去中心化的智能合约，发布后不可修改</li>
<li>有账户的性质<ul>
<li>能避免双花攻击</li>
<li>余额通过状态树维护，避免篡改余额</li>
<li>有一个随机数记录账户交易的次数</li>
<li>1以太 &#x3D; 10^18^Wei</li>
<li>账户中可存放合约代码</li>
<li>账户可存储信息</li>
</ul>
</li>
<li>发布新的区块时不会包含叔父区块中的交易，会检查叔父区块的合法性（是否符合挖矿难度要求）</li>
<li>只有分叉后的第一个叔父节点可以得到奖励、</li>
<li>交易需要付燃油费gas<ul>
<li>每5个byte需要1个gas</li>
</ul>
</li>
</ul>
<h3 id="状态树（Modified-Merkle-Patricia-Tree）"><a href="#状态树（Modified-Merkle-Patricia-Tree）" class="headerlink" title="状态树（Modified Merkle Patricia Tree）"></a>状态树（Modified Merkle Patricia Tree）</h3><ul>
<li><p>账户地址到账户状态的映射，键值对</p>
<ul>
<li>key是地址</li>
<li>value是账户的状态，通过RLP进行序列化</li>
</ul>
</li>
<li><p>账户地址160位，40个16进制的数</p>
</li>
<li><p>类似字典树，但进行了路径压缩</p>
<ul>
<li>是唯一的</li>
<li>路径压缩对稀疏的数据效果好</li>
<li>eth的地址是2^160^ 的随机数，符合稀疏的条件</li>
<li>路径压缩就是把相同前缀的节点进行合并，减小树的高度</li>
</ul>
</li>
<li><p>没有发生变化的节点在区块之间是共享的，有发生变化的需要新建分支</p>
<ul>
<li>维护没有发生变化的区块，是因为需要保留历史状态</li>
<li>因为交易可能需要回滚，所以需要保留历史状态</li>
<li>因为智能合约的设计复杂，无法推断出账户之前的状态，所以需要保留账户的历史信息</li>
</ul>
</li>
<li><p>大的状态树包含很多小的状态树</p>
</li>
</ul>
<h3 id="交易树"><a href="#交易树" class="headerlink" title="交易树"></a>交易树</h3><ul>
<li>结构和状态树一样</li>
<li>记录的是交易信息</li>
</ul>
<h3 id="收据树"><a href="#收据树" class="headerlink" title="收据树"></a>收据树</h3><ul>
<li>结构和状态树一样</li>
<li>结合布隆过滤器一起使用</li>
<li>每次交易</li>
<li>记录的是交易的收据信息，记录了交易的执行结果，收据列表的长度和交易列表的长度一致</li>
</ul>
<h3 id="共识协议POW"><a href="#共识协议POW" class="headerlink" title="共识协议POW"></a>共识协议POW</h3><ul>
<li>由于出块时间短，导致出现多个节点同时出块的可能性很高，所以临时性分叉很多</li>
<li>大型矿池更有可能成为最长合法连，马太效应</li>
<li>以太坊使用基于Ghost协议的共识机制</li>
<li>奖励<ul>
<li>叔父区块可以获得出块奖励，每次发布新区块最多只有两个叔父区块可以获得奖励<ul>
<li>七代以内的叔父 区块才有奖励，逐代递减1&#x2F;8</li>
</ul>
</li>
<li>发布区块包含叔父区块可以获得1&#x2F;32奖励，包含多个就有多份奖励</li>
</ul>
</li>
</ul>
<h3 id="挖矿算法"><a href="#挖矿算法" class="headerlink" title="挖矿算法"></a>挖矿算法</h3><ul>
<li>使用两个数据集，一个16m的cache，一个1G的dataset</li>
<li>这个大小是会增长的</li>
<li>轻节点保存cache即可，矿工节点保存dataset</li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li><p>通过一个种子seed通过某种运算算出一个值，然后依次经过这个运算取值存入cache数组</p>
<ul>
<li>每隔30000个区块会重新生成seed，即对原来的seed取hash</li>
<li>cache数组的初始大小是16M，每隔30000个区块会增大128k</li>
</ul>
</li>
<li><p>生成一个更大的dataset数组</p>
<ul>
<li>初始大小是1G，每隔30000个区块会增大8M</li>
<li>读取小数组第 i % cache_size ，对这个数异或 i 再取hash，记为mix</li>
<li>循环256次<ul>
<li>通过函数传入mix算出下一个读取的下标</li>
<li>通过函数传入mix和 cache[下标 % cache_size]，得到新的mix</li>
</ul>
</li>
<li>得到 hash(mix) 存入dataset[i]</li>
<li>循环这个操作直到填满dataset</li>
</ul>
</li>
<li><p>根据块头和nonce值，算出一个初始的hash，映射到大数组的某个位置和他的下一个位置</p>
<ul>
<li>全节点直接访存，轻节点通过下标间接访问</li>
</ul>
</li>
<li><p>然后这两个位置的数在进行运算得出下两个位置，循环这个操作64次</p>
</li>
<li><p>最后算出的值和挖矿难度的目标阈值比对，满足则通过，不 过则改nonce</p>
</li>
</ul>
<h3 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h3><ul>
<li>难度为：max（131072, 父区块难度 + X * Y） + Z<ul>
<li>最低难度：131072</li>
<li>X：难度调整单位，上一个区块的难度的2048分之1</li>
<li>Y：max（n - m，-99）<ul>
<li>n：有uncle区块为2，否则为1</li>
<li>m：（当前区块的时间戳 - 父区块的时间戳） &#x2F; 9，向下取整</li>
</ul>
</li>
<li>Z：2^(区块号-3000000)&#x2F;100000-2^<ul>
<li>难度炸弹，挖矿初期难度炸弹影响较小，越往后难度指数增加</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="WETH"><a href="#WETH" class="headerlink" title="WETH"></a>WETH</h3><ul>
<li>遵守ERC20标准的以太坊代币</li>
<li>和ETH一比一兑换</li>
</ul>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><ul>
<li>以太坊使用的数字签名算法叫双椭圆曲线数字签名算法（ECDSA），基于双椭圆曲线“私钥-公钥”对的数字签名算法。它主要起到了三个作用<ol>
<li><strong>身份认证</strong>：证明签名方是私钥的持有人。</li>
<li><strong>不可否认</strong>：发送方不能否认发送过这个消息。</li>
<li><strong>完整性</strong>：消息在传输过程中无法被修改。</li>
</ol>
</li>
<li>签名流程<ol>
<li>签名者利用<code>私钥</code>（隐私的）对<code>消息</code>（公开的）创建<code>签名</code>（公开的）。</li>
<li>其他人使用<code>消息</code>（公开的）和<code>签名</code>（公开的）恢复签名者的<code>公钥</code>（公开的）并验证签名。</li>
</ol>
</li>
</ul>
<h2 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h2><h3 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h3><ul>
<li>工作量证明，即比拼算力</li>
<li>通过求得满足难度要求的Hash值即可获得记账权</li>
<li>耗费电力，算力集中到了矿池</li>
</ul>
<h3 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h3><ul>
<li>权益证明，即比拼钱、币龄</li>
<li>早期有两边下注的问题</li>
<li>验证者<ul>
<li>质押抵押金可以参与验证者的选举，抵押金越高越容易成为验证者</li>
<li>抵押金会被锁定一段时间</li>
<li>如果验证者将非法的交易写入区块，则会扣除抵押金</li>
</ul>
</li>
</ul>
<h3 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h3><ul>
<li>委托权益证明 &#x2F; 代理权益证明</li>
<li>角色：投票、见证人、代表<ul>
<li>用户投票选出见证人</li>
<li>代表人可以提出提案，用户投票决定是否采纳</li>
</ul>
</li>
</ul>
<h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><ul>
<li><p>实用拜占庭容错机制，主要应用于联盟链中</p>
</li>
<li><p>三个阶段：预准备阶段、准备阶段和确认阶段，总节点数为N个，“拜占庭节点”有f个</p>
<ul>
<li>预准备阶段：主节点发布包含待验证记录的预准备消息，接收到预备消息后，每一个节点进入准备阶段</li>
<li>准备阶段：每一个节点验证其正确性，将正确记录保存下来发送给其他节点，直到某一个节点接收到2f个不同节点发送的与预准备阶段接收的记录一致的正确记录，该节点才向其他节点广播确认消息</li>
<li>确认阶段：直到每个诚实节点接收到2f+1个确认消息，协议才终止，各节点对记录达成一致</li>
</ul>
</li>
<li><p>实现区块链的一致性，剔出多余的计算量，避免资源浪费</p>
</li>
<li><p>只有一个节点可以提出新区块，因而不会出现“分叉”问题</p>
</li>
</ul>
<h2 id="Layer2"><a href="#Layer2" class="headerlink" title="Layer2"></a>Layer2</h2><h3 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h3><ul>
<li><p>在以太坊Layer1上部署合约</p>
</li>
<li><p>时刻更新交易数据到Layer2网络中</p>
</li>
<li><p>将交易按批次打包交易提交到Layer1的智能合约上</p>
<ul>
<li>乐观打包<ul>
<li>Optimistic<ul>
<li>引入争议时间延迟机制</li>
<li>使用挑战期保护数据正确性</li>
<li>容易实现</li>
</ul>
</li>
<li>Arbitrum<ul>
<li>多轮交互式欺诈证明</li>
<li>可组合性</li>
</ul>
</li>
</ul>
</li>
<li>零知识证明打包<ul>
<li>安全性依赖密码学，不需要挑战期</li>
<li>计算能力较差</li>
</ul>
</li>
</ul>
</li>
<li><p>然后以太坊主网验证</p>
</li>
</ul>
<h2 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h2><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><ul>
<li>将治理规则以智能合约形式编码的去中心化自治组织，与公司制相对</li>
<li>组织资源、事项执行、资金分配</li>
</ul>
<h2 id="去中心化存储"><a href="#去中心化存储" class="headerlink" title="去中心化存储"></a>去中心化存储</h2><ul>
<li>ipfs 星际文件系统</li>
</ul>
<h2 id="跨链多链"><a href="#跨链多链" class="headerlink" title="跨链多链"></a>跨链多链</h2><ul>
<li>通过两条链的智能合约实现<ul>
<li>一般通过资产冻结和生成实现</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/" data-id="clrj8k01b004u4wuwafyh6bqz" data-title="区块链基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web3/" rel="tag">web3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/基础/开发工具" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.658Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Remix"><a href="#Remix" class="headerlink" title="Remix"></a>Remix</h2><h2 id="Hardhat"><a href="#Hardhat" class="headerlink" title="Hardhat"></a>Hardhat</h2><h2 id="Foundry"><a href="#Foundry" class="headerlink" title="Foundry"></a>Foundry</h2><ul>
<li>本地开发测试</li>
</ul>
<h2 id="Phalcon-Fork"><a href="#Phalcon-Fork" class="headerlink" title="Phalcon Fork"></a>Phalcon Fork</h2><ul>
<li>协助开发测试</li>
<li>从主网fork一个测试网络出来，好处是测试时和主网环境一致</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" data-id="clrj8k01b004x4wuw02yd57r5" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/基础/协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.658Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3/">Web3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8D%8F%E8%AE%AE/">区块链协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>想要发行代币或者NFT，就需要实现相应的协议中规定的函数&#x2F;接口并对外暴露</p>
</li>
<li><p>ERC</p>
<ul>
<li>Ethereum Request For Comments  以太坊意见征求稿，</li>
<li>用以记录以太坊上应用级的各种开发标准和协议</li>
</ul>
</li>
<li><p>EIP</p>
<ul>
<li>Ethereum Imporvement Proposals 以太坊改进建议, </li>
<li>是以太坊开发者社区提出的改进建议</li>
<li>EIP 包含 ERC</li>
</ul>
</li>
</ul>
<h2 id="代币协议"><a href="#代币协议" class="headerlink" title="代币协议"></a>代币协议</h2><h3 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20 is IERC20&#123;</span><br><span class="line">	//balanceOf、allowance、totalSupply为public，会自动生成对应的get方法实现IERC20中的接口</span><br><span class="line">	mapping(address =&gt; uint256) public override balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span><br><span class="line">    uint256 public override totalSupply;   // 代币总供给</span><br><span class="line"></span><br><span class="line">    string public name;   // 名称</span><br><span class="line">    string public symbol;  // 代号</span><br><span class="line">    uint8 public decimals = 18; // 小数位数</span><br><span class="line">    </span><br><span class="line">    //初始化代币名称、代号</span><br><span class="line">    constructor(string memory name_, string memory symbol_)&#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line">    //转账</span><br><span class="line">    function transfer(address recipient, uint amount) external override returns(bool)&#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //授权，被授权方spender可以支配授权方的amount数量的代币</span><br><span class="line">    function approve(address spender, uint amount) external override returns (bool)&#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //授权转账</span><br><span class="line">    function transferFrom(address sender, address recipient, uint amount) </span><br><span class="line">    external override returns (bool) &#123;</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //铸币函数</span><br><span class="line">    function mint(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //销毁函数</span><br><span class="line">    function burn(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        totalSupply -= amount;</span><br><span class="line">        emit Transfer(msg.sender, address(0), amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>代币标准，IERC20是他的接口合约</p>
</li>
<li><p>函数</p>
<ul>
<li>代币总量 totalSupply</li>
<li>账户余额 balanceOf</li>
<li>转账 transfer</li>
<li>授权转账 approve</li>
<li>授权额度 allowance</li>
<li>获取授权转账 transferFrom</li>
<li>代币信息（可选）：名称，代号，小数位数下</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li><code>Transfer</code>事件</li>
<li><code>Approval</code>事件</li>
</ul>
</li>
<li><p>使用时</p>
<ul>
<li>需要添加铸币函数和销毁函数</li>
<li>需要注意权限控制和溢出问题</li>
</ul>
</li>
</ul>
<h3 id="EIP-712"><a href="#EIP-712" class="headerlink" title="EIP-712"></a>EIP-712</h3><p>- </p>
<h3 id="Ordinals"><a href="#Ordinals" class="headerlink" title="Ordinals"></a>Ordinals</h3><ul>
<li>序数<ul>
<li>可以给聪添加编号</li>
</ul>
</li>
<li>Inscription 铭文<ul>
<li>可以给带序数的聪里嵌入信息，大小在4mb以内</li>
<li>这个过程也成为铭刻</li>
</ul>
</li>
<li>BRC20<ul>
<li>本质是一个Json脚本</li>
<li>不允许智能合约</li>
<li>安全公平</li>
</ul>
</li>
<li>优缺点<ul>
<li>提高网络安全</li>
<li>提高矿工收入，保障了算力的稳定</li>
<li>偏离了比特币最初的目标</li>
<li>造成区块链膨胀，大小变大</li>
<li>会有垃圾信息</li>
<li>损害了聪的可替代性</li>
</ul>
</li>
</ul>
<h2 id="NFT协议"><a href="#NFT协议" class="headerlink" title="NFT协议"></a>NFT协议</h2><h3 id="ERC165"><a href="#ERC165" class="headerlink" title="ERC165"></a>ERC165</h3><ul>
<li>检查一个智能合约是不是支持了<code>ERC721</code>，<code>ERC1155</code>的接口。</li>
<li>IERC165接口合约只声明了一个<code>supportsInterface</code>函数，输入要查询的<code>interfaceId</code>接口id，若合约实现了该接口id，则返回true</li>
<li>即对外表明自己实现了哪些接口标准</li>
<li>如果想知道某个合约实现了哪些接口合约，只需要将该合约的 <code>Interface ID</code> 传入目标合约的 <code>supportsInterface</code> 函数，返回为true即实现了对应的合约要求</li>
<li>Interface ID 是接口合约中每个函数选择器 取 keccak256 再异或(^) 取 bytes4 获得</li>
</ul>
<h3 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// by 0xAA</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;./IERC165.sol&quot;;</span><br><span class="line">import &quot;./IERC721.sol&quot;;</span><br><span class="line">import &quot;./IERC721Receiver.sol&quot;;</span><br><span class="line">import &quot;./IERC721Metadata.sol&quot;;</span><br><span class="line">import &quot;./Address.sol&quot;;</span><br><span class="line">import &quot;./String.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC721 is IERC721, IERC721Metadata&#123;</span><br><span class="line">    using Address for address; // 使用Address库，用isContract来判断地址是否为合约</span><br><span class="line">    using Strings for uint256; // 使用String库，</span><br><span class="line"></span><br><span class="line">    // Token名称</span><br><span class="line">    string public override name;</span><br><span class="line">    // Token代号</span><br><span class="line">    string public override symbol;</span><br><span class="line">    // tokenId 到 owner address 的持有人映射</span><br><span class="line">    mapping(uint =&gt; address) private _owners;</span><br><span class="line">    // address 到 持仓数量 的持仓量映射</span><br><span class="line">    mapping(address =&gt; uint) private _balances;</span><br><span class="line">    // tokenID 到 授权地址 的授权映射</span><br><span class="line">    mapping(uint =&gt; address) private _tokenApprovals;</span><br><span class="line">    //  owner地址。到operator地址 的批量授权映射</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，初始化`name` 和`symbol` .</span><br><span class="line">     */</span><br><span class="line">    constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC165接口supportsInterface</span><br><span class="line">    function supportsInterface(bytes4 interfaceId)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return</span><br><span class="line">            interfaceId == type(IERC721).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC165).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC721Metadata).interfaceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查询owner地址的balance。</span><br><span class="line">    function balanceOf(address owner) external view override returns (uint) &#123;</span><br><span class="line">        require(owner != address(0), &quot;owner = zero address&quot;);</span><br><span class="line">        return _balances[owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查询tokenId的owner。</span><br><span class="line">    function ownerOf(uint tokenId) public view override returns (address owner) &#123;</span><br><span class="line">        owner = _owners[tokenId];</span><br><span class="line">        require(owner != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查询owner地址是否将所持NFT批量授权给了operator地址。</span><br><span class="line">    function isApprovedForAll(address owner, address operator)</span><br><span class="line">        external view override returns (bool)&#123;</span><br><span class="line">        return _operatorApprovals[owner][operator];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将持有代币全部授权给operator地址</span><br><span class="line">    function setApprovalForAll(address operator, bool approved) external override &#123;</span><br><span class="line">        _operatorApprovals[msg.sender][operator] = approved;</span><br><span class="line">        emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查询tokenId的授权地址。</span><br><span class="line">    function getApproved(uint tokenId) external view override returns (address) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">        return _tokenApprovals[tokenId];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //内部授权函数，授权 to 地址操作 tokenId。</span><br><span class="line">    function _approve(address owner, address to, uint tokenId) private &#123;</span><br><span class="line">        _tokenApprovals[tokenId] = to;</span><br><span class="line">        emit Approval(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将tokenId授权给 to 地址</span><br><span class="line">    function approve(address to, uint tokenId) external override &#123;</span><br><span class="line">        address owner = _owners[tokenId];</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner || _operatorApprovals[owner][msg.sender],</span><br><span class="line">            &quot;not owner nor approved for all&quot;</span><br><span class="line">        );</span><br><span class="line">        _approve(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询 spender地址是否可以使用tokenId（他是owner或被授权地址）。</span><br><span class="line">    function _isApprovedOrOwner(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private view returns (bool) &#123;</span><br><span class="line">        return (spender == owner ||</span><br><span class="line">            _tokenApprovals[tokenId] == spender ||</span><br><span class="line">            _operatorApprovals[owner][spender]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //内部转账函数。将 tokenId 从 from 转账给 to</span><br><span class="line">    function _transfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private &#123;</span><br><span class="line">        require(from == owner, &quot;not owner&quot;);</span><br><span class="line">        require(to != address(0), &quot;transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[from] -= 1;</span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 实现IERC721的transferFrom，非安全转账，不建议使用。调用_transfer函数</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 安全转账，安全地将 tokenId 代币从 from 转移到 to，会检查合约接收者是否了解 ERC721 协议，以防止代币被永久锁定。调用了_transfer函数和_checkOnERC721Received函数。条件：</span><br><span class="line">     */</span><br><span class="line">    function _safeTransfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private &#123;</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">        require(_checkOnERC721Received(from, to, tokenId, _data), &quot;not ERC721Receiver&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721的safeTransferFrom，安全转账，调用了_safeTransfer函数。</span><br><span class="line">     */</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) public override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _safeTransfer(owner, from, to, tokenId, _data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // safeTransferFrom重载函数</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。</span><br><span class="line">     * 这个mint函数所有人都能调用，实际使用需要开发人员重写，加上一些条件。</span><br><span class="line">     * 条件:</span><br><span class="line">     * 1. tokenId尚不存在。</span><br><span class="line">     * 2. to不是0地址.</span><br><span class="line">     */</span><br><span class="line">    function _mint(address to, uint tokenId) internal virtual &#123;</span><br><span class="line">        require(to != address(0), &quot;mint to zero address&quot;);</span><br><span class="line">        require(_owners[tokenId] == address(0), &quot;token already minted&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(address(0), to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁函数，通过调整_balances和_owners变量来销毁tokenId，同时释放Transfer事件。条件：tokenId存在。</span><br><span class="line">    function _burn(uint tokenId) internal virtual &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(msg.sender == owner, &quot;not owner of token&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[owner] -= 1;</span><br><span class="line">        delete _owners[tokenId];</span><br><span class="line"></span><br><span class="line">        emit Transfer(owner, address(0), tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // _checkOnERC721Received：函数，用于在 to 为合约的时候调用IERC721Receiver-onERC721Received, 以防 tokenId 被不小心转入黑洞。</span><br><span class="line">    function _checkOnERC721Received(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private returns (bool) &#123;</span><br><span class="line">        if (to.isContract()) &#123;</span><br><span class="line">            return</span><br><span class="line">                IERC721Receiver(to).onERC721Received(</span><br><span class="line">                    msg.sender,</span><br><span class="line">                    from,</span><br><span class="line">                    tokenId,</span><br><span class="line">                    _data</span><br><span class="line">                ) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721Metadata的tokenURI函数，查询metadata。</span><br><span class="line">     */</span><br><span class="line">    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;Token Not Exist&quot;);</span><br><span class="line"></span><br><span class="line">        string memory baseURI = _baseURI();</span><br><span class="line">        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算&#123;tokenURI&#125;的BaseURI，tokenURI就是把baseURI和tokenId拼接在一起，需要开发重写。</span><br><span class="line">     * BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ </span><br><span class="line">     */</span><br><span class="line">    function _baseURI() internal view virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用 <code>tokenId </code>来表示特定的非同质化代币</p>
</li>
<li><p>函数</p>
<ul>
<li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li>
<li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li>
<li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>
<li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code></li>
<li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code></li>
<li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li>
<li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li>
<li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li>
<li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li>
<li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li>
<li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发3出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li>
</ul>
</li>
<li><p>检测目标函数是否实现 <code>ERC721Receiver</code> 接口，实现这则说明拥有管理NFT的能力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function _checkOnERC721Received(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint tokenId,</span><br><span class="line">    bytes memory _data</span><br><span class="line">) private returns (bool) &#123;</span><br><span class="line">    if (to.isContract()) &#123;</span><br><span class="line">    	return IERC721Receiver(to).onERC721Received(</span><br><span class="line">            msg.sender,</span><br><span class="line">            from,</span><br><span class="line">            tokenId,</span><br><span class="line">            _data</span><br><span class="line">    	) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a>ERC1155</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/AmazingAng/WTFSolidity/blob/main/34_ERC721/IERC165.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC1155标准的接口合约，实现了EIP1155的功能</span><br><span class="line"> * 详见：https://eips.ethereum.org/EIPS/eip-1155[EIP].</span><br><span class="line"> */</span><br><span class="line">interface IERC1155 is IERC165 &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev 单类代币转账事件</span><br><span class="line">     * 当`value`个`id`种类的代币被`operator`从`from`转账到`to`时释放.</span><br><span class="line">     */</span><br><span class="line">    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 批量代币转账事件</span><br><span class="line">     * ids和values为转账的代币种类和数量数组</span><br><span class="line">     */</span><br><span class="line">    event TransferBatch(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed from,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256[] ids,</span><br><span class="line">        uint256[] values</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 批量授权事件</span><br><span class="line">     * 当`account`将所有代币授权给`operator`时释放</span><br><span class="line">     */</span><br><span class="line">    event ApprovalForAll(address indexed account, address indexed operator, bool approved);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 当`id`种类的代币的URI发生变化时释放，`value`为新的URI</span><br><span class="line">     */</span><br><span class="line">    event URI(string value, uint256 indexed id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 持仓查询，返回`account`拥有的`id`种类的代币的持仓量</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(address account, uint256 id) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 批量持仓查询，`accounts`和`ids`数组的长度要想等。</span><br><span class="line">     */</span><br><span class="line">    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256[] memory);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 批量授权，将调用者的代币授权给`operator`地址。</span><br><span class="line">     * 释放&#123;ApprovalForAll&#125;事件.</span><br><span class="line">     */</span><br><span class="line">    function setApprovalForAll(address operator, bool approved) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 批量授权查询，如果授权地址`operator`被`account`授权，则返回`true`</span><br><span class="line">     * 见 &#123;setApprovalForAll&#125;函数.</span><br><span class="line">     */</span><br><span class="line">    function isApprovedForAll(address account, address operator) external view returns (bool);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 安全转账，将`amount`单位`id`种类的代币从`from`转账给`to`.</span><br><span class="line">     * 释放&#123;TransferSingle&#125;事件.</span><br><span class="line">     * 要求:</span><br><span class="line">     * - 如果调用者不是`from`地址而是授权地址，则需要得到`from`的授权</span><br><span class="line">     * - `from`地址必须有足够的持仓</span><br><span class="line">     * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155Received`方法，并返回相应的值</span><br><span class="line">     */</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 id,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 批量安全转账</span><br><span class="line">     * 释放&#123;TransferBatch&#125;事件</span><br><span class="line">     * 要求：</span><br><span class="line">     * - `ids`和`amounts`长度相等</span><br><span class="line">     * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155BatchReceived`方法，并返回相应的值</span><br><span class="line">     */</span><br><span class="line">    function safeBatchTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256[] calldata ids,</span><br><span class="line">        uint256[] calldata amounts,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>支持一个合约包含多种代币，在gamefi运用的比较多</p>
</li>
<li><p>事件</p>
<ul>
<li><code>TransferSingle</code>事件：单类代币转账事件，在单币种转账时释放。</li>
<li><code>TransferBatch</code>事件：批量代币转账事件，在多币种转账时释放。</li>
<li><code>ApprovalForAll</code>事件：批量授权事件，在批量授权时释放。</li>
<li><code>URI</code>事件：元数据地址变更事件，在<code>uri</code>变化时释放。</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li><p><code>balanceOf()</code>：单币种余额查询，返回<code>account</code>拥有的<code>id</code>种类的代币的持仓量。</p>
</li>
<li><p><code>balanceOfBatch()</code>：多币种余额查询，查询的地址<code>accounts</code>数组和代币种类<code>ids</code>数组的长度要相等。</p>
</li>
<li><p><code>setApprovalForAll()</code>：批量授权，将调用者的代币授权给<code>operator</code>地址。。</p>
</li>
<li><p><code>isApprovedForAll()</code>：查询批量授权信息，如果授权地址<code>operator</code>被<code>account</code>授权，则返回<code>true</code>。</p>
</li>
<li><p><code>safeTransferFrom()</code>：安全单币转账，将<code>amount</code>单位<code>id</code>种类的代币从<code>from</code>地址转账给<code>to</code>地址。如果<code>to</code>地址是合约，则会验证是否实现了<code>onERC1155Received()</code>接收函数。</p>
</li>
<li><p><code>safeBatchTransferFrom()</code>：安全多币转账，与单币转账类似，只不过转账数量<code>amounts</code>和代币种类<code>ids</code>变为数组，且长度相等。如果<code>to</code>地址是合约，则会验证是否实现了<code>onERC1155BatchReceived()</code>接收函数。</p>
</li>
</ul>
</li>
<li><p>与<code>ERC721</code>标准类似，为了避免代币被转入黑洞合约，<code>ERC1155</code>要求代币接收合约继承<code>IERC1155Receiver</code>并实现两个接收函数：</p>
<ul>
<li><code>onERC1155Received()</code>：单币转账接收函数，接受ERC1155安全转账<code>safeTransferFrom</code> 需要实现并返回自己的选择器<code>0xf23a6e61</code>*或 <code>bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))</code>*。</li>
<li><code>onERC1155BatchReceived()</code>：多币转账接收函数，接受ERC1155安全多币转账<code>safeBatchTransferFrom</code> 需要实现并返回自己的选择器<code>0xbc197c81</code>*或 <code>bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))</code>*。</li>
</ul>
</li>
</ul>
<h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><h3 id="Atomico"><a href="#Atomico" class="headerlink" title="Atomico"></a>Atomico</h3><h2 id="权益证明协议"><a href="#权益证明协议" class="headerlink" title="权益证明协议"></a>权益证明协议</h2><h3 id="Casper"><a href="#Casper" class="headerlink" title="Casper"></a>Casper</h3><ul>
<li>ETH中使用的权益证明协议</li>
<li>有一个验证者Validator<ul>
<li>需要投入一定的以太币来充当该角色</li>
<li>以50个区块为一个epoch</li>
<li>使用两阶段提交</li>
<li>每轮需要2&#x2F;3的验证者通过</li>
</ul>
</li>
<li>需要交保证金才能成为验证者<ul>
<li>如果没有完成它的职责，则会被扣除部分保证金</li>
<li>如果两边投票则没收全部保证金</li>
</ul>
</li>
</ul>
<h2 id="系统协议"><a href="#系统协议" class="headerlink" title="系统协议"></a>系统协议</h2><h3 id="EIP-2535-Diamonds"><a href="#EIP-2535-Diamonds" class="headerlink" title="EIP-2535 Diamonds"></a>EIP-2535 Diamonds</h3><ul>
<li>是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8D%8F%E8%AE%AE/" data-id="clrj8k01c00504wuw6skp2bhl" data-title="区块链协议" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web3/" rel="tag">web3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/基础/区块链安全" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.657Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3/">Web3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/">区块链安全</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h3><h4 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h4><ul>
<li>create和cteate2联合部署a, b, c 合约，暗中修改c合约代码并部署在原来的地址上<ul>
<li>a合约通过create2部署b合约，b合约通过create部署c合约</li>
<li>然后b，c合约调用自毁函数</li>
<li>然后b，c合约重新部署，此时c的代码是可以和原来不一样的</li>
<li>因为b自毁后重新部署其nonce值会重置，所以c还是部署在原来的地址上</li>
<li>起到欺诈的作用</li>
</ul>
</li>
</ul>
<h3 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h3><ul>
<li>51%攻击<ul>
<li>51%算力攻击：拥有了一半的算力</li>
<li>51%货币攻击：拥有了一半的投票权和决定权</li>
</ul>
</li>
<li>双花攻击</li>
<li>日蚀攻击<ul>
<li>孤立节点，恶意节点通过操控该节点可以接收和联系到的节点实现</li>
<li>恶意节点需要有足够的带宽资源才能发动日蚀攻击</li>
<li>如果该恶意节点拥有40%算力，它可以将比特币网络拆分为两个分区，然后在两个分区中都发起51%攻击</li>
<li>如果恶意者只有网络带宽资源而没有算力，依然可以实现双花攻击</li>
</ul>
</li>
<li>预言机攻击</li>
<li>矿池过度套利，过度闪电贷</li>
<li>链桥攻击</li>
<li>自治管理攻击</li>
<li>先跑攻击<ul>
<li>利用更高的gas费来使交易更快的执行</li>
</ul>
</li>
<li>重入攻击<ul>
<li><p>通过fallback函数实现取款反调用操作，实现循环取币</p>
</li>
<li><p>解决方法</p>
<ul>
<li><p>需要先把账户进行结算，再进行转账</p>
</li>
<li><p>使用重入锁，是一个函数修改器，用一个布尔值来防止重入</p>
</li>
</ul>
</li>
</ul>
</li>
<li>数学溢出<ul>
<li><p>solidity8.0通过安全数学和自动检测</p>
</li>
<li><p>使用openzeppelin中的安全数学库</p>
</li>
</ul>
</li>
<li>权限管理漏洞</li>
<li>退款恶意<ul>
<li>接受退款的合约在其receive或者fallback函数中写了恶意消耗gas的代码，使其他合约退款或转账失败</li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>调用其他合约的方法时要小心被反调用</li>
<li>要记得写fallback函数</li>
</ul>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/" data-id="clrj8k01a004r4wuw5ljz72we" data-title="区块链安全" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web3/" rel="tag">web3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/基础/Solidity" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/Solidity/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.656Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3/">Web3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/Solidity/">Solidity</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>用于智能合约开发，是面向对象的，强类型语言</li>
<li>单线程的，线程安全</li>
<li>使用时需要先声明Solidity的版本号</li>
<li>使用remix开发<ul>
<li><a target="_blank" rel="noopener" href="https://remix.ethereum.org/">https://remix.ethereum.org</a></li>
</ul>
</li>
<li>智能合约是用来编写控制逻辑的</li>
<li>发布到区块链上的交易不一定都是成功执行的<ul>
<li>为了扣除汽油费</li>
</ul>
</li>
<li>智能合约可以获得的信息比较有限<ul>
<li>因为每个节点的环境不同</li>
</ul>
</li>
<li>智能合约编译后的字节码最大不超过24KB</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//声明使用的solidity版本</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">//合约</span><br><span class="line">contract A &#123;</span><br><span class="line">	</span><br><span class="line">	//状态变量</span><br><span class="line">	string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">	</span><br><span class="line">	//方法</span><br><span class="line">    function method1 public &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>constant</td>
<td>定义常量</td>
<td>gas费较低，不能修改</td>
</tr>
<tr>
<td>immutable</td>
<td>将变量定义为常量</td>
<td>gas费较低，需要赋值</td>
</tr>
<tr>
<td>indexed</td>
<td>事件中用于修饰变量，他们会保存在以太坊虚拟机日志的 topics 中</td>
<td>相当于检索事件的索引“键”，方便搜索，大小为固定的256比特，超过这个大小会自动计算成哈希存储</td>
</tr>
<tr>
<td>ether</td>
<td>以太坊代币单位</td>
<td>1 ether &#x3D; 10^18 wei</td>
</tr>
<tr>
<td>memory</td>
<td>将变量存储在内存</td>
<td>只在函数调用期间存在，函数执行结束就会被清除，消耗<code>gas</code>少</td>
</tr>
<tr>
<td>Storage</td>
<td>变量会永久存储在区块链</td>
<td>函数之外声明的变量默认为<code>storage</code>类型，消耗<code>gas</code>多</td>
</tr>
<tr>
<td>calldata</td>
<td>将变量存储在函数之外</td>
<td>只能修饰输入参数，不能修改，函数间传递参数消耗<code>gas</code>少</td>
</tr>
<tr>
<td>public</td>
<td>公共的</td>
<td>修饰的状态变量会生成访问函数，修饰的函数可以被调用，内外部都可以调用</td>
</tr>
<tr>
<td>private</td>
<td>私有的</td>
<td>合约内部可用，不可被继承，比public节约gas</td>
</tr>
<tr>
<td>external</td>
<td>外部的</td>
<td>只能通过外部读取函数，可以通过this调用但消耗gas，不可被继承</td>
</tr>
<tr>
<td>internal</td>
<td>内部的</td>
<td>合约内部可用，可以被继承</td>
</tr>
<tr>
<td>payable</td>
<td>付费</td>
<td>调用合约方法需要转账，标记的地址可以发送代币</td>
</tr>
<tr>
<td>view</td>
<td>可视的</td>
<td>可以读取状态变量，不能修改状态变量</td>
</tr>
<tr>
<td>pure</td>
<td>纯函数</td>
<td>不能读取状态变量，只能拥有局部变量，用户调用pure函数不用gas，合约调用需要支付gas</td>
</tr>
<tr>
<td>virtual</td>
<td>可重写的</td>
<td></td>
</tr>
<tr>
<td>override</td>
<td>重写的</td>
<td>修饰 <code>public</code> 变量会重写该变量的 get 方法</td>
</tr>
<tr>
<td>returns</td>
<td>返回值</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>值传递还是引用传递<ul>
<li>函数外的storage状态变量赋值给函数内的storage变量时，修改函数内storage变量<strong>会影响</strong>函数外的状态变量</li>
<li>函数外的storage状态变量赋值给函数内的memory变量时，修改函数内memory变量<strong>不会影响</strong>函数外的状态变量</li>
<li>memory变量赋值给memory变量时，会影响原变量</li>
<li>变量赋值给storage变量，会创建独立的副本</li>
</ul>
</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>分为状态变量，局部变量和全局变量</p>
<ul>
<li>状态变量：写在合约内函数外，如果没有提供修改的方法，那么它将永远的写在区块链上了</li>
<li>局部变量：写在函数内，调用函数时就会在虚拟机中产生</li>
<li>全局变量：内置变量</li>
</ul>
</li>
<li><p>状态变量默认是internal</p>
</li>
<li><p>局部变量不能使用public</p>
</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
<th>备注</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte、bytes8、bytes32</td>
<td></td>
<td>固定长度，十六进制</td>
<td>0x00…</td>
</tr>
<tr>
<td>int、uint、uint8、uint32、uint256</td>
<td>整型、正整数</td>
<td>int默认是256位的，uint256(-1)是最大值</td>
<td>0</td>
</tr>
<tr>
<td>bool</td>
<td>布尔</td>
<td>true &#x2F; false</td>
<td>false</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
<td>消耗的gas多</td>
<td>“”</td>
</tr>
</tbody></table>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
<th>备注</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>address</td>
<td>地址信息</td>
<td>十六进制</td>
<td>0x00地址</td>
</tr>
<tr>
<td>mapping</td>
<td>映射 &#x2F; hash表</td>
<td>不支持遍历，默认值0，key不能是结构体</td>
<td>type的默认值</td>
</tr>
<tr>
<td>bytes &#x2F; bytes1[]</td>
<td>字节数组</td>
<td>bytes的gas更便宜</td>
<td>动态：[] <br />静态：类型默认值</td>
</tr>
<tr>
<td>struct</td>
<td>结构体</td>
<td>创建对象不用new</td>
<td>成员默认值</td>
</tr>
<tr>
<td>enum</td>
<td>枚举</td>
<td>取值是取下标</td>
<td>第一个值</td>
</tr>
</tbody></table>
<ul>
<li><p>mapping</p>
<ul>
<li>使用<code>keccak256(key)</code>当成offset存取value。</li>
</ul>
</li>
<li><p>address</p>
<ul>
<li><p>在以太坊中存储的是20字节的值，即uint160</p>
</li>
<li><p>address有成员变量，用payable修饰的地址多了 <code>transfer</code> 和 <code>send</code> 成员变量</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>push</td>
<td>将元素插入数组尾部</td>
<td>动态数组才可以使用该方法</td>
</tr>
<tr>
<td>delete</td>
<td>将指定的元素变为默认值</td>
<td>delete 数组[下标]，不改变数组长度</td>
</tr>
<tr>
<td>pop</td>
<td>弹出数组尾部元素</td>
<td>数组的长度会-1</td>
</tr>
<tr>
<td>length</td>
<td>获取数组中元素个数</td>
<td></td>
</tr>
</tbody></table>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
<th>返回值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>msg.sender</td>
<td>调用者地址</td>
<td>address</td>
<td></td>
</tr>
<tr>
<td>msg.value</td>
<td>获取payable的转账金额</td>
<td></td>
<td></td>
</tr>
<tr>
<td>msg.data</td>
<td>完整的调用信息calldata</td>
<td></td>
<td>前4个字节为函数选择器selector<br />后面32个字节为输入的参数</td>
</tr>
<tr>
<td>msg.gas</td>
<td>剩余的gas</td>
<td></td>
<td></td>
</tr>
<tr>
<td>msg.sig</td>
<td>calldata的前4个字节</td>
<td></td>
<td></td>
</tr>
<tr>
<td>block.blockhash</td>
<td>获得最近256个区块的哈希值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>block.coinbase</td>
<td>当前块矿工地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td>block.diffculty</td>
<td>当前块难度</td>
<td></td>
<td></td>
</tr>
<tr>
<td>block.gaslimit</td>
<td>当前块gas限制</td>
<td></td>
<td></td>
</tr>
<tr>
<td>block.number</td>
<td>当前块区块号</td>
<td>uint</td>
<td></td>
</tr>
<tr>
<td>block.timestamp</td>
<td>当前块时间戳</td>
<td>uint</td>
<td></td>
</tr>
<tr>
<td>now</td>
<td>当前区块</td>
<td></td>
<td></td>
</tr>
<tr>
<td>gasleft</td>
<td>剩余的gas</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tx.gasprice</td>
<td>当前交易的gas价格</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tx.origin</td>
<td>交易的发送者</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>msg.data一般包含2个部分<ul>
<li>函数签名：函数名称 + 参数类型 &#x3D;&gt; hash 后取前四位bytes值</li>
<li>参数</li>
</ul>
</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function test() public &#123;</span><br><span class="line">	//if-else</span><br><span class="line">	if(条件判断)&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;else if(条件判断)&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //三元</span><br><span class="line">    条件判断 ? 返回值2 : 返回值2</span><br><span class="line">    </span><br><span class="line">    //for循环</span><br><span class="line">    for(uint i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //while循环</span><br><span class="line">    while(i &lt; 10)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //do-while循环</span><br><span class="line">    do&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;while(i &lt; 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract A&#123;	</span><br><span class="line">	//需要子类重写的方法</span><br><span class="line">	function a() virtual&#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract B is A&#123;</span><br><span class="line">	function b()&#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">    //重写父类方法</span><br><span class="line">    function a() override&#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修饰器也可以被继承，也可以重写</p>
</li>
<li><p>调用父合约</p>
<ul>
<li>通过父合约名.函数名</li>
<li>通过super.函数名<ul>
<li>会执行最远的父合约函数</li>
</ul>
</li>
</ul>
</li>
<li><p>父类构造函数需要传参的情况</p>
<ul>
<li><p>可以在继承时在父类合约名后加上参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract C is  A(参数), B(参数)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在子类构造函数中传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C is A, B&#123;</span><br><span class="line">	constructor(参数1, 参数2) A(参数1) B(参数2)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract a&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">contract b is a&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">contract c is a&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">contract d is b, c&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>允许多继承，同名函数遵循最远继承规则<ul>
<li>多继承时父类的顺序应该由高到低</li>
<li>多个父类都有的函数子类必须重写</li>
<li>重写多个父类都有的函数时，需要标注所有父合约的名字<ul>
<li><code>override(父a，父b ...)</code></li>
</ul>
</li>
</ul>
</li>
<li>钻石继承<ul>
<li>即父合约之间继承于同一个合约</li>
<li>使用super时每一个父合约的函数都会被执行，但顶级合约的函数只会执行一次</li>
</ul>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><p>是EVM上对日志的抽象</p>
</li>
<li><p>接口订阅和监听</p>
</li>
<li><p>存储数据，每个大概消耗2,000 gas，链上存储至少需要20,000 gas</p>
</li>
<li><p>是一种写入方法，所以不能被标记为view &#x2F; pure</p>
</li>
<li><p>事件的参数可以使用indexed标记，标记过的变量就可以在链外进行搜索查询</p>
<ul>
<li>最多只能标记三个变量</li>
</ul>
</li>
<li><p>用法</p>
<ul>
<li>发生代币转移时</li>
<li>部署合约时返回合约地址</li>
</ul>
</li>
</ul>
<h3 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract a &#123;</span><br><span class="line">	//建立事件</span><br><span class="line">    event 事件名(类型 [indexed] 参数a ...)</span><br><span class="line">    //使用 emit 激活 / 调用事件</span><br><span class="line">    emit 事件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>require</td>
<td>条件、异常描述</td>
<td>要求达到对应的条件，不会消耗gas并终止执行</td>
</tr>
<tr>
<td>assert</td>
<td>条件</td>
<td>断言，会消耗gas并继续执行</td>
</tr>
<tr>
<td>revert</td>
<td></td>
<td>直接抛出异常，不需要写条件，会消耗gas</td>
</tr>
<tr>
<td>error</td>
<td>方法</td>
<td>自定义错误，可以携带信息，gas更低</td>
</tr>
</tbody></table>
<h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error thorized(类型 变量名);</span><br><span class="line">contract a &#123;</span><br><span class="line">	function method() public &#123;</span><br><span class="line">		revert thorized(变量);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节约gas费</li>
<li>能够在错误中定义变量，即抛出异常时可以抛出变量，报错信息详细</li>
<li>可以定义在合约中或者合约外</li>
</ul>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try externalContract.f() [returns(类型 val)]&#123;</span><br><span class="line">	// call成功的情况下 运行一些代码</span><br><span class="line">&#125; catch Error(string memory reason) &#123;</span><br><span class="line">	// 捕获失败的 revert() 和 require()</span><br><span class="line">&#125; catch (bytes memory reason) &#123;</span><br><span class="line">	// 捕获失败的 assert()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有<code>external</code> 函数和构造函数可以使用</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>函数默认会分配4个32字节的内存空间</li>
<li>函数可以重载，即同名不同参数</li>
</ul>
<h3 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract A &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    //在合约部署的时候会调用一次，是不会写到链上的</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	//普通函数</span><br><span class="line">	//有返回值名的情况下函数体内可以不用写return语句，隐式返回</span><br><span class="line">    function 函数名 [修饰符...] [returns (类型 返回值1 [, 类型 返回值2, ...])] &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //fallback函数</span><br><span class="line">    fallback() external payable&#123;&#125;</span><br><span class="line">    //receive函数</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fallback 和 receive函数<ul>
<li>都是作为兜底函数，即外部合约调用了不存在的函数时会调用这两个函数<ul>
<li>调用时如果没传入数据会执行receive函数，前提是有定义receive函数，其他情况都是调用的fallback函数</li>
</ul>
</li>
<li>需要<code>payable、external</code>关键字</li>
<li>receive和fallback不要写太多逻辑，因为如果是send&#x2F;transfer转账的话gas费只有2300，容易超出</li>
</ul>
</li>
</ul>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
<th>参数</th>
<th>返回值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>creationCode</td>
<td>获取合约代码</td>
<td></td>
<td></td>
<td>type(合约).creationCode</td>
</tr>
<tr>
<td>address</td>
<td>获取地址</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>balance</td>
<td>获取合约余额</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transfer</td>
<td>转账</td>
<td></td>
<td></td>
<td>余额不足会报错，2300gas</td>
</tr>
<tr>
<td>send</td>
<td>转账</td>
<td></td>
<td>bool</td>
<td>余额不足情况需要处理，2300gas</td>
</tr>
<tr>
<td>call</td>
<td>转账 &#x2F; 调用合约</td>
<td>{[value:ETH数],[gas:gas数]}(转账金额 &#x2F; 二进制编码)</td>
<td>bool,data</td>
<td>余额不足情况需要处理，支付全部gas</td>
</tr>
<tr>
<td>callcode</td>
<td>转账 &#x2F; 调用合约</td>
<td></td>
<td></td>
<td>调用底层</td>
</tr>
<tr>
<td>delegatecall</td>
<td>转账 &#x2F; 调用合约</td>
<td></td>
<td></td>
<td>可以发gas，不能发eth</td>
</tr>
<tr>
<td>staticall</td>
<td>静态调用</td>
<td></td>
<td></td>
<td>不会有写入操作</td>
</tr>
<tr>
<td>keccak256</td>
<td>将任何长度的数据转换为256位的哈希值</td>
<td>数据</td>
<td>bytes32</td>
<td>哈希算法</td>
</tr>
<tr>
<td>create</td>
<td></td>
<td>创建者地址，nonce</td>
<td>不准确</td>
<td></td>
</tr>
<tr>
<td>create2</td>
<td>预测合约部署后的地址</td>
<td>常数，创建者地址，盐，机器码</td>
<td>8.0新特性</td>
<td></td>
</tr>
<tr>
<td>abi.encode</td>
<td>压缩</td>
<td></td>
<td>bytes</td>
<td>会将每个参数用0填充到32字节，避免hash碰撞</td>
</tr>
<tr>
<td>abi.encodePacked</td>
<td>压缩</td>
<td></td>
<td>bytes</td>
<td>不定长的，有一定的压缩，如果参数是连续的字符串可能会出现hash碰撞</td>
</tr>
<tr>
<td>abi.decode</td>
<td>解码</td>
<td>bytes, (类型)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>abi.encodeWithSignature</td>
<td>获得二进制编码</td>
<td>函数(参数类型)，参数</td>
<td></td>
<td>第一个参数为函数签名</td>
</tr>
<tr>
<td>abi.encodeWithSelector</td>
<td>获得二进制编码</td>
<td>地址.函数.selector，参数</td>
<td>bytes</td>
<td></td>
</tr>
<tr>
<td>ecrecover</td>
<td>获取消息的签名者地址</td>
<td>加密信息，签名</td>
<td>address</td>
<td></td>
</tr>
<tr>
<td>selfdestruct</td>
<td>自毁合约</td>
<td>address</td>
<td>&#x2F;</td>
<td>强制发送剩余代币</td>
</tr>
</tbody></table>
<ul>
<li>create和create2<ul>
<li>create2创建合约时，目标智能合约的构造函数中不能有参数，create可以有参数</li>
<li>create函数不能创建已经创建过的地址，create2可以<ul>
<li>因为nonce指的是交易数，之前部署过了nonce会增加</li>
<li>为什么会要创建已经创建过的地址呢，是因为合约自销毁后想重新部署到源地址就无法实现了</li>
</ul>
</li>
</ul>
</li>
<li>ABI函数<ul>
<li>配合call实现底层调用</li>
<li>ether.js中实现合约的导入和函数调用</li>
<li>对不开源的合约进行反编译后，由于查不到函数名，所以可以通过abi进行调用</li>
</ul>
</li>
</ul>
<h3 id="合约外函数"><a href="#合约外函数" class="headerlink" title="合约外函数"></a>合约外函数</h3><ul>
<li>在8.0之后允许函数定义在合约外</li>
</ul>
<h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//权限校验</span><br><span class="line">modifier auth()&#123;</span><br><span class="line">	require(</span><br><span class="line">		//检验逻辑，返回布尔类型</span><br><span class="line">	);</span><br><span class="line">	_;</span><br><span class="line">&#125;</span><br><span class="line">//代码复用(三明治结构)</span><br><span class="line">modifier rep([参数])&#123;</span><br><span class="line">	//代码</span><br><span class="line">	_;//被修饰函数中的代码</span><br><span class="line">	//代码</span><br><span class="line">&#125;</span><br><span class="line">//对应的方法上添加修饰器即可生效</span><br><span class="line">function test() public auth rep([参数])&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数签名-选择器"><a href="#函数签名-选择器" class="headerlink" title="函数签名 &#x2F; 选择器"></a>函数签名 &#x2F; 选择器</h3><ul>
<li>calldata中的前4个字节为函数选择器，是将函数经过哈希运算求得<ul>
<li><code>bytes4(keccak256(&quot;函数名(参数类型)&quot;))</code></li>
</ul>
</li>
<li>有可能会发生冲突<ul>
<li>可以使用透明代理和通用可升级代理解决</li>
<li>透明代理：代理合约的fallback函数限制管理员调用</li>
<li>通用可升级代理：将代理合约中的升级函数放在逻辑函数中</li>
</ul>
</li>
</ul>
<h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><h3 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//直接创建合约对象</span><br><span class="line">合约名 合约对象 = new 合约名();</span><br><span class="line"></span><br><span class="line">//间接创建合约对象</span><br><span class="line">address addr = new 合约名();</span><br><span class="line">合约名 合约对象 = 合约名(address);</span><br><span class="line"></span><br><span class="line">//工厂合约创建合约对象</span><br><span class="line">contract A&#123;&#125;</span><br><span class="line">contract AFactory&#123;</span><br><span class="line">	A[] public As;</span><br><span class="line">	function createA()&#123;</span><br><span class="line">		As.push(new A())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合约调用"><a href="#合约调用" class="headerlink" title="合约调用"></a>合约调用</h3><ul>
<li><p>外部用户直接调用合约</p>
<ul>
<li>合约对象直接调用出现错误时，调用方会出现错误并回滚</li>
</ul>
</li>
<li><p>外部用户间接调用合约</p>
<ul>
<li>call<ul>
<li>格式： <code>合约地址.call(abi.encodeWithSignature(&quot;函数名(参数类型1, 参数类型2...)&quot;, 参数1, 参数2...))</code></li>
<li>调用合约出现错误时，调用方不会回滚</li>
<li>call通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code></li>
<li>call调用会切换上下文，即进入到被调用的合约内部</li>
<li>不建议直接通过call来调用合约，因为主动权给了被调用的合约，有安全风险，推荐通过创建合约对象来调用</li>
</ul>
</li>
<li>delegatecall<ul>
<li>用法和call一致</li>
<li>调用合约出现错误时，调用方不会回滚</li>
<li>不会切换上下文，即还在调用方合约，即委托合约内部</li>
<li>不能使用value方法</li>
<li>delegatecall有安全隐患，需要保证当前合约和目标合约的状态变量类型相同，并且目标合约安全</li>
<li>delegatecall 调用目标合约时，调用者是调用delegatecall的源头</li>
</ul>
</li>
</ul>
</li>
<li><p>合约调用合约</p>
<ul>
<li><p>需要有被调用合约的地址，且知道其函数信息才可以调用</p>
</li>
<li><p>需要传递代币的话就用 <code>&#123;value: msg.value&#125;</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">	function testA1(address _B)&#123;</span><br><span class="line">		B(_B).testB1()</span><br><span class="line">    &#125;</span><br><span class="line">    function testA2(B _B)&#123;</span><br><span class="line">		_B.testB1()</span><br><span class="line">    &#125;</span><br><span class="line">    function testA3(address _B)&#123;</span><br><span class="line">		B(_B).testB2&#123;value: msg.value&#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract B &#123;</span><br><span class="line">	function testB1()&#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">    function testB2() payable&#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>多重调用</p>
<ul>
<li>将对合约的多次调用整合到一个交易中，再对合约进行调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">contract TestMultiCall &#123;</span><br><span class="line">    function test(uint _i) external pure returns (uint) &#123;</span><br><span class="line">        return _i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData(uint _i) external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSelector(this.test.selector, _i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//多重调用合约</span><br><span class="line">contract MultiCall &#123;</span><br><span class="line">    function multiCall(address[] calldata targets, bytes[] calldata data)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (bytes[] memory)</span><br><span class="line">    &#123;</span><br><span class="line">        require(targets.length == data.length, &quot;target length != data length&quot;);</span><br><span class="line"></span><br><span class="line">        bytes[] memory results = new bytes[](data.length);</span><br><span class="line"></span><br><span class="line">        for (uint i; i &lt; targets.length; i++) &#123;</span><br><span class="line">            (bool success, bytes memory result) = targets[i].staticcall(data[i]);</span><br><span class="line">            require(success, &quot;call failed&quot;);</span><br><span class="line">            results[i] = result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多重委托调用</p>
<ul>
<li>只能调用自身的合约方法，即如果调用他人的合约即无法使用</li>
<li>注意在合约调用中不要重复计算主币数量，或者让多重委托调用合约不能接受主币</li>
</ul>
</li>
</ul>
<h3 id="代理合约"><a href="#代理合约" class="headerlink" title="代理合约"></a>代理合约</h3><ul>
<li>为了解决合约的更新问题，因为链上代码不可变和数据迁移的费用昂贵</li>
<li>委托调用不会改变逻辑合约中的值，改变的是代理合约的值，即使用逻辑合约的逻辑</li>
<li>代理模式将合约数据和逻辑分开，分别保存在不同合约中<ul>
<li>代理合约Proxy：存储所有相关的变量、逻辑合约的地址</li>
<li>逻辑合约Logic：存储所有的函数，通过<code>delegatecall</code>执行，逻辑合约也需要定义和代理合约完全一样的变量（类型 &#x2F; 顺序 &#x2F; 名称），在这些变量之后可以定义独有的变量</li>
</ul>
</li>
</ul>
<h3 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h3><ul>
<li>合约用<code>abstract</code> 修饰，合约中至少有一个没有被实现的函数，该函数需要标注<code>virtual</code></li>
</ul>
<h3 id="接口合约"><a href="#接口合约" class="headerlink" title="接口合约"></a>接口合约</h3><ul>
<li>不清楚目标合约的代码的具体信息，但知道其函数名称参数返回值等等，就可以通过接口合约调用</li>
<li>不能有状态变量、构造函数</li>
<li>只能继承接口合约，所有函数都得标注 <code>external</code></li>
<li>类似模拟了一个目标合约</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//目标合约</span><br><span class="line">contract TargetContract&#123;</span><br><span class="line">	//具体细节不明</span><br><span class="line">	function A()&#123;</span><br><span class="line">		//详细代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//接口合约</span><br><span class="line">interface ITargetContract&#123;</span><br><span class="line">	function A()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">contract Test&#123;</span><br><span class="line">	function test(address _TargetContract)&#123;</span><br><span class="line">		ITargetContract(_TargetContract).A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约</h3><ul>
<li><p>提取复用性强的代码作为库合约以便复用</p>
</li>
<li><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library a&#123;</span><br><span class="line">	//函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>特点</p>
<ul>
<li>不能存在状态变量</li>
<li>不能够继承或被继承</li>
<li>不能接收以太币</li>
<li>不可以被销毁</li>
<li>一般会将函数定义为 internal</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>使用 <code>using 库合约 for 类型</code> 使该类型可以直接调用库合约方法</li>
<li>使用 <code>库合约名.函数</code></li>
</ul>
</li>
<li><p>常用库合约</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">String</a>：将<code>uint256</code>转换为<code>String</code></li>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</li>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>Create2 EVM opcode</code></li>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库函数</li>
</ul>
</li>
</ul>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><ul>
<li>防止函数被重复调用</li>
<li>使用函数修改器实现</li>
</ul>
<h3 id="时间锁"><a href="#时间锁" class="headerlink" title="时间锁"></a>时间锁</h3><ul>
<li>保护管理员权限，将操作排进队列中，经过一段时间后执行</li>
</ul>
<h3 id="代币锁"><a href="#代币锁" class="headerlink" title="代币锁"></a>代币锁</h3><ul>
<li>可以把合约中的代币锁仓一段时间，受益人在锁仓期满后才可以取走代币</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>合约执行具有原子性，发生异常时消耗的汽油费不会退回</li>
<li>常见错误情况<ul>
<li>汽油费不够</li>
<li>出现异常</li>
</ul>
</li>
</ul>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>解决solidity现有方法中无法实现的一些操作</li>
<li>使用内联汇编自由度更高，性能更强，节约gas费</li>
<li>格式为使用 assembly{} 代码块</li>
<li>批量操作适合使用内联汇编</li>
<li>因为EVM时基于栈的虚拟机，想要难道栈顶之外的数据比较困难，所以要使用内联汇编</li>
<li>可以获取合约的代码，并加载到bytes变量中</li>
<li>可以判断一个地址是合约地址还是用户地址</li>
<li>函数操作需要结合地址和数据</li>
</ul>
<h3 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//汇编代码块</span><br><span class="line">assembly&#123;</span><br><span class="line">	//通过let关键字来定义变量，作用域只在当前大括号中</span><br><span class="line">	let a := 1;</span><br><span class="line">	//for循环</span><br><span class="line">	for&#123;let i := 0&#125; lt(i, x) &#123;i := add(i ,1)&#125;&#123;</span><br><span class="line">		//循环体</span><br><span class="line">	&#125;</span><br><span class="line">	//if</span><br><span class="line">	if slt(x, 0)&#123;</span><br><span class="line">		//。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li><strong>算术和逻辑操作</strong>：<ul>
<li><strong>add</strong>：将栈上的两个元素相加。</li>
<li><strong>sub</strong>：从栈上的第二个元素中减去第一个元素。</li>
<li><strong>mul</strong>：将栈上的两个元素相乘。</li>
<li><strong>div</strong>：将栈上的第二个元素除以第一个元素（整数除法）。</li>
<li><strong>sdiv</strong>：带符号的整数除法。</li>
<li><strong>mod</strong>：取模运算。</li>
<li><strong>smod</strong>：带符号的取模运算。</li>
<li><strong>addmod</strong>：(x + y) mod z，加法后取模。</li>
<li><strong>mulmod</strong>：(x * y) mod z，乘法后取模。</li>
<li><strong>exp</strong>：指数运算。</li>
<li><strong>signextend</strong>：符号扩展。</li>
</ul>
</li>
<li><strong>比较和位操作</strong>：<ul>
<li><strong>lt</strong>、<strong>gt</strong>、<strong>slt</strong>、<strong>sgt</strong>、<strong>eq</strong>：比较栈上的两个元素，分别对应小于、大于、带符号小于、带符号大于、等于。</li>
<li><strong>iszero</strong>：如果栈顶元素为0，则返回1，否则返回0。</li>
<li><strong>and</strong>、<strong>or</strong>、<strong>xor</strong>、<strong>not</strong>：位运算。</li>
<li><strong>shiftleft</strong>、<strong>shiftright</strong>：位移操作。</li>
</ul>
</li>
<li><strong>内存和存储操作</strong>：<ul>
<li><strong>mstore</strong>、<strong>mstore8</strong>：将值存储到内存中。</li>
<li><strong>mload</strong>：从内存中加载z值</li>
<li><strong>sstore</strong>：将值存储到合约存储中。</li>
<li><strong>push</strong>、<strong>pop</strong>：栈操作，用于将值压入栈或从栈中弹出。</li>
</ul>
</li>
<li><strong>控制流</strong>：<ul>
<li><strong>jump</strong>、<strong>jumpi</strong>：跳转到指定位置。</li>
<li><strong>return</strong>：结束执行并返回结果。</li>
<li><strong>revert</strong>：停止执行。</li>
<li><strong>selfdestruct</strong>（原名为<code>suicide</code>）：销毁合约并发送资金。</li>
</ul>
</li>
<li><strong>栈操作</strong>：<ul>
<li><strong>dup</strong>：复制栈顶元素。</li>
<li><strong>swap</strong>：交换栈上的两个元素。</li>
</ul>
</li>
<li><strong>日志和事件</strong>：<ul>
<li><strong>log0</strong>、<strong>log1</strong>、<strong>log2</strong>、<strong>log3</strong>、<strong>log4</strong>：生成日志事件，用于外部监听和分析。</li>
</ul>
</li>
<li><strong>系统操作</strong>：<ul>
<li><code>blockhash</code>：获取指定区块的哈希。</li>
<li><code>coinbase</code>：获取当前区块的矿工地址。</li>
<li><code>timestamp</code>：获取当前区块的时间戳。</li>
<li><code>number</code>：获取当前区块号。</li>
<li><code>difficulty</code>：获取当前区块的难度。</li>
<li><code>gaslimit</code>：获取当前区块的燃气上限。</li>
<li><code>origin</code>：获取交易的发起者地址。</li>
<li><code>caller</code>：获取当前函数的调用者地址。</li>
<li><code>callvalue</code>：获取当前交易的金额（以wei为单位）。</li>
<li><code>calldataload</code>、<code>calldatasize</code>、<code>calldatacopy</code>：访问输入数据。</li>
<li><code>codesize</code>、<code>codecopy</code>：访问合约代码。</li>
<li><code>gasprice</code>：获取当前交易的燃气价格。</li>
<li><code>extcodesize</code>、<code>extcodecopy</code>：访问外部合约的代码。</li>
<li><code>returndatasize</code>、<code>returndatacopy</code>：访问返回值数据。</li>
</ul>
</li>
</ol>
<h2 id="8-0特性"><a href="#8-0特性" class="headerlink" title="8.0特性"></a>8.0特性</h2><h3 id="安全数学-SafeMath"><a href="#安全数学-SafeMath" class="headerlink" title="安全数学 SafeMath"></a>安全数学 SafeMath</h3><ul>
<li>提高安全的数学运算</li>
<li>自动检测溢出</li>
</ul>
<h3 id="Create2"><a href="#Create2" class="headerlink" title="Create2"></a>Create2</h3><ul>
<li>加盐部署，可以获得合约部署出的合约地址</li>
<li>在内联汇编中才可以使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//使用solidity实现</span><br><span class="line">//_salt作为参数传入</span><br><span class="line">Contract A = new A&#123;salt: byte32(_salt)&#125;();</span><br><span class="line">//获取部署合约的地址</span><br><span class="line">function getAddress(address addr, uint _salt)public view returns(address)&#123;</span><br><span class="line">	bytes memory bytecode = getCode(addr);</span><br><span class="line">	bytes32 hash = keccak256(abi.encodePacked(</span><br><span class="line">		//固定的1字节字符串 + he&#x27;yu地址 + 盐 + 待部署合约代码哈希</span><br><span class="line">		bytes1(0xff), address(this), _salt, keccak256(bytecode)</span><br><span class="line">	));</span><br><span class="line">	return address(uin160(uint(hash)));</span><br><span class="line">&#125;</span><br><span class="line">//获取bytecode</span><br><span class="line">function getBytecode(address _owner) public pure returns (bytes memory) &#123;</span><br><span class="line">	bytes memory bytecode = type(合约).creationCode;</span><br><span class="line">	return abi.encodePacked(bytecode, abi.encode(_owner));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//使用内联汇编实现</span><br><span class="line">//获取地址中的代码</span><br><span class="line">function getCode(address _addr) public view returns (bytes memory)&#123;</span><br><span class="line">	assembly&#123;</span><br><span class="line">		//获取代码长度</span><br><span class="line">		let size := extcodesize(_addr)</span><br><span class="line">		//分配一块足够大的内存空间</span><br><span class="line">		let codePtr := mload(0x40)</span><br><span class="line">		//初始化为20，预留空间给代码长度和代码本身</span><br><span class="line">		mstore(codePtr, 0x20);</span><br><span class="line">		let codeEnd := add(codePtr, 0x20)  </span><br><span class="line">		//把size存入该内存空间</span><br><span class="line">		mstore(add(codePtr, 0x10), size)</span><br><span class="line">		// 获取代码并保存  </span><br><span class="line">        extcodecopy(_addr, codePtr, size)  </span><br><span class="line">        // 更新代码结束位置  </span><br><span class="line">        mstore(codeEnd, mload(codeEnd))  </span><br><span class="line">        // 返回代码  </span><br><span class="line">        return(codePtr, size)  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">function deploy(bytes32 salt, address addr) public view returns (address pair)&#123;</span><br><span class="line">	bytes memory bytecode = getCode(addr);</span><br><span class="line">	assembly&#123;</span><br><span class="line">		pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function insertSort(uint[] memory a) public pure returns (uint[] memory) &#123;</span><br><span class="line">    for(uint i = 1; i &lt; a.length; ++i)&#123;</span><br><span class="line">        uint tmp = a[i];</span><br><span class="line">        uint j;</span><br><span class="line">        for(j = i; j &gt; 0 &amp;&amp;  a[j - 1] &gt; tmp; --j)&#123;</span><br><span class="line">        	a[j] = a[j-1];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">contract Verify&#123;</span><br><span class="line">    function verify(address _signer, string memory _message, bytes memory _sig) external pure returns(bool)&#123;</span><br><span class="line">    	//1. 将消息进行哈希</span><br><span class="line">    	bytes32 msgHash = getMsgHash(_message);</span><br><span class="line">    	//2. 将哈希消息拼接上一段字符串进行二次哈希</span><br><span class="line">    	bytes32 ethMsgHash = getEthMsgHash(msgHash);</span><br><span class="line">        //3. 验证签名和签名者是否一致</span><br><span class="line">        return recover(ethMsgHash, _sig) == _signer;</span><br><span class="line">    &#125;</span><br><span class="line">    //哈希</span><br><span class="line">    function getMsgHash(string memory _message) public pure returns(bytes32) &#123;</span><br><span class="line">    	return keccak256(abi.encodePacked(_message));</span><br><span class="line">    &#125;</span><br><span class="line">    //二次hash</span><br><span class="line">    function getEthMsgHash(bytes32 _message) public pure returns(bytes32) &#123;</span><br><span class="line">    	return keccak256(abi.encodePacked(</span><br><span class="line">    		&quot;\x19Ethereum Signed Message:\n32&quot;, _message</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    //取得加密消息中的签名用户地址</span><br><span class="line">    function recover(bytes32 _msg, bytes memory _sig) public pure returns(address)&#123;</span><br><span class="line">    	(bytes32 r, bytes32 s, uint8 v) = _split(_sig);</span><br><span class="line">    	return ecrecover(_msg, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line">    //分割签名取出r, s, v</span><br><span class="line">    function _split(bytes memory _sig) internal pure returns (bytes32 r, bytes32 s, uint8 v)&#123;</span><br><span class="line">    	//验证参数是否是65位的字符串</span><br><span class="line">    	require(_sig.length == 65, &quot;invalid signature length!&quot;)</span><br><span class="line">    	//sig = r + s + v</span><br><span class="line">    	assembly&#123;</span><br><span class="line">    		r := mload(add(_sig, 32))</span><br><span class="line">    		s := mload(add(_sig, 64))</span><br><span class="line">    		v := byte(0, mload(add(_sig, 96)))</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">contract AccessControl&#123;</span><br><span class="line">	event GrantRole(bytes32 indexed role, address indexed account);</span><br><span class="line">	event RevokeRole(bytes32 indexed role, address indexed account);</span><br><span class="line">	//角色映射集合</span><br><span class="line">	mapping(bytes32 =&gt; mapping(address =&gt; bool)) public roles;</span><br><span class="line">	</span><br><span class="line">	//角色</span><br><span class="line">	bytes32 private constant ADMIN = keccak256(abi.encodePacked(&quot;ADMIN&quot;));</span><br><span class="line">	bytes32 private constant USER = keccak256(abi.encodePacked(&quot;USER&quot;));</span><br><span class="line">	</span><br><span class="line">	//函数修饰器</span><br><span class="line">	modifier OnlyRole(bytes32 _role)&#123;</span><br><span class="line">		require(roles[_role][msg.sender], &quot;Not Authorized!&quot;);</span><br><span class="line">		_;</span><br><span class="line">    &#125;</span><br><span class="line">    //给合约部署者管理员权限</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    	_grantRole(ADMIN, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//升级角色-内部调用</span><br><span class="line">	function _grantRole(bytes32 _role, address _account) internal &#123;</span><br><span class="line">		roles[_role][_account] = true;</span><br><span class="line">		emit GrantRole(_role, _account);</span><br><span class="line">	&#125;</span><br><span class="line">	//升级角色</span><br><span class="line">	function grantRole(bytes32 _role, address _account) external OnlyRole(ADMIN)&#123;</span><br><span class="line">		_grantRole(_role, _account);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//撤销角色-内部调用</span><br><span class="line">	function _revokeRole(bytes32 _role, address _account) internal &#123;</span><br><span class="line">		roles[_role][_account] = false;</span><br><span class="line">		emit RevokeRole(_role, _account);</span><br><span class="line">	&#125;</span><br><span class="line">	//撤销角色</span><br><span class="line">	function revokeRole(bytes32 _role, address _account) external OnlyRole(ADMIN)&#123;</span><br><span class="line">		_revokeRole(_role, _account);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多签钱包"><a href="#多签钱包" class="headerlink" title="多签钱包"></a>多签钱包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">contract MultiSigWallet &#123;</span><br><span class="line">    event Deposit(address indexed sender, uint amount);//收款事件</span><br><span class="line">    event Submit(uint indexed txId);//提交交易事件</span><br><span class="line">    event Approve(address indexed owner, uint indexed txId);//批准交易事件</span><br><span class="line">    event Revoke(address indexed owner，uint indexed txId);//撤销批准事件</span><br><span class="line">    event Execute(uint indexed txId);//交易执行事件</span><br><span class="line">    </span><br><span class="line">    //拥有者列表</span><br><span class="line">    address[] public owners;</span><br><span class="line">    //拥有者地址映射</span><br><span class="line">    mapping(address =&gt; bool) public isOwner;</span><br><span class="line">    //交易确认数</span><br><span class="line">    uint public required;</span><br><span class="line">    </span><br><span class="line">    //交易结构</span><br><span class="line">    struct Transaction &#123;</span><br><span class="line">    	address to;</span><br><span class="line">    	uint value;</span><br><span class="line">    	bytes data;</span><br><span class="line">    	bool executed;</span><br><span class="line">    &#125;</span><br><span class="line">    //交易记录</span><br><span class="line">    Transaction[] public transactions;</span><br><span class="line">    //同意交易的拥有者</span><br><span class="line">    mapping(uint =&gt; mapping(address =&gt; bool)) public approved;</span><br><span class="line">    //设置持有者和交易确认数</span><br><span class="line">    constructor(address[] memory _owners, uint _required)&#123;</span><br><span class="line">    	require(_owners.length &gt; 0，&quot;owners required&quot;);</span><br><span class="line">    	require(</span><br><span class="line">    		_required &gt; 0 &amp;&amp; _required &lt;= owners.length,</span><br><span class="line">    		&quot;invalid required number of owners&quot;</span><br><span class="line">		);</span><br><span class="line">        for (uint i; i &lt; owners.length; i++) &#123;</span><br><span class="line">        	address owner = _owners[il;</span><br><span class="line">            require(owner != address(0)，&quot;invalidowner&quot;);</span><br><span class="line">            require(!isOwner[owner]，&quot;owner is not unique&quot;);</span><br><span class="line">            isOwner[owner] = true;</span><br><span class="line">            owners.push(owner);</span><br><span class="line">        &#125;</span><br><span class="line">        required = required;</span><br><span class="line">    &#125; </span><br><span class="line">    //接受主币</span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">    	emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">    	require(isOwner[msg.sender], &quot;Not Owner!&quot;);</span><br><span class="line">    	_;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier txExists(uint _txId)&#123;</span><br><span class="line">    	require(_txId &lt; transactions.length, &quot;Tx does not exist!&quot;);</span><br><span class="line">    	_;</span><br><span class="line">    &#125; </span><br><span class="line">    modifier notApproved(uint _txId)&#123;</span><br><span class="line">    	require(!approved[_txId][msg.sender], &quot;Tx already approved!&quot;);</span><br><span class="line">    	_;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier notExecuted(uint _txId)&#123;</span><br><span class="line">    	require(!transactions[_txId].executed, &quot;Tx already executed!&quot;);</span><br><span class="line">    	_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //提交交易</span><br><span class="line">    function submit(address _to, uint _value, bytes calldata _data) external onlyOwner&#123;</span><br><span class="line">        transactions.push(Transaction(&#123;</span><br><span class="line">        to: to,</span><br><span class="line">        value: value,</span><br><span class="line">        data: data,</span><br><span class="line">        executed: false</span><br><span class="line">        &#125;));</span><br><span class="line">        emit Submit(transactions.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //批准交易</span><br><span class="line">    function approve(uint txId) external</span><br><span class="line">    	onlyOwner </span><br><span class="line">    	txExists( txId)</span><br><span class="line">        notApproved( txId)</span><br><span class="line">        notExecuted( txId)</span><br><span class="line">    &#123;</span><br><span class="line">		approved[ txId][msg.sender] = true;</span><br><span class="line">		emit Approve(msg.sender, txId);</span><br><span class="line">	&#125;	</span><br><span class="line">	//获取某个交易的批准数量</span><br><span class="line">    function _getApprovalCount(uint _txId) private view returns (uint count)&#123;</span><br><span class="line">        for(uint i; i &lt; owners.length; i++) &#123;</span><br><span class="line">            if (approved[_txId][owners[i]]) &#123;</span><br><span class="line">            	count += 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //执行交易</span><br><span class="line">    function execute(uint txId) external txExists( txId) notExecuted( txId)&#123;</span><br><span class="line">        require(_getApprovalCount(_txId) &gt;= required, &quot;approvals &lt; required&quot;);</span><br><span class="line">        Transaction storage transaction = transactions[_txId];</span><br><span class="line">        transaction.executed = true;</span><br><span class="line">        (bool success，) = </span><br><span class="line">        	transaction.to.call&#123;value: transaction.value&#125;(transaction.data);</span><br><span class="line">        require(success，&quot;tx failed&quot;);</span><br><span class="line">        emit Execute(_txId);</span><br><span class="line">    &#125;</span><br><span class="line">    //撤销批准</span><br><span class="line">    function revoke(uint _txId) external onlyOwner txExists( txId) notExecuted(_txId)&#123;</span><br><span class="line">        require(approved[_txId][msg.sender],&quot;tx not approved&quot;);</span><br><span class="line">        approved[_txId][msg.sender] = false;</span><br><span class="line">        emit Revoke(msg.sender，_txId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="荷兰拍卖"><a href="#荷兰拍卖" class="headerlink" title="荷兰拍卖"></a>荷兰拍卖</h3><ol>
<li>1个NFT部署一个合约</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//随着时间价格越来越低</span><br><span class="line">//使用NFT标准ERC721</span><br><span class="line">contract DutchAuction is ERC721&#123;</span><br><span class="line">	uint private constant DURATION = 7 days;		//拍卖周期</span><br><span class="line">    IERC721 public immutable nft;					//NFT对象</span><br><span class="line">    uint public immutable nftId;					//NFT的ID</span><br><span class="line">    address payable public immutable seller;		//NFT售卖者</span><br><span class="line">    uint public immutable startingPrice;			//起拍价</span><br><span class="line">    uint public immutable startAt;					//竞拍时间</span><br><span class="line">    uint public immutable expiresAt;				//结束时间</span><br><span class="line">    uint public immutable discountRate;				//折损率</span><br><span class="line">    </span><br><span class="line">    //通过构造函数给变量赋值</span><br><span class="line">    constructor(uint _startingPrice, uint _discountRate, address _nft, uint _nftId )&#123;</span><br><span class="line">        seller = payable(msg.sender);</span><br><span class="line">        startingPrice = _startingPrice;</span><br><span class="line">        discountRate = _discountRate;</span><br><span class="line">        startAt = block.timestamp;</span><br><span class="line">        expiresAt = block.timestamp + DURATION;</span><br><span class="line">        require(</span><br><span class="line">            _startingPrice &gt;= _discountRate * DURATION,</span><br><span class="line">            &quot;starting price &lt; discount&quot;</span><br><span class="line">        );</span><br><span class="line">        nft = IERC721(_nft);</span><br><span class="line">        nftId = _nftId;</span><br><span class="line">    &#125;</span><br><span class="line">    //获得NFT价格</span><br><span class="line">    function getPrice() public view returns (uint) &#123;</span><br><span class="line">    	uint timeElapsed = block.timestamp - startAt;</span><br><span class="line">    	uint discount = discountRate * timeElapsed;</span><br><span class="line">    	return startingPrice - discount;</span><br><span class="line">    &#125;</span><br><span class="line">    //购买NFT</span><br><span class="line">    function buy() external payable &#123;</span><br><span class="line">		require(block.timestamp &lt; expiresAt，&quot;auction expired&quot;);</span><br><span class="line">        uint price = getPrice();</span><br><span class="line">        require(msg.value &gt;= price，&quot;ETH &lt; price&quot;);</span><br><span class="line">        ntf.transferFrom(seller, msg.sender, nftId);</span><br><span class="line">        //因为价格一直在变动，所以可能需要退差价</span><br><span class="line">        uint refund = msg.value - price;</span><br><span class="line">        if (refund &gt; 0) &#123;</span><br><span class="line">        	payable(msg.sender).transfer(refund);</span><br><span class="line">        &#125;</span><br><span class="line">        selfdestruct(seller);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多个NFT部署一个合约</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line">import &quot;https://github.com/AmazingAng/WTFSolidity/blob/main/34_ERC721/ERC721.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DutchAuction is Ownable, ERC721 &#123;</span><br><span class="line">    uint256 public constant COLLECTOIN_SIZE = 10000; // NFT总数</span><br><span class="line">    uint256 public constant AUCTION_START_PRICE = 1 ether; // 起拍价(最高价)</span><br><span class="line">    uint256 public constant AUCTION_END_PRICE = 0.1 ether; // 结束价(最低价/地板价)</span><br><span class="line">    uint256 public constant AUCTION_TIME = 10 minutes; // 拍卖时间，为了测试方便设为10分钟</span><br><span class="line">    uint256 public constant AUCTION_DROP_INTERVAL = 1 minutes; // 每过多久时间，价格衰减一次</span><br><span class="line">    uint256 public constant AUCTION_DROP_PER_STEP =</span><br><span class="line">        (AUCTION_START_PRICE - AUCTION_END_PRICE) /</span><br><span class="line">        (AUCTION_TIME / AUCTION_DROP_INTERVAL); // 每次价格衰减步长</span><br><span class="line">    </span><br><span class="line">    uint256 public auctionStartTime; // 拍卖开始时间戳</span><br><span class="line">    string private _baseTokenURI;   // metadata URI</span><br><span class="line">    uint256[] private _allTokens; // 记录所有存在的tokenId </span><br><span class="line">    </span><br><span class="line">    constructor() ERC721(&quot;name&quot;,&quot;symbol&quot;) &#123;</span><br><span class="line">        auctionStartTime = block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置拍卖时间开始时间</span><br><span class="line">    function setAuctionStartTime(uint32 timestamp) external onlyOwner &#123;</span><br><span class="line">        auctionStartTime = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取拍卖实时价格</span><br><span class="line">    function getAuctionPrice() public view returns (uint256) &#123;</span><br><span class="line">        if (block.timestamp &lt; auctionStartTime) &#123;</span><br><span class="line">        	return AUCTION_START_PRICE;</span><br><span class="line">        &#125;else if (block.timestamp - auctionStartTime &gt;= AUCTION_TIME) &#123;</span><br><span class="line">        	return AUCTION_END_PRICE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint256 steps = </span><br><span class="line">            	(block.timestamp - auctionStartTime) / AUCTION_DROP_INTERVAL;</span><br><span class="line">            return AUCTION_START_PRICE - (steps * AUCTION_DROP_PER_STEP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拍卖mint函数，quantity数量</span><br><span class="line">    // TODO 需要调整</span><br><span class="line">    function auctionMint(uint256 quantity) external payable&#123;</span><br><span class="line">    	// 建立local变量，减少gas花费</span><br><span class="line">        uint256 _saleStartTime = uint256(auctionStartTime); </span><br><span class="line">        // 检查是否设置起拍时间，拍卖是否开始</span><br><span class="line">        require(</span><br><span class="line">            _saleStartTime != 0 &amp;&amp; block.timestamp &gt;= _saleStartTime,</span><br><span class="line">            &quot;sale has not started yet&quot;</span><br><span class="line">        ); </span><br><span class="line">        // 检查是否超过NFT上限</span><br><span class="line">        require(</span><br><span class="line">        	totalSupply() + quantity &lt;= COLLECTOIN_SIZE,</span><br><span class="line">        	&quot;not enough remaining reserved for auction to support desired mint amount&quot;</span><br><span class="line">        ); </span><br><span class="line">		// 计算mint成本</span><br><span class="line">        uint256 totalCost = getAuctionPrice() * quantity; </span><br><span class="line">        // 检查用户是否支付足够ETH</span><br><span class="line">        require(msg.value &gt;= totalCost, &quot;Need to send more ETH.&quot;); </span><br><span class="line">        </span><br><span class="line">        // Mint NFT</span><br><span class="line">        for(uint256 i = 0; i &lt; quantity; i++) &#123;</span><br><span class="line">            uint256 mintIndex = totalSupply();</span><br><span class="line">            _mint(msg.sender, mintIndex);</span><br><span class="line">            _addTokenToAllTokensEnumeration(mintIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        // 多余ETH退款</span><br><span class="line">        // TODO 加锁</span><br><span class="line">        if (msg.value &gt; totalCost) &#123;</span><br><span class="line">            payable(msg.sender).transfer(msg.value - totalCost); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="英式拍卖"><a href="#英式拍卖" class="headerlink" title="英式拍卖"></a>英式拍卖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">contract EnglishAuction &#123;</span><br><span class="line">	event Start();</span><br><span class="line">	event Bid(address indexed sender, uint amount);</span><br><span class="line">	event Withdraw(address indexed bidder, uint amount);</span><br><span class="line"></span><br><span class="line">	IERC721 public immutable nft;</span><br><span class="line">	uint public immutable nftId;</span><br><span class="line">    address payable public immutable seller;</span><br><span class="line">    uint32 public endAt;</span><br><span class="line">    bool public started;</span><br><span class="line">    bool public ended;</span><br><span class="line">    </span><br><span class="line">    address public highestBidder;</span><br><span class="line">    uint public highestBid;</span><br><span class="line">    mapping(address =&gt; uint) public bids;</span><br><span class="line">    </span><br><span class="line">    constructor(address _nft,uint _nftId,uint _startingBid)&#123;</span><br><span class="line">        nft = IERC721(_nft);</span><br><span class="line">        nftId = _nftId;</span><br><span class="line">        seller = payable(msg.sender);</span><br><span class="line">        highestBid = _startingBid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //开始拍卖</span><br><span class="line">    function start() external &#123;</span><br><span class="line">        require(msg.sender == seller,&quot;not seller&quot;);</span><br><span class="line">        require(!started,&quot;started&quot; ) ;</span><br><span class="line">        started = true;</span><br><span class="line">        endAt = uint32(block.timestamp + 60);</span><br><span class="line">        nft,transferFrom(seller， address(this)， nftId);</span><br><span class="line">        emit Start();</span><br><span class="line">    &#125;</span><br><span class="line">    //竞拍</span><br><span class="line">    function bid() external payable &#123;</span><br><span class="line">        require(started,&quot;not started&quot;);</span><br><span class="line">        require(block.timestamp &lt; endAt，&quot;ended&quot;);</span><br><span class="line">        require(msg.value &gt; highestBid, &quot;value &lt; highest bid&quot;);</span><br><span class="line">        if (highestBidder != address(0)) &#123;</span><br><span class="line">        	bids[highestBidder] += highestBid;</span><br><span class="line">        &#125;</span><br><span class="line">        highestBid = msg.value;</span><br><span class="line">        highestBidder = msg.sender;</span><br><span class="line">        emit Bid(msg.sender， msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">    //取回上一次竞拍的出价</span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        uint bal = bids[msg.sender];</span><br><span class="line">        bids[msg.sender] = 0;</span><br><span class="line">        payable(msg.sender).transfer(bal);</span><br><span class="line">        emit Withdraw(msg.sender，bal);</span><br><span class="line">    &#125;</span><br><span class="line">    //结束竞拍</span><br><span class="line">    function end() external &#123;</span><br><span class="line">        require(started, &quot;not started&quot;);</span><br><span class="line">        require(block.timestamp &gt;= endAt, &quot;not ended&quot;);</span><br><span class="line">        require(!ended, &quot;ended&quot;);</span><br><span class="line"></span><br><span class="line">        ended = true;</span><br><span class="line">        if (highestBidder != address(0)) &#123;</span><br><span class="line">            nft.safeTransferFrom(address(this), highestBidder, nftId);</span><br><span class="line">            seller.transfer(highestBid);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nft.safeTransferFrom(address(this), seller, nftId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emit End(highestBidder, highestBid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="众筹合约"><a href="#众筹合约" class="headerlink" title="众筹合约"></a>众筹合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">contract CrowdFund &#123;</span><br><span class="line">    event Launch(</span><br><span class="line">        uint id,</span><br><span class="line">        address indexed creator,</span><br><span class="line">        uint goal,</span><br><span class="line">        uint32 startAt,</span><br><span class="line">        uint32 endAt</span><br><span class="line">    );</span><br><span class="line">    event Cancel(uint id);</span><br><span class="line">    event Pledge(uint indexed id, address indexed caller, uint amount);</span><br><span class="line">    event Unpledge(uint indexed id, address indexed caller, uint amount);</span><br><span class="line">    event Claim(uint id);</span><br><span class="line">    event Refund(uint id, address indexed caller, uint amount);</span><br><span class="line"></span><br><span class="line">	//众筹结构体</span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address creator;	//发起人</span><br><span class="line">        uint goal;			//目标</span><br><span class="line">        uint pledged;		//已经获得的众筹数量</span><br><span class="line">        uint32 startAt;		//开始时间</span><br><span class="line">        uint32 endAt;		//结束时间</span><br><span class="line">        bool claimed;		//是否领取</span><br><span class="line">    &#125;</span><br><span class="line">	//众筹使用的代币</span><br><span class="line">    IERC20 public immutable token;</span><br><span class="line">    //众筹数</span><br><span class="line">    uint public count;</span><br><span class="line">    //记录众筹</span><br><span class="line">    mapping(uint =&gt; Campaign) public campaigns;</span><br><span class="line">    //记录某一次众筹参与用户和数额</span><br><span class="line">    mapping(uint =&gt; mapping(address =&gt; uint)) public pledgedAmount;</span><br><span class="line"></span><br><span class="line">    constructor(address _token) &#123;</span><br><span class="line">        token = IERC20(_token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//创建一个众筹</span><br><span class="line">    function launch(uint _goal, uint32 _startAt, uint32 _endAt) external &#123;</span><br><span class="line">        require(_startAt &gt;= block.timestamp, &quot;start at &lt; now&quot;);</span><br><span class="line">        require(_endAt &gt;= _startAt, &quot;end at &lt; start at&quot;);</span><br><span class="line">        require(_endAt &lt;= block.timestamp + 90 days, &quot;end at &gt; max duration&quot;);</span><br><span class="line"></span><br><span class="line">        count += 1;</span><br><span class="line">        campaigns[count] = Campaign(&#123;</span><br><span class="line">            creator: msg.sender,</span><br><span class="line">            goal: _goal,</span><br><span class="line">            pledged: 0,</span><br><span class="line">            startAt: _startAt,</span><br><span class="line">            endAt: _endAt,</span><br><span class="line">            claimed: false</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        emit Launch(count, msg.sender, _goal, _startAt, _endAt);</span><br><span class="line">    &#125;</span><br><span class="line">	//取消一个众筹</span><br><span class="line">    function cancel(uint _id) external &#123;</span><br><span class="line">        Campaign memory campaign = campaigns[_id];</span><br><span class="line">        require(campaign.creator == msg.sender, &quot;not creator&quot;);</span><br><span class="line">        require(block.timestamp &lt; campaign.startAt, &quot;started&quot;);</span><br><span class="line"></span><br><span class="line">        delete campaigns[_id];</span><br><span class="line">        emit Cancel(_id);</span><br><span class="line">    &#125;</span><br><span class="line">	//参与众筹</span><br><span class="line">    function pledge(uint _id, uint _amount) external &#123;</span><br><span class="line">        Campaign storage campaign = campaigns[_id];</span><br><span class="line">        require(block.timestamp &gt;= campaign.startAt, &quot;not started&quot;);</span><br><span class="line">        require(block.timestamp &lt;= campaign.endAt, &quot;ended&quot;);</span><br><span class="line"></span><br><span class="line">        campaign.pledged += _amount;</span><br><span class="line">        pledgedAmount[_id][msg.sender] += _amount;</span><br><span class="line">        token.transferFrom(msg.sender, address(this), _amount);</span><br><span class="line"></span><br><span class="line">        emit Pledge(_id, msg.sender, _amount);</span><br><span class="line">    &#125;</span><br><span class="line">	//退出众筹</span><br><span class="line">    function unpledge(uint _id, uint _amount) external &#123;</span><br><span class="line">        Campaign storage campaign = campaigns[_id];</span><br><span class="line">        require(block.timestamp &lt;= campaign.endAt, &quot;ended&quot;);</span><br><span class="line"></span><br><span class="line">        campaign.pledged -= _amount;</span><br><span class="line">        pledgedAmount[_id][msg.sender] -= _amount;</span><br><span class="line">        token.transfer(msg.sender, _amount);</span><br><span class="line"></span><br><span class="line">        emit Unpledge(_id, msg.sender, _amount);</span><br><span class="line">    &#125;</span><br><span class="line">	//众筹成功取出筹款</span><br><span class="line">    function claim(uint _id) external &#123;</span><br><span class="line">        Campaign storage campaign = campaigns[_id];</span><br><span class="line">        require(campaign.creator == msg.sender, &quot;not creator&quot;);</span><br><span class="line">        require(block.timestamp &gt; campaign.endAt, &quot;not ended&quot;);</span><br><span class="line">        require(campaign.pledged &gt;= campaign.goal, &quot;pledged &lt; goal&quot;);</span><br><span class="line">        require(!campaign.claimed, &quot;claimed&quot;);</span><br><span class="line"></span><br><span class="line">        campaign.claimed = true;</span><br><span class="line">        token.transfer(campaign.creator, campaign.pledged);</span><br><span class="line"></span><br><span class="line">        emit Claim(_id);</span><br><span class="line">    &#125;</span><br><span class="line">	//众筹失败退回筹款</span><br><span class="line">    function refund(uint _id) external &#123;</span><br><span class="line">        Campaign memory campaign = campaigns[_id];</span><br><span class="line">        require(block.timestamp &gt; campaign.endAt, &quot;not ended&quot;);</span><br><span class="line">        require(campaign.pledged &lt; campaign.goal, &quot;pledged &gt;= goal&quot;);</span><br><span class="line"></span><br><span class="line">        uint bal = pledgedAmount[_id][msg.sender];</span><br><span class="line">        pledgedAmount[_id][msg.sender] = 0;</span><br><span class="line">        token.transfer(msg.sender, bal);</span><br><span class="line"></span><br><span class="line">        emit Refund(_id, msg.sender, bal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代币水龙头"><a href="#代币水龙头" class="headerlink" title="代币水龙头"></a>代币水龙头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">contract Faucet &#123;</span><br><span class="line">	uint256 public amountAllowed = 100; // 每次领 100 单位代币</span><br><span class="line">	address public tokenContract;   // token合约地址</span><br><span class="line">	mapping(address =&gt; bool) public requestedAddress;   // 记录领取过代币的地址</span><br><span class="line">	</span><br><span class="line">	// SendToken事件    </span><br><span class="line">	event SendToken(address indexed Receiver, uint256 indexed Amount); </span><br><span class="line">	</span><br><span class="line">	// 部署时设定ERC2代币合约</span><br><span class="line">    constructor(address _tokenContract) &#123;</span><br><span class="line">        tokenContract = _tokenContract; // set token contract</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 用户领取代币函数</span><br><span class="line">    function requestTokens() external &#123;</span><br><span class="line">     	// 每个地址只能领一次</span><br><span class="line">        require(requestedAddress[msg.sender] == false, </span><br><span class="line">        	&quot;Can&#x27;t Request Multiple Times!&quot;);</span><br><span class="line">        IERC20 token = IERC20(tokenContract); // 创建IERC20合约对象</span><br><span class="line">        require(token.balanceOf(address(this)) &gt;= amountAllowed, &quot;Faucet Empty!&quot;); // 水龙头空了</span><br><span class="line"></span><br><span class="line">        token.transfer(msg.sender, amountAllowed); // 发送token</span><br><span class="line">        requestedAddress[msg.sender] = true; // 记录领取地址 </span><br><span class="line"></span><br><span class="line">        emit SendToken(msg.sender, amountAllowed); // 释放SendToken事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空投"><a href="#空投" class="headerlink" title="空投"></a>空投</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">contract Airdrop &#123;</span><br><span class="line">	// 数组求和函数</span><br><span class="line">    function getSum(uint256[] calldata _arr) public pure returns(uint sum)</span><br><span class="line">    &#123;</span><br><span class="line">        for(uint i = 0; i &lt; _arr.length; i++)</span><br><span class="line">            sum = sum + _arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// @notice 向多个地址转账ERC20代币，使用前需要先授权</span><br><span class="line">    function multiTransferToken(</span><br><span class="line">        address _token,					//转账的ERC20代币地址</span><br><span class="line">        address[] calldata _addresses,	//空投地址数组</span><br><span class="line">        uint256[] calldata _amounts		//代币数量数组（每个地址的空投数量）</span><br><span class="line">        ) external &#123;</span><br><span class="line">        require(_addresses.length == _amounts.length, </span><br><span class="line">        	&quot;Lengths of Addresses and Amounts NOT EQUAL&quot;);</span><br><span class="line">        	</span><br><span class="line">        IERC20 token = IERC20(_token); // 声明IERC合约变量</span><br><span class="line">        uint _amountSum = getSum(_amounts); // 计算空投代币总量</span><br><span class="line">        // 检查：授权代币数量 &gt;= 空投代币总量</span><br><span class="line">        require(token.allowance(msg.sender, address(this)) &gt;= _amountSum, &quot;Need Approve ERC20 token&quot;);</span><br><span class="line"></span><br><span class="line">        // for循环，利用transferFrom函数发送空投</span><br><span class="line">        for (uint8 i; i &lt; _addresses.length; i++) &#123;</span><br><span class="line">            token.transferFrom(msg.sender, _addresses[i], _amounts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 向多个地址转账ETH</span><br><span class="line">    function multiTransferETH(</span><br><span class="line">        address payable[] calldata _addresses,</span><br><span class="line">        uint256[] calldata _amounts</span><br><span class="line">    ) public payable &#123;</span><br><span class="line">        require(_addresses.length == _amounts.length, </span><br><span class="line">        	&quot;Lengths of Addresses and Amounts NOT EQUAL&quot;);</span><br><span class="line">        	</span><br><span class="line">        uint _amountSum = getSum(_amounts); // 计算空投ETH总量</span><br><span class="line">        // 检查转入ETH等于空投总量</span><br><span class="line">        require(msg.value == _amountSum, &quot;Transfer amount error&quot;);</span><br><span class="line">        // for循环，利用transfer函数发送ETH</span><br><span class="line">        for (uint256 i = 0; i &lt; _addresses.length; i++) &#123;</span><br><span class="line">            _addresses[i].transfer(_amounts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><ol>
<li>通过MerkleTree发放</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">contract MerkleTree is ERC721 &#123;</span><br><span class="line">    bytes32 immutable public root; // Merkle树的根</span><br><span class="line">    mapping(address =&gt; bool) public mintedAddress;   // 记录已经mint的地址</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化NFT合集的名称、代号、Merkle树的根</span><br><span class="line">    constructor(string memory name, string memory symbol, bytes32 merkleroot)</span><br><span class="line">    ERC721(name, symbol)</span><br><span class="line">    &#123;</span><br><span class="line">        root = merkleroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 利用Merkle树验证地址并完成mint</span><br><span class="line">    function mint(address account, uint256 tokenId, bytes32[] calldata proof)</span><br><span class="line">    external</span><br><span class="line">    &#123;</span><br><span class="line">        require(_verify(_leaf(account), proof), &quot;Invalid merkle proof&quot;); // Merkle检验通过</span><br><span class="line">        require(!mintedAddress[account], &quot;Already minted!&quot;); // 地址没有mint过</span><br><span class="line">        _mint(account, tokenId); // mint</span><br><span class="line">        mintedAddress[account] = true; // 记录mint过的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算Merkle树叶子的哈希值</span><br><span class="line">    function _leaf(address account)</span><br><span class="line">    internal pure returns (bytes32)</span><br><span class="line">    &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(account));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Merkle树验证，调用MerkleProof库的verify()函数</span><br><span class="line">    function _verify(bytes32 leaf, bytes32[] memory proof)</span><br><span class="line">    internal view returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return MerkleProof.verify(proof, root, leaf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过签名发放</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">contract SignatureNFT is ERC721 &#123;</span><br><span class="line">    address immutable public signer; // 签名地址</span><br><span class="line">    mapping(address =&gt; bool) public mintedAddress;   // 记录已经mint的地址</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化NFT合集的名称、代号、签名地址</span><br><span class="line">    constructor(string memory _name, string memory _symbol, address _signer)</span><br><span class="line">    ERC721(_name, _symbol)</span><br><span class="line">    &#123;</span><br><span class="line">        signer = _signer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 利用ECDSA验证签名并mint</span><br><span class="line">    function mint(address _account, uint256 _tokenId, bytes memory _signature)</span><br><span class="line">    external</span><br><span class="line">    &#123;</span><br><span class="line">    	// 将_account和_tokenId打包消息</span><br><span class="line">        bytes32 _msgHash = getMessageHash(_account, _tokenId); </span><br><span class="line">        // 计算以太坊签名消息</span><br><span class="line">        bytes32 _ethSignedMessageHash = ECDSA.toEthSignedMessageHash(_msgHash); </span><br><span class="line">        // ECDSA检验通过</span><br><span class="line">        require(verify(_ethSignedMessageHash, _signature), &quot;Invalid signature&quot;); </span><br><span class="line">         // 地址没有mint过</span><br><span class="line">        require(!mintedAddress[_account], &quot;Already minted!&quot;);</span><br><span class="line">        // mint</span><br><span class="line">        _mint(_account, _tokenId); </span><br><span class="line">        // 记录mint过的地址</span><br><span class="line">        mintedAddress[_account] = true; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getMessageHash(address _account, uint256 _tokenId) public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(abi.encodePacked(_account, _tokenId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ECDSA验证，调用ECDSA库的verify()函数</span><br><span class="line">    function verify(bytes32 _msgHash, bytes memory _signature)</span><br><span class="line">    public view returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return ECDSA.verify(_msgHash, _signature, signer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交易所"><a href="#交易所" class="headerlink" title="交易所"></a>交易所</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">contract NFTSwap is IERC721Receiver&#123;</span><br><span class="line">    event List(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 price);</span><br><span class="line">    event Purchase(address indexed buyer, address indexed nftAddr, uint256 indexed tokenId, uint256 price);</span><br><span class="line">    event Revoke(address indexed seller, address indexed nftAddr, uint256 indexed tokenId);    </span><br><span class="line">    event Update(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 newPrice);</span><br><span class="line">    </span><br><span class="line">    fallback() external payable&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 定义order结构体</span><br><span class="line">    struct Order&#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint256 price; </span><br><span class="line">    &#125;</span><br><span class="line">    // NFT地址 - NFT id -  Order映射</span><br><span class="line">    mapping(address =&gt; mapping(uint256 =&gt; Order)) public nftList;</span><br><span class="line">    </span><br><span class="line">    // 实现&#123;IERC721Receiver&#125;的onERC721Received，能够接收ERC721代币</span><br><span class="line">    function onERC721Received(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external override returns (bytes4)&#123;</span><br><span class="line">        return IERC721Receiver.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 挂单: 卖家上架NFT，合约地址为_nftAddr，tokenId为_tokenId，价格_price为以太坊（单位是wei）</span><br><span class="line">    function list(address _nftAddr, uint256 _tokenId, uint256 _price) public&#123;</span><br><span class="line">        IERC721 _nft = IERC721(_nftAddr); // 声明IERC721接口合约变量</span><br><span class="line">        require(_nft.getApproved(_tokenId) == address(this), &quot;Need Approval&quot;); // 合约得到授权</span><br><span class="line">        require(_price &gt; 0); // 价格大于0</span><br><span class="line"></span><br><span class="line">        Order storage _order = nftList[_nftAddr][_tokenId]; //设置NF持有人和价格</span><br><span class="line">        _order.owner = msg.sender;</span><br><span class="line">        _order.price = _price;</span><br><span class="line">        // 将NFT转账到合约</span><br><span class="line">        _nft.safeTransferFrom(msg.sender, address(this), _tokenId);</span><br><span class="line"></span><br><span class="line">        // 释放List事件</span><br><span class="line">        emit List(msg.sender, _nftAddr, _tokenId, _price);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 撤单： 卖家取消挂单</span><br><span class="line">    function revoke(address _nftAddr, uint256 _tokenId) public &#123;</span><br><span class="line">        Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order        </span><br><span class="line">        require(_order.owner == msg.sender, &quot;Not Owner&quot;); // 必须由持有人发起</span><br><span class="line">        // 声明IERC721接口合约变量</span><br><span class="line">        IERC721 _nft = IERC721(_nftAddr);</span><br><span class="line">        require(_nft.ownerOf(_tokenId) == address(this), &quot;Invalid Order&quot;); // NFT在合约中</span><br><span class="line">        </span><br><span class="line">        // 将NFT转给卖家</span><br><span class="line">        _nft.safeTransferFrom(address(this), msg.sender, _tokenId);</span><br><span class="line">        delete nftList[_nftAddr][_tokenId]; // 删除order</span><br><span class="line">      </span><br><span class="line">        // 释放Revoke事件</span><br><span class="line">        emit Revoke(msg.sender, _nftAddr, _tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 调整价格: 卖家调整挂单价格</span><br><span class="line">    function update(address _nftAddr, uint256 _tokenId, uint256 _newPrice) public &#123;</span><br><span class="line">        require(_newPrice &gt; 0, &quot;Invalid Price&quot;); // NFT价格大于0</span><br><span class="line">        Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order        </span><br><span class="line">        require(_order.owner == msg.sender, &quot;Not Owner&quot;); // 必须由持有人发起</span><br><span class="line">        // 声明IERC721接口合约变量</span><br><span class="line">        IERC721 _nft = IERC721(_nftAddr);</span><br><span class="line">        require(_nft.ownerOf(_tokenId) == address(this), &quot;Invalid Order&quot;); // NFT在合约中</span><br><span class="line">        </span><br><span class="line">        // 调整NFT价格</span><br><span class="line">        _order.price = _newPrice;</span><br><span class="line">      </span><br><span class="line">        // 释放Update事件</span><br><span class="line">        emit Update(msg.sender, _nftAddr, _tokenId, _newPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 购买: 买家购买NFT，合约为_nftAddr，tokenId为_tokenId，调用函数时要附带ETH</span><br><span class="line">    function purchase(address _nftAddr, uint256 _tokenId) payable public &#123;</span><br><span class="line">        Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order        </span><br><span class="line">        require(_order.price &gt; 0, &quot;Invalid Price&quot;); // NFT价格大于0</span><br><span class="line">        require(msg.value &gt;= _order.price, &quot;Increase price&quot;); // 购买价格大于标价</span><br><span class="line">        // 声明IERC721接口合约变量</span><br><span class="line">        IERC721 _nft = IERC721(_nftAddr);</span><br><span class="line">        require(_nft.ownerOf(_tokenId) == address(this), &quot;Invalid Order&quot;); // NFT在合约中</span><br><span class="line"></span><br><span class="line">        // 将NFT转给买家</span><br><span class="line">        _nft.safeTransferFrom(address(this), msg.sender, _tokenId);</span><br><span class="line">        // 将ETH转给卖家，多余ETH给买家退款</span><br><span class="line">        payable(_order.owner).transfer(_order.price);</span><br><span class="line">        payable(msg.sender).transfer(msg.value-_order.price);</span><br><span class="line"></span><br><span class="line">        delete nftList[_nftAddr][_tokenId]; // 删除order</span><br><span class="line"></span><br><span class="line">        // 释放Purchase事件</span><br><span class="line">        emit Purchase(msg.sender, _nftAddr, _tokenId, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分账"><a href="#分账" class="headerlink" title="分账"></a>分账</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分账合约 </span><br><span class="line"> * @dev 这个合约会把收到的ETH按事先定好的份额分给几个账户。收到ETH会存在分账合约中，需要每个受益人调用release()函数来领取。</span><br><span class="line"> */</span><br><span class="line">contract PaymentSplit&#123;</span><br><span class="line"></span><br><span class="line">    // 事件</span><br><span class="line">    event PayeeAdded(address account, uint256 shares); // 增加受益人事件</span><br><span class="line">    event PaymentReleased(address to, uint256 amount); // 受益人提款事件</span><br><span class="line">    event PaymentReceived(address from, uint256 amount); // 合约收款事件</span><br><span class="line">    </span><br><span class="line">    uint256 public totalShares; // 总份额</span><br><span class="line">    uint256 public totalReleased; // 总支付</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public shares; // 每个受益人的份额</span><br><span class="line">    mapping(address =&gt; uint256) public released; // 支付给每个受益人的金额</span><br><span class="line">    address[] public payees; // 受益人数组</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @dev 初始化受益人数组_payees和分账份额数组_shares</span><br><span class="line">     * 数组长度不能为0，两个数组长度要相等。_shares中元素要大于0，_payees中地址不能为0地址且不能有重复地址</span><br><span class="line">     */</span><br><span class="line">    constructor(address[] memory _payees, uint256[] memory _shares) payable &#123;</span><br><span class="line">        // 检查_payees和_shares数组长度相同，且不为0</span><br><span class="line">        require(_payees.length == _shares.length, &quot;PaymentSplitter: payees and shares length mismatch&quot;);</span><br><span class="line">        require(_payees.length &gt; 0, &quot;PaymentSplitter: no payees&quot;);</span><br><span class="line">        // 调用_addPayee，更新受益人地址payees、受益人份额shares和总份额totalShares</span><br><span class="line">        for (uint256 i = 0; i &lt; _payees.length; i++) &#123;</span><br><span class="line">            _addPayee(_payees[i], _shares[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 回调函数，收到ETH释放PaymentReceived事件</span><br><span class="line">     */</span><br><span class="line">    receive() external payable virtual &#123;</span><br><span class="line">        emit PaymentReceived(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 为有效受益人地址_account分帐，相应的ETH直接发送到受益人地址。任何人都可以触发这个函数，但钱会打给account地址。</span><br><span class="line">     * 调用了releasable()函数。</span><br><span class="line">     */</span><br><span class="line">    function release(address payable _account) public virtual &#123;</span><br><span class="line">        // account必须是有效受益人</span><br><span class="line">        require(shares[_account] &gt; 0, &quot;PaymentSplitter: account has no shares&quot;);</span><br><span class="line">        // 计算account应得的eth</span><br><span class="line">        uint256 payment = releasable(_account);</span><br><span class="line">        // 应得的eth不能为0</span><br><span class="line">        require(payment != 0, &quot;PaymentSplitter: account is not due payment&quot;);</span><br><span class="line">        // 更新总支付totalReleased和支付给每个受益人的金额released</span><br><span class="line">        totalReleased += payment;</span><br><span class="line">        released[_account] += payment;</span><br><span class="line">        // 转账</span><br><span class="line">        _account.transfer(payment);</span><br><span class="line">        emit PaymentReleased(_account, payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 计算一个账户能够领取的eth。</span><br><span class="line">     * 调用了pendingPayment()函数。</span><br><span class="line">     */</span><br><span class="line">    function releasable(address _account) public view returns (uint256) &#123;</span><br><span class="line">        // 计算分账合约总收入totalReceived</span><br><span class="line">        uint256 totalReceived = address(this).balance + totalReleased;</span><br><span class="line">        // 调用_pendingPayment计算account应得的ETH</span><br><span class="line">        return pendingPayment(_account, totalReceived, released[_account]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 根据受益人地址`_account`, 分账合约总收入`_totalReceived`和该地址已领取的钱`_alreadyReleased`，计算该受益人现在应分的`ETH`。</span><br><span class="line">     */</span><br><span class="line">    function pendingPayment(</span><br><span class="line">        address _account,</span><br><span class="line">        uint256 _totalReceived,</span><br><span class="line">        uint256 _alreadyReleased</span><br><span class="line">    ) public view returns (uint256) &#123;</span><br><span class="line">        // account应得的ETH = 总应得ETH - 已领到的ETH</span><br><span class="line">        return (_totalReceived * shares[_account]) / totalShares - _alreadyReleased;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 新增受益人_account以及对应的份额_accountShares。只能在构造器中被调用，不能修改。</span><br><span class="line">     */</span><br><span class="line">    function _addPayee(address _account, uint256 _accountShares) private &#123;</span><br><span class="line">        // 检查_account不为0地址</span><br><span class="line">        require(_account != address(0), &quot;PaymentSplitter: account is the zero address&quot;);</span><br><span class="line">        // 检查_accountShares不为0</span><br><span class="line">        require(_accountShares &gt; 0, &quot;PaymentSplitter: shares are 0&quot;);</span><br><span class="line">        // 检查_account不重复</span><br><span class="line">        require(shares[_account] == 0, &quot;PaymentSplitter: account already has shares&quot;);</span><br><span class="line">        // 更新payees，shares和totalShares</span><br><span class="line">        payees.push(_account);</span><br><span class="line">        shares[_account] = _accountShares;</span><br><span class="line">        totalShares += _accountShares;</span><br><span class="line">        // 释放增加受益人事件</span><br><span class="line">        emit PayeeAdded(_account, _accountShares);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性释放代币"><a href="#线性释放代币" class="headerlink" title="线性释放代币"></a>线性释放代币</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">contract TokenVesting &#123;</span><br><span class="line">    // 事件</span><br><span class="line">    event ERC20Released(address indexed token, uint256 amount); // 提币事件</span><br><span class="line">    </span><br><span class="line">    // 状态变量</span><br><span class="line">    mapping(address =&gt; uint256) public erc20Released; // 代币地址-&gt;释放数量的映射，记录已经释放的代币</span><br><span class="line">    address public immutable beneficiary; // 受益人地址</span><br><span class="line">    uint256 public immutable start; // 起始时间戳</span><br><span class="line">    uint256 public immutable duration; // 归属期</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @dev 初始化受益人地址，释放周期(秒), 起始时间戳(当前区块链时间戳)</span><br><span class="line">     */</span><br><span class="line">    constructor(</span><br><span class="line">        address beneficiaryAddress,</span><br><span class="line">        uint256 durationSeconds</span><br><span class="line">    ) &#123;</span><br><span class="line">        require(beneficiaryAddress != address(0), &quot;VestingWallet: beneficiary is zero address&quot;);</span><br><span class="line">        beneficiary = beneficiaryAddress;</span><br><span class="line">        start = block.timestamp;</span><br><span class="line">        duration = durationSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 受益人提取已释放的代币。</span><br><span class="line">     * 调用vestedAmount()函数计算可提取的代币数量，然后transfer给受益人。</span><br><span class="line">     * 释放 &#123;ERC20Released&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function release(address token) public &#123;</span><br><span class="line">        // 调用vestedAmount()函数计算可提取的代币数量</span><br><span class="line">        uint256 releasable = vestedAmount(token, uint256(block.timestamp)) - erc20Released[token];</span><br><span class="line">        // 更新已释放代币数量   </span><br><span class="line">        erc20Released[token] += releasable; </span><br><span class="line">        // 转代币给受益人</span><br><span class="line">        emit ERC20Released(token, releasable);</span><br><span class="line">        IERC20(token).transfer(beneficiary, releasable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 根据线性释放公式，计算已经释放的数量。开发者可以通过修改这个函数，自定义释放方式。</span><br><span class="line">     * @param token: 代币地址</span><br><span class="line">     * @param timestamp: 查询的时间戳</span><br><span class="line">     */</span><br><span class="line">    function vestedAmount(address token, uint256 timestamp) public view returns (uint256) &#123;</span><br><span class="line">        // 合约里总共收到了多少代币（当前余额 + 已经提取）</span><br><span class="line">        uint256 totalAllocation = IERC20(token).balanceOf(address(this)) + erc20Released[token];</span><br><span class="line">        // 根据线性释放公式，计算已经释放的数量</span><br><span class="line">        if (timestamp &lt; start) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (timestamp &gt; start + duration) &#123;</span><br><span class="line">            return totalAllocation;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (totalAllocation * (timestamp - start)) / duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h2><ul>
<li>openzeelping</li>
<li>MerkleProof<ul>
<li>验证交易合法xing</li>
</ul>
</li>
</ul>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li>Gas优化<ul>
<li>使用calldata</li>
<li>如果频繁修改状态变量的话，可以将修改记录后再一次性修改</li>
<li>循环判断条件使用 &amp;&amp; 拼接</li>
<li>用++替换+&#x3D;1</li>
<li>提前将变量提取出来，避免重复计算</li>
<li>当函数代码太多时可以将一些代码用单独的大括号划分出来，避免堆栈太深导致gas超额</li>
</ul>
</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ol>
<li>将代码完成后编译成bytecode，存在data域</li>
<li>发起一个转账交易到0x0地址，from地址为当前合约<ul>
<li>转账金额为0</li>
<li>支付汽油费</li>
<li>合约的代码放在data域中</li>
</ul>
</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>估算gas费<ol>
<li>remix在部署后执行函数调用会估算gas费</li>
<li>使用hardhat-gas-reporter插件生成gas报告</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/Solidity/" data-id="clrj8k01a004n4wuw3ugbfwse" data-title="Solidity" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/solidity/" rel="tag">solidity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/学习路线" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.644Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>区块链知识<ul>
<li><input checked="" disabled="" type="checkbox"> 【北京大学肖臻老师《区块链技术与应用》公开课】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vt411X7JF/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1Vt411X7JF/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input checked="" disabled="" type="checkbox"> 【Web3新人公开课】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nt4y1N7xJ/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1nt4y1N7xJ/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【Chainlink 预言机】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ed4y1N7Uv/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1ed4y1N7Uv/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【Defi】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1va41127DM/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1va41127DM/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【零知识证明】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wo4y1b7Ps/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1wo4y1b7Ps/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
</ul>
</li>
<li>源码<ul>
<li><input disabled="" type="checkbox"> 比特币源码<ul>
<li><input disabled="" type="checkbox"> 【白皮书】<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/649874047">https://zhuanlan.zhihu.com/p/649874047</a></li>
<li><input disabled="" type="checkbox"> 【向经典致敬-15周年比特币白皮书中文版全文】<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/664308886?utm_id=0">https://zhuanlan.zhihu.com/p/664308886?utm_id=0</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 以太坊源码<ul>
<li><input disabled="" type="checkbox"> 【文档】<a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/intro-to-ethereum">https://ethereum.org/zh/developers/docs/intro-to-ethereum</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> uniswap源码<ul>
<li><input checked="" disabled="" type="checkbox"> 【源码解读】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hY4y1D7aD/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1hY4y1D7aD/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【白皮书】<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3055">https://learnblockchain.cn/article/3055</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> usdt源码</li>
<li><input disabled="" type="checkbox"> Compound源码</li>
</ul>
</li>
<li>Solidity<ul>
<li><input checked="" disabled="" type="checkbox"> 【油管-崔棉大师-solidity】<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=XlJwBTIps_I&list=PLV16oVzL15MS-Zw8a3eEOADwbHhm8GrMp&index=1">https://www.youtube.com/watch?v=XlJwBTIps_I&amp;list=PLV16oVzL15MS-Zw8a3eEOADwbHhm8GrMp&amp;index=1</a></li>
<li><input checked="" disabled="" type="checkbox"> 【智能合约内联汇编】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jK4y1X75h/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1jK4y1X75h/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input checked="" disabled="" type="checkbox"> 【WTF 文档】<a target="_blank" rel="noopener" href="https://www.wtf.academy/">https://www.wtf.academy/</a></li>
<li><input disabled="" type="checkbox"> 【【2023最新版】学习 Solidity、区块链和智能合约开发：Chainlink融合AI的高效开发方法（中英字幕完整版）】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gz4y1i79f/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1gz4y1i79f/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
</ul>
</li>
<li>前端<ul>
<li><input checked="" disabled="" type="checkbox"> 【react】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Tt4y1772f/?p=157&share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1Tt4y1772f/?p=157&amp;share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input checked="" disabled="" type="checkbox"> 【web3.js】</li>
<li><input checked="" disabled="" type="checkbox"> 【ether.js】</li>
</ul>
</li>
<li>项目<ul>
<li><input checked="" disabled="" type="checkbox"> 【油管NFT项目】<a target="_blank" rel="noopener" href="https://youtu.be/S3jJtGYI18E?si=udwmWUGlwELwlUWN">https://youtu.be/S3jJtGYI18E?si=udwmWUGlwELwlUWN</a></li>
<li><input disabled="" type="checkbox"> 【崔棉大师uniswap】<a target="_blank" rel="noopener" href="https://youtu.be/38mVbslZpS4?si=anTRDzHpb8L1v-kA">https://youtu.be/38mVbslZpS4?si=anTRDzHpb8L1v-kA</a></li>
<li><input disabled="" type="checkbox"> 【百度网盘项目】<a target="_blank" rel="noopener" href="https://pan.baidu.com/disk/main?from=1026962h#/index?category=all&path=%2FGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2F%E5%8C%BA%E5%9D%97%E9%93%BE&fromNav=%2FGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2F%E5%8C%BA%E5%9D%97%E9%93%BE">https://pan.baidu.com/disk/main?from=1026962h#/index?category=all&amp;path=%2FGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2F%E5%8C%BA%E5%9D%97%E9%93%BE&amp;fromNav=%2FGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2F%E5%8C%BA%E5%9D%97%E9%93%BE</a></li>
</ul>
</li>
<li>资料</li>
<li>补充知识<ul>
<li><input disabled="" type="checkbox"> 【区块链安全实战修炼营】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14u4y1H7ik/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV14u4y1H7ik/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【Rust】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hp4y1k7SV/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1hp4y1k7SV/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【【公开课】Solana区块链开发人员训练营：教你使用Rust + JavaScript 开发区块链】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1da411G7Dj/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1da411G7Dj/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【Golang】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gf4y1r79E/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV1gf4y1r79E/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
<li><input disabled="" type="checkbox"> 【Go相关书籍】<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613227155">https://zhuanlan.zhihu.com/p/613227155</a></li>
<li><input disabled="" type="checkbox"> 【崔棉大师直播课】<a target="_blank" rel="noopener" href="https://youtu.be/JLB5iZj9XGM?si=c4hdCskFMq1fDbMF">https://youtu.be/JLB5iZj9XGM?si=c4hdCskFMq1fDbMF</a></li>
<li><input disabled="" type="checkbox"> 【【麻省理工】区块链与金钱】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19q4y1B7RZ/?share_source=copy_web&vd_source=8385103b7fab7d5a444c0ff2de51f0ae">https://www.bilibili.com/video/BV19q4y1B7RZ/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae</a></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" data-id="clrj8k00s000w4wuw1ogy9brp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/零知识证明" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.644Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>不告知识细节但是能证明知识的正确性合理性，而且验证者不会得知知识细节</li>
<li>验证者向证明者提问，证明者不能提供有意义的信息</li>
<li>只需要关注验证的时间，不关心相关知识的证明时间</li>
<li>通过协议来证明证明者的理论</li>
<li>通过同态加密实现</li>
</ul>
<h2 id="盲签"><a href="#盲签" class="headerlink" title="盲签"></a>盲签</h2><ul>
<li>A提供货币序列号，银行在不知道该序列号的情况下返回token，减少A的存款</li>
<li>A用序列号和token与B进行交易</li>
<li>B拿序列号和token给银行验证，银行验证通过，增加B的存款</li>
</ul>
<h2 id="零币和零钞"><a href="#零币和零钞" class="headerlink" title="零币和零钞"></a>零币和零钞</h2><ul>
<li>零币系统中存在基础币和零币，通过基础币和零币之间的来换转换，消除旧地址和新地址的关联性</li>
<li>零钞系统使用ZK-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工信息，区块链上不显示交易地址和金额，交易通过零知识证明进行</li>
</ul>
<h2 id="NP-Proof"><a href="#NP-Proof" class="headerlink" title="NP-Proof"></a>NP-Proof</h2><ul>
<li>例子<ul>
<li>证明N是2个大质数的乘积</li>
</ul>
</li>
</ul>
<h2 id="zk-snark"><a href="#zk-snark" class="headerlink" title="zk-snark"></a>zk-snark</h2><ul>
<li>非交互性，证明者向验证者发送一次信息，两者无需交互</li>
<li>验证速度快，存储空间小</li>
<li>应用<ul>
<li>Zcash<ul>
<li>保护交易的具体信息，只要说明币的来源</li>
<li>是第一个广泛使用zk-snark的应用</li>
</ul>
</li>
<li>Filecoin<ul>
<li>规模最大</li>
<li>提供复制证明和时空证明<ul>
<li>复制证明：初次完成存储交易，验证存储提供者存储了数据</li>
<li>时空证明：随着时间推移，证明存储提供者依然持续存储原始数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="ZkSync"><a href="#ZkSync" class="headerlink" title="ZkSync"></a>ZkSync</h4><ul>
<li>基于zk-snarks</li>
<li>提供链上存储和链下存储</li>
</ul>
<h4 id="StarkWare"><a href="#StarkWare" class="headerlink" title="StarkWare"></a>StarkWare</h4><ul>
<li>基于zk-stark</li>
<li>透明、扩展、抗量子攻击</li>
</ul>
<h4 id="Polygon"><a href="#Polygon" class="headerlink" title="Polygon"></a>Polygon</h4><ul>
<li>多种layer2扩容方案的聚合器</li>
<li>POS</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/" data-id="clrj8k00t00114wuw10f14iji" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Note/区块链开发/DeFi" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/DeFi/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.642Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3/">Web3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/DeFi/">DeFi</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>去中心化的金融交易所<ul>
<li>中心化金融CeFi：受相关部门监管，严格遵守规定，客户没有隐私，信息不透明，客户权限有限</li>
<li>去中心化金融DeFi：资产由客户自己掌控，无监管，信任、低门槛、高效、高隐私性、可组合、可交互、透明、自动化、可编程、开发简单</li>
</ul>
</li>
<li>可以链上借贷，闪电贷，超额抵押，快速套利（价格差）</li>
<li>提供稳定币，通过链下抵押资产、链上抵押资产、算法实现（波动较大）实现</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><h3 id="DID身份"><a href="#DID身份" class="headerlink" title="DID身份"></a>DID身份</h3><ul>
<li>链上数据：转账、DeFi交互、NFT交易&#x2F;持有等一切链上行为</li>
<li>链下数据：Web2身份、POP、SBT</li>
<li>信息聚合协议：对链上原始数据、各种凭证数据的加工聚合</li>
<li>身份管理工具：钱包、域名</li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li>Galxe：链上凭证基础平台</li>
<li>ENS：域名绑定，提供.eth后缀域名注册服务</li>
<li>SPACEID：域名绑定，提供.bnb后缀的域名注册服务，迭代速度和落地速度更快。链接Web2，建立个人品牌</li>
<li>Compound：</li>
</ul>
<h3 id="Uniswap"><a href="#Uniswap" class="headerlink" title="Uniswap"></a>Uniswap</h3><ul>
<li><p>提供代币质押兑换，需要付手续费</p>
</li>
<li><p>发行代币不用经过审查，只需要满足其代币标准和流通性标准即可</p>
</li>
<li><p>代币置换规则（恒定乘积做市商）</p>
<ul>
<li>规则：A币 * B币 &#x3D; 常数</li>
<li>例子：<ul>
<li>假设 1A &#x3D; 1000B，池子中有 10A，10000B，则常数为100,000</li>
<li>当用户想出售一个A换B时，池子中<ul>
<li>A &#x3D; 10 + 1 &#x3D; 11</li>
<li>B &#x3D; 100,000 &#x2F; 11 ≈ 9090</li>
<li>即置换出 10000 - 9090 &#x3D; 910B</li>
<li>常数 &#x3D; 11 * 9090 &#x3D; 99,990</li>
</ul>
</li>
<li>置换比例不是 1：1000的比例，是因为例子中币数量太少，导致兑换比例差距过大</li>
<li>大池子中这个比例就会很接近 1：1000的比例</li>
</ul>
</li>
</ul>
</li>
<li><p>V3和V2的区别</p>
<ul>
<li><p><strong>流动性提供方式</strong>：在Uniswap V2中，流动性提供者需要预先将资产锁定在合约中，这使得他们无法在合约之外使用这些资产。而在Uniswap V3中，流动性提供者可以通过智能合约将资产自由地借出或归还，而不需要锁定它们。这使得流动性提供者的操作更加灵活。</p>
</li>
<li><p><strong>交易逻辑</strong>：Uniswap V3和V2的交易逻辑也有很大的不同。在V2中，交易是直接在AMM池中进行的，而V3则引入了一个新的交易类型——单币交易。这意味着在V3中，用户可以单独对某一个币进行交易，而不需要考虑AMM池中的其他币种。</p>
</li>
<li><p><strong>费用结构</strong>：在费用结构上，V3也进行了优化。它引入了两种新的费用类型：交易费和滑点费。交易费是针对每笔交易收取的费用，而滑点费则是针对交易对价格波动收取的费用。这种费用结构可以更好地激励流动性提供者提供更好的交易体验。</p>
</li>
<li><p><strong>虚拟流动性</strong>：为了提高资金利用率，但是只能在特定的价格区间做市，需要用户自己设置需要做市的价格区间</p>
<ul>
<li>v2公式<ul>
<li>x * y &#x3D; k（x是代币A的数量，y是代币B的数量，k是流动性代币的数量）</li>
<li>y &#x3D; p * x（p是价格）</li>
<li>p * x^2^ &#x3D; k</li>
<li>x &#x3D; $\sqrt{k &#x2F; p}$，y &#x3D; $\sqrt{k * p}$</li>
</ul>
</li>
<li>v3公式：<ul>
<li>（x + x_virtual)  * （y + y_virtual）&#x3D; k</li>
<li>x_virtual &#x3D; $\sqrt{k &#x2F; p(最高价)}$ ，y_virtual &#x3D; $\sqrt{k * p(最低价)}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/DeFi/" data-id="clrj8k00r000p4wuwdwp24x5f" data-title="DeFi" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/defi/" rel="tag">defi</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E4%B8%AD%E9%97%B4%E4%BB%B6/">Java中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A1%86%E6%9E%B6/">Java框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web3/">Web3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3/">力扣</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A8%A1%E5%9D%97/">模块</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/">计算机知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/defi/" rel="tag">defi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/language/" rel="tag">language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solidity/" rel="tag">solidity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web3/" rel="tag">web3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" rel="tag">代码随想录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%A2%98100/" rel="tag">力扣热题100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%9B%E6%89%A3%E9%A2%98/" rel="tag">力扣题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%A5%9E/" rel="tag">左神</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%93/" rel="tag">库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag">技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97/" rel="tag">模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B/" rel="tag">模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E5%BF%B5/" rel="tag">理念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9Fan-quan/" rel="tag">系统an&#39;quan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" rel="tag">系统设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%84%E8%8C%83/" rel="tag">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E6%88%90/" rel="tag">集成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E7%BE%A4/" rel="tag">集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/defi/" style="font-size: 10px;">defi</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/language/" style="font-size: 10px;">language</a> <a href="/tags/solidity/" style="font-size: 10px;">solidity</a> <a href="/tags/web3/" style="font-size: 12.86px;">web3</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 20px;">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 10px;">代码随想录</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 10px;">优化</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 10px;">剑指offer</a> <a href="/tags/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%A2%98100/" style="font-size: 10px;">力扣热题100</a> <a href="/tags/%E5%8A%9B%E6%89%A3%E9%A2%98/" style="font-size: 10px;">力扣题</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">基础</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E5%B7%A6%E7%A5%9E/" style="font-size: 10px;">左神</a> <a href="/tags/%E5%BA%93/" style="font-size: 10px;">库</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 18.57px;">开发</a> <a href="/tags/%E6%8A%80%E5%B7%A7/" style="font-size: 11.43px;">技巧</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12.86px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" style="font-size: 17.14px;">数据结构和算法</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 14.29px;">框架</a> <a href="/tags/%E6%A8%A1%E5%9D%97/" style="font-size: 15.71px;">模块</a> <a href="/tags/%E6%A8%A1%E5%9E%8B/" style="font-size: 11.43px;">模型</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 12.86px;">源码</a> <a href="/tags/%E7%90%86%E5%BF%B5/" style="font-size: 14.29px;">理念</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9Fan-quan/" style="font-size: 10px;">系统an'quan</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">系统设计</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E8%A7%84%E8%8C%83/" style="font-size: 10px;">规范</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a> <a href="/tags/%E9%9B%86%E6%88%90/" style="font-size: 10px;">集成</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 10px;">集群</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 12.86px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E8%8B%B1%E8%AF%AD/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E5%9C%BA%E6%99%AF%E9%A2%98/">场景题</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 JianHong<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>