<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JianHong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Note">
<meta property="og:type" content="website">
<meta property="og:title" content="JianHong">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="JianHong">
<meta property="og:description" content="Note">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JianHong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="JianHong" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JianHong</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Note/后端/Java/开发/优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%BC%80%E5%8F%91/%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.688Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%BC%80%E5%8F%91/%E4%BC%98%E5%8C%96/">开发优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>减少STW出现的次数</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>jdk自带的JvisualVM可视化虚拟机内存模型</li>
<li>jps查看运行中的java进程</li>
<li>jmap查看堆内存的占用情况</li>
<li>jstack查看线程栈的情况</li>
<li>jconsole图形界面的，多功能的监测工具，实时监测</li>
<li>Arthas<ul>
<li>阿里的JVM监控工具</li>
<li>可以定位死锁和CPU占用高的线程，能定位到异常代码</li>
<li>反编译线上代码</li>
<li>直接修改线上代码的值<ul>
<li>将执行中的代码反编译并保存为文件<ul>
<li>jad –source-only 全类名 &gt; 文件存放位置</li>
</ul>
</li>
<li>编辑此文件<ul>
<li>vim</li>
</ul>
</li>
<li>将修改过后的文件进行编译<ul>
<li>mc 文件存放地址</li>
</ul>
</li>
<li>将编译后的字节码文件记载进线上程序<ul>
<li>redefine 文件存放地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JVM指令"><a href="#JVM指令" class="headerlink" title="JVM指令"></a>JVM指令</h3><table>
<thead>
<tr>
<th>效果</th>
<th>指令</th>
</tr>
</thead>
<tbody><tr>
<td>堆内存的最大大小</td>
<td>-Xmx {大小}</td>
</tr>
<tr>
<td>堆内存的最小(初始)大小</td>
<td>-Xms {大小}</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn {大小}</td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRation&#x3D; {大小}</td>
</tr>
<tr>
<td>幸存区晋升阈值，即对象进入老年代年龄</td>
<td>-XX:MaxTenuringThreshold&#x3D; {大小}</td>
</tr>
<tr>
<td>新生代和老年代比例</td>
<td>-XX:NewRation&#x3D;  {大小}: {大小}</td>
</tr>
<tr>
<td>禁用显式的垃圾回收</td>
<td>-XX:+DisableExplicitGC</td>
</tr>
<tr>
<td>查看垃圾回收详细参数</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td>开启串行垃圾回收器</td>
<td>-XX:+UseSerialGC&#x3D;Serial+SeriaOld</td>
</tr>
<tr>
<td>设置from区晋升老年代阈值</td>
<td>-XX:TargetSurvivorRatio&#x3D;90</td>
</tr>
<tr>
<td>采用自适应新生代大小</td>
<td>-XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>调整垃圾回收时间和总时间占比</td>
<td>-XX:GCTimeRatio&#x3D;ratio</td>
</tr>
<tr>
<td>最大暂停毫秒数</td>
<td>-XX:MaxGCPauseMillis&#x3D;ms</td>
</tr>
<tr>
<td>开启指针压缩</td>
<td>-XX:+UseCompressedOops</td>
</tr>
<tr>
<td>查看虚拟机生效的参数</td>
<td>-XX:+PrintFlagsFinal</td>
</tr>
<tr>
<td>对字符串去重</td>
<td>-XX:+UseStringDeduplication</td>
</tr>
<tr>
<td>类加载器加载的类不再使用时卸载它加载的所有类</td>
<td>-XX:+ClassUnloadingWithConcurrentMark</td>
</tr>
<tr>
<td>设置并发标记的起始时间</td>
<td>-XX:InitiatingHeapOccupancyPercent</td>
</tr>
<tr>
<td>大对象直接进入老年代(只在Serial和ParNew有效)</td>
<td>-XX:PetenureSizeThreshold&#x3D;</td>
</tr>
</tbody></table>
<h3 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h3><ol>
<li><p>预估系统产生的对象的大小，调整Eden，Old，Survivor区的比例，尽量使快速过期的对象不进入Old区</p>
<ol>
<li>可以通过压测来评估</li>
</ol>
</li>
<li><p>权衡堆的大小</p>
<ul>
<li>堆大GC时间短，但GC次数多</li>
<li>堆小GC时间长，但GC次数少</li>
</ul>
</li>
<li><p>Xmx 和 Xms 一样大可以减少GC次数，但GC时间长</p>
<ul>
<li>可以设置最小空闲比例<ul>
<li>MinHeapFreeRatio。默认40，小于则扩展</li>
</ul>
</li>
<li>设置最大空闲比例<ul>
<li>MaxHeapFreeRatio，默认70，大于则压缩</li>
</ul>
</li>
</ul>
</li>
<li><p>对字符串去查</p>
<ul>
<li><code>-XX: UseStringDeduplication</code></li>
</ul>
</li>
<li><p>新生代优化</p>
<ul>
<li><p>尽量能容纳所有 [ 并发量*(请求 - 响应) ] 的数据</p>
</li>
<li><p>幸存区需要大到能保留[ 当前活跃对象+需要晋升的对象 ]</p>
</li>
<li><p>合理的晋升阈值，让长时间存活对象尽早晋升至老年代</p>
</li>
</ul>
</li>
<li><p>老年代优化</p>
<ul>
<li>调大老年代的内存</li>
<li>大对象直接进入老年代</li>
<li>设置对象进入老年代的年龄</li>
</ul>
</li>
<li><p>幸存区优化</p>
<ul>
<li>提高From区的利用率，超过90%时进入老年代<ul>
<li><code>-XX: TargetSurvivorRatio=90</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Spring优化"><a href="#Spring优化" class="headerlink" title="Spring优化"></a>Spring优化</h2><p>事务优化</p>
<ol>
<li>避免大事务，事务粒度应该小一些</li>
</ol>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ul>
<li>针对数据量大，查询频繁的表需要建立索引</li>
<li>对经常需要作为查询条件，排序，分组的字段建立索引</li>
<li>对区分度高的字段建立索引，尽量建唯一索引</li>
<li>尽量使用联合索引，并满足最左前缀法则，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>索引不是越多越好，会影响增删改效率</li>
<li>不能为可以为null的字段建立索引，需要使用 not null 约束，当优化器知道每列是否包含null值时，它可以更好的确定哪个索引最有效的用于查询</li>
</ul>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul>
<li>没有满足最左前缀法则，跳过其中某一列或顺序不正确则其之后索引失效 </li>
<li>联合索引中使用了 &gt; &lt; ，（&gt;&#x3D;，&lt;&#x3D;不会失效）</li>
<li>like “%xx”（左模糊）</li>
<li>字符串没加引号</li>
<li>or两端有一端没有索引</li>
<li>MySQL评估走全表更快时</li>
<li>索引的字段进行运算时</li>
<li>索引的字段进行类型转换</li>
<li>索引的字段使用了函数</li>
<li>返回的字段很多，musql可能会选择不走索引</li>
<li>联合索引前部分用值比较，后面用了模糊比较，则从模糊比较处索引失效</li>
</ul>
<h3 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h3><ul>
<li>对较长的字符型字段建立前缀索引<ul>
<li><code>create Index on 表名(字段(长度))</code></li>
<li>前缀的长度的大小最好是：<ul>
<li>按前缀长度去重后的数量 &#x2F; 总数量</li>
<li>越接近1越好</li>
</ul>
</li>
</ul>
</li>
<li>使用 <code>force index</code> 强制使用索引</li>
<li>查询的字段尽量覆盖索引，减少 select * 的使用</li>
<li>mysql5.6之后支持索引下推，能减少回表</li>
<li>如果存储介质是机械硬盘的话，可以打开MRR，它可以把id存到buffer中，排序后写入磁盘</li>
<li>插入大批量数据时，使用load指令</li>
<li>手动提交事务</li>
<li>按主键顺序操作数据</li>
</ul>
<h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><ul>
<li><p>慢查询日志</p>
<ul>
<li><p>默认没有开启，需要在 <code>/etc/my.cnf</code> 中配置以下内容</p>
<ul>
<li><p><code>show_query_log = 1</code> 开启慢查询日志</p>
</li>
<li><p><code>long_query_time = 2</code> SQL查询超过2秒的为慢查询</p>
</li>
</ul>
</li>
<li><p>重启mysql，在<code>/var/lib/mysql/localhost-slow.log</code> 中查看日志</p>
</li>
</ul>
</li>
<li><p>SQL执行频率</p>
<ul>
<li><code>show session / global status like &#39;Com_&#39;</code></li>
</ul>
</li>
<li><p>查看SQL耗时情况</p>
<ul>
<li>每一条SQL耗时：<code>show profiles</code> </li>
<li>指定SQL各阶段耗时：<code>show profile for query &#123;id&#125;</code> </li>
<li>指定SQL的CPU使用情况：<code>show profile cpu for query &#123;id&#125;</code></li>
</ul>
</li>
<li><p>查看SQL执行计划</p>
<ul>
<li><code>explain sql语句</code> <ul>
<li><p>id：sql序列号，id值越大越先执行</p>
</li>
<li><p>select_type：查询的类型</p>
<ul>
<li>simple：简单单表查询</li>
<li>primary：主查询，即外层的查询</li>
<li>union：联合查询后的查询</li>
<li>subquery：select&#x2F;where后的子查询</li>
</ul>
</li>
<li><p>type：连接类型（null、system、const、eq_ref、ref、range、index、all）</p>
<ul>
<li>如果使用的是主键索引或唯一索引一般是const</li>
</ul>
</li>
<li><p>possible_key：可能使用到的索引</p>
</li>
<li><p>key：实际使用到的索引</p>
</li>
<li><p>key_len：索引中使用的字节数（最大可能长度），越短越好</p>
</li>
<li><p>rows：必须要执行的查询的行数，innodb引擎中是一个估值</p>
</li>
<li><p>filtered：返回结果行数占需读取行数的百分比，越大越好</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><ul>
<li>如果存储介质是机械硬盘，可以设置MRR开启顺序存储，这个功能会将插入的值按id排好序存到buffer中，顺序写入磁盘，提高插入效率，因为机械硬盘需要一个磁盘寻址的过程会影响效率</li>
<li>插入大批量数据时使用 load 指令</li>
<li>手动提交事务</li>
<li>插入时按主键顺序插入</li>
<li>MySQL5.6 之后支持索引下推，能减少回表</li>
<li>分页查询时使用 覆盖索引 + 子查询（想查询的id）</li>
<li><code>select * </code> 优化，使用具体的字段</li>
<li>排序优化<ul>
<li>在创建索引是可以指定索引排序规则，符合规则的sql语句效率高</li>
<li>需要注意各字段的升降序，尽量一致，尽量覆盖索引</li>
<li>可以适当的增大排序缓冲区的大小<ul>
<li><code>sort_buffer_size</code> 默认是256k</li>
</ul>
</li>
</ul>
</li>
<li>Join 优化<ul>
<li>小表 join 大表</li>
<li>连接字段需要是索引字段</li>
<li>左右连接才有优化，内连接的话由mysql自行判断顺序</li>
<li>增大 join buffer 的大小</li>
<li>减少不必要的查询字段，可以缓存更多的数据</li>
<li>大表 join 大表的话可以为大表建立分区</li>
<li>算法<ul>
<li>NLJ算法：双重for，连接字段为非索引就是用这个算法</li>
<li>BNLJ算法：把 join 的驱动表放到了内存 buffer 中，减少了循环次数</li>
<li>INLJ算法：连接字段为索引字段用这个算法，内层表的连接索引字段进行匹配，减少内层表的循环次数</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%BC%80%E5%8F%91/%E4%BC%98%E5%8C%96/" data-id="clrj8k01n007e4wuw890jckgr" data-title="开发优化" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/基础/Web" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Web/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.686Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Web/">Web</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
<th>IO多路复用</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>同步阻塞</td>
<td>同步非阻塞</td>
<td>异步非阻塞</td>
<td>异步阻塞</td>
</tr>
<tr>
<td>组成</td>
<td>字节流&#x2F;字符流</td>
<td>Buffer、Channel、Selector</td>
<td></td>
<td></td>
</tr>
<tr>
<td>场景</td>
<td>连接数少，短链接</td>
<td>连接数多，流量小</td>
<td>连接数多，流量大</td>
<td>连接数多，流量</td>
</tr>
</tbody></table>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>字节流</p>
<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
</ul>
<p>字符流</p>
<ul>
<li><p>FileReader</p>
<ul>
<li>可以读一个字符或一个字符数组</li>
</ul>
</li>
<li><p>FileWriter</p>
<ul>
<li>可以写一个字符或一个字符数组或字符数组的一部分</li>
</ul>
</li>
</ul>
<p>缓冲流</p>
<ul>
<li><p>缓冲流自带8kb的缓存区，可以提高原始字节流读写数据的性能</p>
<ul>
<li><p>字节缓存流：</p>
<ul>
<li>BufferedInputStream &#x2F; BufferedOutputStream</li>
</ul>
</li>
<li><p>字符缓冲流：</p>
<ul>
<li>BufferedReader &#x2F; BufferedWrite</li>
<li>可按行读取</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>转换流</p>
<ul>
<li>InputStreamReader<ul>
<li>可以解决字符流读取不同编码乱码的问题</li>
<li>可以指定编码把原始字节流转换成字符流，解决乱码</li>
</ul>
</li>
<li>OutputStreamWriter<ul>
<li>按指定编码把字节输出流转换成字符输出流</li>
</ul>
</li>
</ul>
<p>序列化</p>
<ul>
<li>对象输入流，反序列化<ul>
<li>ObjectInputStream</li>
</ul>
</li>
<li>对象输出流，序列化<ul>
<li>ObjectOutputStream</li>
</ul>
</li>
</ul>
<p>打印流</p>
<ul>
<li>字节输出流<ul>
<li>PrintStream</li>
</ul>
</li>
<li>字符输出流<ul>
<li>PrintWriter</li>
</ul>
</li>
</ul>
<p>数据流</p>
<ul>
<li>数据输入流<ul>
<li>DataInputStream</li>
</ul>
</li>
<li>数据输出流<ul>
<li>DataOutputStream</li>
</ul>
</li>
</ul>
<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><ul>
<li>一个Socket会创建一个线程，线程间的竞争和上下文切换开销很大</li>
<li>每个线程还会占用栈空间和CPU资源</li>
<li>Socket等待时浪费系统资源</li>
<li>无法支持高并发场景，可用线程池优化，但并不能真正的解决问题</li>
</ul>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/../../../blog/source/images/image-20220310000437904.png" alt="image-20220310000437904"></p>
<ul>
<li>Buffer缓冲区<ul>
<li>是一个内存块，底层是一个数组，负责数据的读取和写入</li>
<li>固定容量，不能修改，读写需要指定操作数据的大小，不能超过容量</li>
<li>可以标记一个位置，然后通过reset方法跳到标记的位置</li>
<li>内部clear方法不会清除数据，它只会把position的位置设为0</li>
<li>可以分配直接内存给Buffer</li>
</ul>
</li>
<li>Channel管道<ul>
<li>是一个接口</li>
<li>一个Channel对应一个Buffer</li>
<li>负责传输，可以非阻塞的读写，也支持异步读写，双向传输</li>
</ul>
</li>
<li>Selector选择器<ul>
<li>一个Selector对应多个Channel</li>
</ul>
</li>
</ul>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ul>
<li>传统的select和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要遍历</li>
<li>IO多路复用epoll则会通知用户进程有Socket就绪并写入用户空间</li>
</ul>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><ul>
<li>使用一个bitmap用来表示哪几个文件描述符是被监听的，大小是1024位，<ul>
<li>每次与内核交互都需要传递这个bitmap，开销大且不好修改</li>
<li>位图不能复用，每次使用前需要将位图初始化</li>
</ul>
</li>
<li>执行select函数是会将用户态的bitmap复制到内核态中，交给内核来判断事件，是一个阻塞函数，当事件有变动时会将描述符对应的事件置位，然后返回<ul>
<li>开销比较大，而且当有事件就绪时不能明确知道是哪个事件，每次都需要遍历</li>
</ul>
</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li>封装了一个对象pollfd，可复用</li>
<li>执行poll函数是会将用户态的pollfd复制到内核态中，交给内核来判断事件，当事件有变动时会将pollfd中的revents置位为1，然后返回<ul>
<li>每次都要将就绪的事件置位后拷贝到内核空间，开销还是比较大的</li>
<li>当有事件就绪时不能明确知道是哪个事件，每次都需要遍历</li>
</ul>
</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul>
<li>epoll使用一个文件描述符管理多个描述符，将用户关心的事件放到内核中的一个事件表，这样在用户空间和内核空间只需要复制一次且只需要保存一个fd的引用即可，开销小</li>
<li>在内核态中，用户态通过一个fd就可以找到内核态中epoll</li>
<li>有一个监听列表、就绪队列和等待队列<ul>
<li>监听列表是红黑树结构的</li>
<li>等待队列保存的是调用epoll_wait的进程</li>
</ul>
</li>
<li>epoll对文件操作符的操作有两种触发模式<ul>
<li>LT（水平触发）：<ul>
<li>事件就绪后，用户可以选择处理或不处理，如果用户不处理，那么下次调用epoll_wait方法是还会将未处理的事件返回，即不会删除就绪列表中未处理的事件</li>
</ul>
</li>
<li>ET（边缘触发）：<ul>
<li>事件就绪后，用户必须处理，因为就绪列表在返回后已经清空了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul>
<li>客户端套接字，是两台机器间通信的端点</li>
<li>使用构造方法和服务器创建连接</li>
</ul>
<h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><ul>
<li>服务端套接字</li>
<li>使用构造方法侦听并接收连接服务端套接字的连接</li>
</ul>
<p>	</p>
<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><ol>
<li><p>把目录拷贝到tomcat目录下的webapps</p>
<ul>
<li>访问的路径就是项目的名称</li>
<li>可以把项目压缩成war包，拉入webapps就会自动创建项目</li>
</ul>
</li>
<li><p>在tomcat&#x2F;conf&#x2F;server.xml文件中配置项目</p>
</li>
</ol>
<ul>
<li><code>&lt;context path=&quot;虚拟路径&quot; doBase=&quot;实际地址&quot; /&gt; </code></li>
<li>不安全，一般不使用</li>
</ul>
<ol start="3">
<li>在tomcat&#x2F;conf&#x2F;Catalina&#x2F;localhost下新建一个xml文件 <ul>
<li><code>&lt;context path=&quot;虚拟路径&quot; doBase=&quot;实际地址&quot; /&gt; </code></li>
<li>热部署</li>
</ul>
</li>
</ol>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>​    1.当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资		源路径<br>​    2.查找web.xml文件，是否有对应的<url-pattern><br>​    3.找到对应的<servlet-class>全类名<br>​    4.tomcat会将字节码文件加载进内存，并为其创建对象<br>​    5.调用其方法。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>​    创建时：执行init方法，只执行一次<br>​        默认情况下，第一次被访问时，servlet被创建，并执行init<br>​        配置servlet的创建时机：（在xml中配置）<br>​            &lt;load-on-<code>startup</code>&gt;num</load-on-startup><br>​                num大于等于0在服务器创建时启动<br>​                num小于0在第一次访问时启动<br>​        注意：<br>​            init只执行一次，说明Servlet在内存中只有一个对象，即是单例的<br>​            多个用户同时访问时，可能存在线程安全问题<br>​            尽量不要在Servlet中定义成员变量，即使定义了，也不要修改值。<br>​    提供服务：执行service方法，执行多次<br>​        每次访问Servlet时会执行<br>​    被销毁：执行destroy方法，执行一次<br>​        服务正常关闭才会调用，会在销毁之前调用，一般用于释放资源</p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>​    HttpServlet extends GenericServlet extends Servlet<br>​        GenericServlet:<br>​            将Servlet的方法做了默认实现，之间Service()做了抽象<br>​        HttpServlet:<br>​            对http协议的一种封装，简化操作<br>​                重写doGet和doPost.实际上也是Service方法,只是区别了提交方式</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>​    每次创建servlet都需要写xml配置信息<br>​    解决：<br>​        在servlet3.0中支持注解配置，不需要配置xml了<br>​            @WebServlet(urlPatterns&#x3D;”资源路径”)<br>​            可以定义多个资源路径 {“&#x2F;a”,”&#x2F;b”….}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Web/" data-id="clrj8k01m007c4wuwcafg1pgt" data-title="Web" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/基础/Spring全家桶" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.685Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E6%A1%86%E6%9E%B6/">Java框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><ul>
<li>IOC：控制反转，即将对象的创建个调用交给Spring管理</li>
<li>DI：依赖注入</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>主要通过两个接口来实现容器的创建</p>
<ul>
<li>BeanFactory：<ul>
<li>spring核心容器，主要是内部使用</li>
<li>使用到对象是才创建，懒加载</li>
<li>提供getBean()方法</li>
</ul>
</li>
<li>ApplicationContext：<ul>
<li>继承了BeanFactory，扩展了更多功能国际化、匹配资源、发布事件、环境信息等</li>
<li>加载配置是就创建所有的对象，体验更好但是启动慢</li>
</ul>
</li>
</ul>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p><strong>加载方式</strong></p>
<ul>
<li>XML中 &lt;Bean id&#x3D;”” class&#x3D;”” &#x2F;&gt;</li>
<li>@Component、@service、@Controller、@Repository、@Import、@Bean</li>
<li>@ComponentScan(“路径”)、@Configuration</li>
<li>@ImportResource(“xml名”)</li>
<li>@Configuration(proxyBeanMethods &#x3D;)</li>
<li>FactoryBean&lt;T&gt;</li>
<li>容器对象.registerBean()</li>
<li>容器对象.registerSingleton(“Bean名”, Bean对象)    不会走bean的创建、依赖注入、初始化过程</li>
<li>实现 ImportSelector、ImportBeanDefinitionRegister、BeanDefinitionRegistryPostProcessor 接口，实现对应的方法</li>
<li>构造注入</li>
</ul>
<p><strong>加载控制</strong></p>
<ul>
<li>@Conditional()</li>
<li>根据一些条件决定是否加载Bean</li>
</ul>
<p><strong>作用域</strong></p>
<ul>
<li>singleton：单例</li>
<li>prototype：多例</li>
<li>request</li>
<li>session</li>
<li>application</li>
</ul>
<p><strong>生命周期</strong></p>
<ul>
<li>实例化前</li>
<li>实例化后</li>
<li>初始化前</li>
<li>初始化后</li>
<li>使用</li>
<li>销毁</li>
</ul>
<h2 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h2><h3 id="Bean后处理器"><a href="#Bean后处理器" class="headerlink" title="Bean后处理器"></a>Bean后处理器</h3><ul>
<li><p>AutowiredAnnotationBeanPostProcessor</p>
<ul>
<li>解析@Autowired、@Value</li>
</ul>
</li>
<li><p>CommonAnnotationBeanPostProcessor</p>
<ul>
<li>解析@Resource、@PostConstruct、@PostDestroy</li>
</ul>
</li>
<li><p>ConfigurationPropertiesBindingPostProcessor</p>
<ul>
<li>解析@ConfigurationProperties</li>
</ul>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator</p>
<ul>
<li><p>解析AOP相关注解</p>
</li>
<li><p>获取所有切面</p>
<ul>
<li>通过findEligibleAdvisors(目标类) 找到所有作用于目标类的切面，会将高级切面转化为低级切面</li>
</ul>
</li>
<li><p>创建代理</p>
<ul>
<li>通过wrapIfNecessary(目标类对象)，需要判断findEligibleAdvisors()返回的集合是否为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BeanFactory后处理器"><a href="#BeanFactory后处理器" class="headerlink" title="BeanFactory后处理器"></a>BeanFactory后处理器</h3><ul>
<li><p>ConfigurationClassPostProcessor</p>
<ul>
<li>解析@ComponentScan、@Bean、@import、@ImportResource</li>
</ul>
</li>
<li><p>MapperScannerConfigurer</p>
<ul>
<li>解析@MapperScan</li>
</ul>
</li>
<li><p>internalConfigurationAnnotationProcessor</p>
<ul>
<li>解析@Configuration、@Bean</li>
</ul>
</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><strong>是什么</strong></p>
<ul>
<li>AOP是IOC流程中的一个扩展点</li>
<li>作用是在不通过修改源代码的基础上，对其进行功能的添加</li>
<li>体现了装饰器模式</li>
<li>代理对象一般是在初始化之后创建</li>
<li>出现循环依赖时，则会在依赖注入之前创建，并暂存二级缓存中</li>
</ul>
<p><strong>使用的场景</strong></p>
<ul>
<li>记录日志、缓存处理、spring内置的事务处理</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>ajc编译器静态代理<ul>
<li>需要添加aspec-maven-plugin</li>
<li>原理是直接将增强方法写进类中，不使用代理，不走IOC</li>
</ul>
</li>
<li>Agent类静态代理<ul>
<li>需要添加JVM参数 <code>-Javaagent:maven仓库路径/</code></li>
<li>原理也是直接将增强方法写进类中，不使用代理，不走IOC</li>
</ul>
</li>
<li>JDK动态代理<ul>
<li>代理对象有实现接口则使用JDK代理，创建的代理和代理对象一个等级</li>
<li>前16次通过反射调用方法，后续都是直接调用</li>
</ul>
</li>
<li>Cglib动态代理<ul>
<li>创建的子类代理对象，所以被代理对象不能是final修饰的</li>
<li>直接调用被代理方法</li>
<li>基于ASM 实现的，动态字节码操作</li>
</ul>
</li>
<li>AspectJ<ul>
<li>属于编译时增强，基于字节码操作</li>
<li>切面多的话AspectJ性能更强</li>
</ul>
</li>
</ul>
<p><strong>使用</strong></p>
<ol>
<li>创建一个AOP处理类，添加@AspectJ 和 @Component</li>
<li>使用@Pointcut标注一个方法，指定代理的方法<ul>
<li>execution 表达式匹配方法名</li>
<li>@Annotation() 表达式匹配注解名</li>
</ul>
</li>
<li>选择对应的通知类型<ul>
<li>@Before、@After、@AfterReturning、@Around、@AfterThrowing</li>
</ul>
</li>
<li>切面<ul>
<li>@Advice</li>
</ul>
</li>
<li>优先级<ul>
<li>@Order(值)    前置通知值小优先，后置通知值大优先</li>
</ul>
</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>代理对象无法增强静态方法</li>
<li>Jdk代理和代理对象时同级关系，而cglib代理和代理对象时父子关系，所以代理对象不能是final修饰</li>
<li>Jdk代理前16次都是通过反射的方式调用目标方法</li>
<li>cglib代理通过代理方法直接调用目标方法</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>是什么</strong></p>
<ul>
<li>即要么都成功，要么都失败，不能存在中间状态</li>
<li>事务一般加在Service层</li>
<li>底层使用AOP，通过TransactionInterceptor实现</li>
<li>@Transaction<ul>
<li>propagation传播属性</li>
<li>isolation隔离级别</li>
<li>rollbackFor</li>
<li>noRollbackFor</li>
</ul>
</li>
</ul>
<p><strong>事务的传播行为</strong></p>
<ul>
<li>Requirded：A有B就用A的，没有就创建</li>
<li>Required_New：不管A有没有，B创建新的</li>
<li>Supports：A有就用A的，没有就不用</li>
<li>Not_Supports：A有就挂起，B不用事务</li>
<li>Mandatory：A没有就抛异常</li>
<li>Never：A有就抛异常</li>
<li>Nested：A里有，B在A里的事务执行，A里没有就在里面创建</li>
</ul>
<p><strong>事务失效的场景</strong></p>
<ul>
<li><p>异常捕获处理</p>
<ul>
<li>即catch到异常并处理时，spring就没发现有异常，所以事务失效</li>
<li>需要抛出才能回滚</li>
</ul>
</li>
<li><p>抛出非运行时异常&#x2F;检查异常</p>
<ul>
<li>非运行时异常如io读取异常等等，即编译阶段可以发现的异常</li>
<li>在@Transaction标注回滚异常类型为Exception可以解决</li>
</ul>
</li>
<li><p>非public方法</p>
</li>
<li><p>非代理对象调用被代理对象的方法</p>
</li>
<li><p>在事务方法中直接调用其他事务方法</p>
<ul>
<li>因为直接调用不是用到代理对象调用，其实是用的this</li>
<li>设置@EnableTransactionManagement(exposeProxy &#x3D; true)，然后使用AopContext.currentProxy()获取代理对象，然后执行方法</li>
</ul>
</li>
<li><p>多线程下可能出现失效</p>
</li>
<li><p>mysql没开启事务</p>
</li>
</ul>
<h2 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h2><p><strong>Aware</strong></p>
<ul>
<li><p>BeanNameAware：注入Bean的名字</p>
</li>
<li><p>BeanFactoryAware ：注入BeanFactory容器   </p>
</li>
<li><p>ApplicationContextAware：</p>
<ul>
<li>接口</li>
<li>注入ApplicationContext容器</li>
</ul>
</li>
<li><p>EmbeddedValueResolverAware：解析 $ { }</p>
</li>
</ul>
<p><strong>InitializingBean</strong></p>
<ul>
<li>容器初始化接口</li>
</ul>
<h1 id="SpringWebFlux"><a href="#SpringWebFlux" class="headerlink" title="SpringWebFlux"></a>SpringWebFlux</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>异步非阻塞的框架、响应式编程，功能和SpringMVC类似，基于Netty</p>
</li>
<li><p>SpringWebFlux + Reactor + Netty</p>
</li>
<li><p>请求和响应是 ServerReuquest 和 ServerResponse</p>
</li>
<li><p>观察者模式 Oberver（Flow取代）</p>
</li>
<li><p>主要使用Flux 和 Mono</p>
<ul>
<li><p>Flux</p>
<ul>
<li>声明多个数据流</li>
<li>可传入数组（fromArray）、集合（fromItertr）、流（fromStream）</li>
</ul>
</li>
<li><p>Mono</p>
<ul>
<li>声明0个或1个数据流</li>
</ul>
</li>
</ul>
</li>
<li><p>可以发送信号</p>
<ul>
<li>错误信号</li>
</ul>
</li>
<li><p>需要订阅后才能发出数据流</p>
<ul>
<li>subscribe()</li>
</ul>
</li>
<li><p>操作符</p>
<ul>
<li>map 映射</li>
<li>flatMap 将元素映射成流</li>
</ul>
</li>
</ul>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>基于spring的框架，有内置的tomcat，可以独立运行</li>
<li>约定大于配置理念，最大的简化配置</li>
<li>核心功能在于依赖管理和自动配置<ul>
<li>依赖管理：<ul>
<li>spring-boot-dependencies 几乎声明了所有开发中常用依赖的版本号，实现自动版本仲裁</li>
</ul>
</li>
<li>自动配置<ul>
<li>启动时自动加载所有的自动配置类</li>
<li>如果不想使用默认的配置，可以直接@Bean替换底层的组件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><ul>
<li>自定义后置处理器，实现EnvironmentPostProcessor接口</li>
</ul>
<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="解决乱码问题"><a href="#解决乱码问题" class="headerlink" title="解决乱码问题"></a>解决乱码问题</h2><ul>
<li><p>配置全局过滤的filter</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h2><ul>
<li><p>自定义拦截器</p>
<ul>
<li><p>创建拦截器类实现HandlerInterceptor接口</p>
<ul>
<li>preHandle()<ul>
<li>处理前被调用</li>
<li>有返回值，返回false后续的方法都不会执行了</li>
</ul>
</li>
<li>postHandle<ul>
<li>处理之后被调用 </li>
<li>在DispatcherServlet进行视图渲染之前调用，所以我们可以对ModelAndView对象进行操作</li>
</ul>
</li>
<li>afterCompletion</li>
</ul>
</li>
<li><p>配置拦截器，xml或者配置类</p>
<p><img src="/../../../../../images/image-20220113151640290.png" alt="image-20220113151640290"></p>
</li>
</ul>
</li>
</ul>
<h1 id="SpringCLoud"><a href="#SpringCLoud" class="headerlink" title="SpringCLoud"></a>SpringCLoud</h1><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>Eureka</p>
<ul>
<li>支持服务注册和拉取、心跳检测</li>
<li>Eureka采用AP方式</li>
<li>服务提供者启动时会向Eureka注册信息，每30秒发送一次心跳</li>
<li>Eureka为服务消费者提供服务提供者的信息</li>
<li>负载均衡策略<ul>
<li>默认是轮询，定时任务30s获取服务提供者信息</li>
</ul>
</li>
</ul>
<p>Nacos</p>
<ul>
<li><p>支持服务注册和拉取、心跳检测</p>
<ul>
<li>临时实例采用心跳检测，非临时采用主动检测</li>
<li>临时实例不正常会剔除，非临时不会</li>
</ul>
</li>
<li><p>支持服务列表变更的消息推送模式，服务列表更新更及时</p>
</li>
<li><p>Nacos集群采用AP模式，集群中存在非临时实例采用CP模式</p>
</li>
<li><p>基于Java语言实现的</p>
</li>
<li><p>服务分级存储模型</p>
<ul>
<li>服务 - 集群 - 实例</li>
<li>可以进行地域划分集群</li>
</ul>
</li>
<li><p>负载均衡策略</p>
<ul>
<li>默认是随机访问</li>
<li>需要在配置文件中配置使用Nacos负载均衡规则<ul>
<li>服务调用优先调用本地集群，本地集群不可用时访问其他集群</li>
</ul>
</li>
</ul>
</li>
<li><p>可以在nacos控制面板中设置实例权重</p>
<ul>
<li>权重设置为0则不处理请求</li>
</ul>
</li>
<li><p>实例可以选择临时实例或者非临时实例</p>
</li>
<li><p>本质上也是通过mvc调用接口实现</p>
</li>
</ul>
<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>Nacos</p>
<ul>
<li>统一配置管理，实现热更新，常配置开关或者格式</li>
<li>服务拉取Nacos配置<ul>
<li><p>新建一个boostrapt.yml 或者 properties 文件</p>
<ul>
<li>配置Nacos地址，配置文件后缀名，模块名</li>
</ul>
</li>
<li><p>使用@NacosValue可以获取配置文件信息</p>
</li>
</ul>
</li>
<li>配置自动刷新，优先使用nacos的配置<ul>
<li>接口上添加 @RefreshScope 实现自动刷新</li>
<li>也可以创建一个类专门完成属性的加载<ul>
<li>类上添加 @ConfigurationProperties(prefix &#x3D; “”)、@Component</li>
<li>对应Nacos配置中的前缀</li>
<li>创建一个变量接收这个配置的信息</li>
</ul>
</li>
</ul>
</li>
<li>环境隔离NameSpace 多环境配置共享<ul>
<li>Nacos控制面板中可以创建命名空间，在配置文件中配置namespace，内容是命名空间自动生成的id</li>
<li>多种配置的优先级<ul>
<li>服务名称-开发环境.yaml  &gt; 服务名称.yaml 中 &gt; 本地配置</li>
</ul>
</li>
<li>命名空间可以按服务来划分，各个服务使用自己的命名空间</li>
<li>可以使用配置多配置文件，将配置信息都放在nacos上</li>
</ul>
</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><ul>
<li>请求先到Ribbon，然后Ribbon取注册中心找服务地址</li>
<li>使用时往Spring容器中添加IRule对应的子类即可（全局），也可以在配置文件中配置（部分微服务）</li>
<li>默认是懒加载的，第一次访问时才会创建LoadBalanceClient，请求时间比较长<ul>
<li>可以设置饥饿加载，启动时就会创建，可以指定饥饿加载的服务器</li>
</ul>
</li>
</ul>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>RoundRobinRule：轮询</li>
<li>AvailabilityFilteringRule：忽略短路和并发数过高（可以指定上限）的服务器</li>
<li>WeightedResponseTimeRule：服务器响应时间越久，服务器的权重越小</li>
<li>ZoneAvoidanceRule：分区，再对区内轮询</li>
<li>BestAvailableRule：忽略短路的服务器，选择并发数低的服务器</li>
<li>RandomRule：随机</li>
<li>RetryRule：重试机制</li>
</ul>
<h3 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h3><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul>
<li>服务治理框架</li>
<li>支持多协议</li>
</ul>
<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>是一个声明式Http客户端</p>
</li>
<li><p>传统的Http远程调用是使用 RestTemplate ，存在一些问题</p>
<ul>
<li>代码可读性差，编程不统一</li>
<li>参数复杂Url难以维护</li>
</ul>
</li>
<li><p>自定义Fegin的配置</p>
<ul>
<li>Fegin运行自定义的配置来覆盖默认配置</li>
<li>配置：<ul>
<li><p>fegin.Longger.Level：修改日志等级</p>
<ul>
<li>NONE：没任何日志</li>
<li>BASIC：一次请求的请求时间，结束时间，耗时时间等基本信息</li>
<li>HEADERS：基本信息 + 请求头信息</li>
<li>FULL：基本信息 + 请求头信息 + 请求体 + 响应体</li>
</ul>
</li>
<li><p>fegin.codec.Decoder：响应结果的解析器，将Json 转换为 Java对象</p>
</li>
<li><p>fegin.codec.Encoder：请求参数编码</p>
</li>
<li><p>fegin.Contract：支持的注解格式，规定支持的注解，默认是SpringMVC的注解</p>
</li>
<li><p>fegin.Retryer：失败重试机制，默认是不重试</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>配置文件</li>
<li>加入Spring容器，创建对应的配置类<ul>
<li>全局配置：@EnableFeignClient(defaultConfiguration &#x3D; 配置类)</li>
<li>局部配置：@FeignClient(value &#x3D; “作用的服务”, configuration &#x3D; 配置类)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li>底层的客户端，修改为支持连接池的客户端（导包 - 配置）<ul>
<li>默认是 URLConnection，不支持连接池</li>
<li>Apache HttpClient：支持连接池</li>
<li>OKHttp：支持连接池</li>
</ul>
</li>
<li>日志级别最好设置为Basic</li>
</ul>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul>
<li>继承<ul>
<li>创建一个接口写这个方法声明，再让Client和Controller去继承和实现</li>
<li>缺点<ul>
<li>对SpringMVC不起作用，这个接口的参数列表中的映射不会被继承</li>
<li>服务紧耦合</li>
</ul>
</li>
</ul>
</li>
<li>抽取<ul>
<li>将方法声明，使用到的Pojo，默认配置等抽取为一个模块</li>
<li>缺点<ul>
<li>会将所有方法引入，多余了一些</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><ul>
<li>基于WebFlux实现d</li>
<li>拦截所有客户端请求，进行身份认证和权限校验</li>
<li>进行服务路由，负载均衡</li>
<li>请求限流</li>
<li>路由断言工厂 （predicates）<ul>
<li>配置写的字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件</li>
<li>spring 提供了11个断言工厂<ul>
<li>After、Before、Between、Cookie、Header、Host、Method、Path、Query、RemoteAddr、Weight</li>
</ul>
</li>
</ul>
</li>
<li>过滤器 （filters）<ul>
<li><p>当前路由过滤器</p>
</li>
<li><p>默认过滤器</p>
<ul>
<li>Default-filter</li>
</ul>
</li>
<li><p>全局过滤器</p>
<ul>
<li>GlobalFilter 接口</li>
</ul>
</li>
<li><p>执行顺序</p>
<ul>
<li>指定Order来决定执行顺序，值相同时，先执行默认，然后局部，然后全局</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全监控"><a href="#安全监控" class="headerlink" title="安全监控"></a>安全监控</h2><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><ul>
<li>雪崩问题<ul>
<li>超时处理：一定时间没响应就返回错误信息</li>
<li>舱壁模式（线程隔离）：限定每个业务能使用的线程数，避免tomcat资源耗尽</li>
<li>熔断降级：断路器统计业务执行的异常比例。超出阈值则熔断该业务，拦截访问该业务的一切请求</li>
<li>流量控制：限制业务访问的QPS，避免服务流量突增发生故障</li>
</ul>
</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><h4 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h4><ul>
<li>线程池隔离</li>
<li>信号量隔离</li>
</ul>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><h3 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h3><ul>
<li>通过过滤器给请求添加一个特殊标识的头信息，携带这个信息的请求才可以正常访问</li>
</ul>
<h3 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h3><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><ul>
<li>线程池<ul>
<li>支持主动超时、支持异步调用</li>
<li>线程开销大</li>
<li>支持低扇出</li>
</ul>
</li>
<li>信号量（默认实现）<ul>
<li>轻量级，开销小</li>
<li>无主动超时和异步调用</li>
<li>高频调用、高扇出</li>
</ul>
</li>
</ul>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><ul>
<li>断路器<ul>
<li>closed：服务正常调用，统计服务异常比例，达到阈值则熔断，进入open状态</li>
<li>open：熔断状态，禁止目标服务调用，熔断持续一段时间后进入half-open状态</li>
<li>half-open：尝试请求服务，如果能正常访问则恢复到closed状态</li>
</ul>
</li>
<li>熔断策略<ul>
<li>慢调用：响应时间慢，一点数量的请求慢则熔断，可以设置响应时间阈值</li>
<li>异常比例：在一定请求中抛异常的请求数量超过一定比例则熔断</li>
<li>异常数：异常请求达到设置的异常数则熔断</li>
</ul>
</li>
</ul>
<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul>
<li>按照安全规则或者安全策略控制用户只能访问被授权的资源</li>
<li>权限管理包括用户身份认证和授权，简称认证授权<ul>
<li>认证：身份认证，就是判断用户是否合法（登录、指纹、人脸等等）</li>
<li>授权：即访问控制，对不同的用户分配不同的权限</li>
</ul>
</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><p>shiro</p>
<ul>
<li>轻量、简单、易于集成</li>
<li>但在微服务和扩展能力没有优势</li>
</ul>
</li>
<li><p>SpringSecurity</p>
<ul>
<li>易于集成，微服务首选框架</li>
</ul>
</li>
<li><p>自定义权限管理</p>
<ul>
<li>大项目、大公司需要，因为可以做到更安全</li>
</ul>
</li>
</ul>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/images/image-20230509162000402.png" alt="image-20230509162000402"></p>
<ul>
<li>认证器（Authentication）<ul>
<li>AuthenticationManager主要的实现类为ProviderManager，该实现类中管理了很多AuthenticationProvider实例，用来允许实现多种认证方式</li>
<li>Authentication实现类用来保存认证以及认证成功的信息</li>
<li>SecurityContextHolder用于获取认证信息， <ul>
<li>原理是用的ThreadLocal实现与线程绑定</li>
<li>第一次认证时的登录信息会保存到SecurityContextHolder中，使用完后会保存到session中，然后清空SecurityContextHolder</li>
<li>之后再请求时会先查session，如果存在登录信息则放入SecurityContextHolder中，用完再放回session并清空</li>
<li>方便在各个层级使用</li>
</ul>
</li>
</ul>
</li>
<li>授权器（Authorization）<ul>
<li>AccessDecisionManager：访问决策管理器，用来决定此次访问是否被允许</li>
<li>AccessDecisionVoter：访问决策投票者，会检查用户是否有对应的角色并进行投票</li>
<li>ConfigAttribute：用来保存授权时的角色信息</li>
</ul>
</li>
</ul>
<h3 id="认证-原理"><a href="#认证-原理" class="headerlink" title="认证 &amp; 原理"></a>认证 &amp; 原理</h3><ul>
<li>本质上是用的一系列的spring提供的过滤器filter，并不是原生的filter</li>
<li>spring提供了DelegatingFilterProxy，将spring的filter转换为原生的filter，使用了代理模式实现</li>
<li>使用了FilterChainProxy，管理了spring的filter，并使其按一定的顺序执行，使用了责任链的设计模式</li>
<li>通过FilterChainProxy嵌入到原生的filter过滤链中，由FilterChainProxy统一管理SecurityFilter</li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>由SpringSecurityFilterChain管理了所有需要使用的过滤器</li>
</ul>
<p><img src="/./../../../../../images/image-20230513114552313.png" alt="image-20230513114552313"></p>
<ul>
<li>默认会加载这15个filter</li>
</ul>
<h3 id="自定义认证"><a href="#自定义认证" class="headerlink" title="自定义认证"></a>自定义认证</h3><h3 id="密码加密-1"><a href="#密码加密-1" class="headerlink" title="密码加密"></a>密码加密</h3><h3 id="Remenber-Me"><a href="#Remenber-Me" class="headerlink" title="Remenber Me"></a>Remenber Me</h3><h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><h3 id="跨域CROS"><a href="#跨域CROS" class="headerlink" title="跨域CROS"></a>跨域CROS</h3><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h3 id="授权-授权模型"><a href="#授权-授权模型" class="headerlink" title="授权 &amp; 授权模型"></a>授权 &amp; 授权模型</h3><h1 id="OAuth2-Jwt"><a href="#OAuth2-Jwt" class="headerlink" title="OAuth2 &amp; Jwt"></a>OAuth2 &amp; Jwt</h1><h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><strong>@Bean</strong></p>
<ul>
<li>向容器注册组件</li>
<li>只能标注方法</li>
<li>@Bean标注的方法不支持重载，只有参数最多的方法会执行</li>
</ul>
<p><strong>@Autowired</strong></p>
<ul>
<li><p>spring提供的，先ByType后ByName，对象必须存在</p>
</li>
<li><p>失效的情况</p>
<ul>
<li>创建对象后创建BeanFactoryPostProcessor</li>
</ul>
</li>
<li><p>scope失效的情况</p>
<ul>
<li>单例对象中注入多例对象，多例会失效<ul>
<li>可以添加@Lazy解决（原理是代理）</li>
<li>可以在@Scope(value &#x3D; “prototype”, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</li>
<li>使用ObjectFactory&lt;多例对象&gt;解决</li>
<li>使用容器对象的getBean方法获取多例对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>@Qualifer</strong></p>
<ul>
<li>不注入</li>
</ul>
<p><strong>@Resource</strong></p>
<ul>
<li>有JDK提供，ByType和ByName，可以指定Name</li>
</ul>
<p><strong>@Value</strong></p>
<p>- </p>
<p><strong>@Import</strong></p>
<ul>
<li>向容器中创建组件，默认组件名字是全类名</li>
</ul>
<p><strong>@Mapper</strong></p>
<ul>
<li>扫描mapper包，获取其元信息，判断是否是注解</li>
<li>获取Bean定义，传入MapperFactoryBean类作为参数</li>
</ul>
<p><strong>@Configuration</strong></p>
<ul>
<li>被标注的类相当于一个工厂类，类中@Bean标注的方法相当于工厂方法</li>
<li>会给标注的类生成代理对象，目的是保证bean的单例特性<ul>
<li>默认是单例模式，可设置为多例</li>
</ul>
</li>
</ul>
<p><strong>@Nullable</strong></p>
<p>- </p>
<p><strong>@Indexed</strong></p>
<ul>
<li>在编译时将标注了该注解的Bean，会生成&#x2F;META-INF&#x2F;spring.components文件并加入其中</li>
<li>扫描包时会先查这个文件并加载其中的Bean</li>
<li>没有再走包sao’miao</li>
</ul>
<p><strong>@Order</strong></p>
<ul>
<li>数字越小的优先级越大</li>
</ul>
<p><strong>@Lazy</strong></p>
<ul>
<li>标注类上是延迟创建</li>
<li>标注方法参数或成员变量上，</li>
</ul>
<p><strong>@primary</strong></p>
<ul>
<li>优先注入该Bean</li>
</ul>
<p><strong>@Conditional</strong></p>
<ul>
<li>条件装配，有很多子实现</li>
<li>写在方法上有先后执行</li>
<li>设定条件，按条件装配容器</li>
</ul>
<p><strong>@ImportResource</strong></p>
<ul>
<li>导入资源（xml）</li>
</ul>
<p><strong>@RequestMapping</strong></p>
<ul>
<li>映射浏览器的请求</li>
</ul>
<p><strong>@ResponseBody</strong></p>
<ul>
<li>将方法返回的内容写给浏览器</li>
</ul>
<p><strong>@RestController</strong></p>
<ul>
<li>等于 @ResponseBody 加 @Controller</li>
</ul>
<p><strong>@EnableConfigurationProperties</strong></p>
<ul>
<li>启用 @ConfigurationProperties 的功能</li>
</ul>
<p><strong>@ConfigurationProperties</strong></p>
<ul>
<li>将.property文件中的键值信息和Bean的属性进行绑定</li>
</ul>
<p>@RequestMapping</p>
<ul>
<li>method  请求方式<ul>
<li>method &#x3D; RequestMethod.请求方式</li>
</ul>
</li>
<li>params   指定限制请求参数的条件，支持简单的表达式</li>
<li>页面跳转<ul>
<li>直接返回字符串<ul>
<li>进行视图跳转</li>
</ul>
</li>
<li>通过ModelAndView对象返回<ul>
<li>new一个ModelAndView对象进行返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@RequestBody</p>
<ul>
<li>将前端传递过来的Json数据映射到类上</li>
</ul>
<p>@ResponseBody</p>
<ul>
<li>将后端返回的数据封装为Json格式返回</li>
</ul>
<p>@RequestParam</p>
<ul>
<li>当请求的参数名称与业务方法上形参的名字不一致时，使用该注解命名<ul>
<li>value                客户端请求的参数名</li>
<li>required           是否必须包含value值，默认时true，没有则报错</li>
<li>defaultValue    默认值</li>
</ul>
</li>
</ul>
<p>@PathVariable</p>
<ul>
<li>在请求映射上添加占位符(请求方式为get)<ul>
<li>@RequestMapping(“&#x2F;user&#x2F;<strong>{username}</strong>“);<ul>
<li>可以用method 来区分请求方式</li>
</ul>
</li>
<li>形参前加**@PathVariable**(value&#x3D;”username”)<ul>
<li>username 的值会自动赋值给形参</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@RequestHeader</p>
<ul>
<li>获得请求头信息<ul>
<li>value       请求头名字</li>
<li>required  是否必须携带此请求头</li>
</ul>
</li>
</ul>
<p>@CookieValue</p>
<ul>
<li>可以获得指定的Cookie的值</li>
</ul>
<p>@RestController</p>
<ul>
<li>@ResponseBody  +  @Controller</li>
</ul>
<p>@CrossOrigin</p>
<ul>
<li>处理Ajax请求的跨域问题</li>
</ul>
<p>@RequestPart</p>
<ul>
<li>用于接收MultipartFile等复杂类型的入参</li>
</ul>
<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><p>DigestUtils</p>
<ul>
<li>md5加密</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" data-id="clrj8k01m00784wuwce1wbpq5" data-title="Spring全家桶" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/基础/JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/JVM/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.684Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/JVM/">JVM虚拟机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>存放new出来的对象、字符串常量池、静态变量<ul>
<li>字符串常量池是在1.7的时候移入堆中，之前都是在方法区中</li>
</ul>
</li>
<li>堆内存由年轻代和老年代组成</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>主要存放的是线程，每个线程开辟一块内存空间，称为线程栈<ul>
<li>最多占用1m内存</li>
</ul>
</li>
<li>线程栈中由多个栈帧组成，栈帧是调用的每个方法<ul>
<li>栈帧包括：，局部变量，<ul>
<li>操作数栈：方法运行期间数据的操作空间 </li>
<li>动态链接：符号引用转变为直接引用</li>
<li>方法出口：记录方法结束时下一句执行的代码的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>存放本地方法（native method）<ul>
<li>本地方法是底层方法，主要是c和c++语言编写的</li>
</ul>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>存放类的信息，静态方法信息、类加载器，全局变量，常量<ul>
<li>类信息就是常量池就是一张表，里面有类名，方法名，参数类型，字面量等信息</li>
<li>当类被加载时，常量池的信息会放入运行时常量池，里面的符号地址变为真实地址</li>
</ul>
</li>
<li>1.7之前称为永久代，1.8之后称为元空间并开始使用物理（本地）内存，不受JVM管理了</li>
<li>类加载器将类信息加载进元空间，当类加载器加载的所有类不再被引用时，gc会将类加载器、加载的类、元空间的类信息释放</li>
<li>在1.7之前永久代空间不足会触发堆的垃圾回收</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>存放下一条要运行的代码的地址</li>
<li>便于线程切换</li>
<li>通过寄存器实现，是线程私有的，不会出现内存溢出</li>
</ul>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><ul>
<li><p>StringTable，1.7之后在堆中，是不能扩容的，底层是一个hash表</p>
</li>
<li><p>编译期优化</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>    <span class="comment">//是加到字符串常量池中的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> ,<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>   </span><br><span class="line">    <span class="comment">//s1+s2     </span></span><br><span class="line">    <span class="comment">//相当于 new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</span></span><br><span class="line">    <span class="comment">//new出来的是在堆中的</span></span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>    <span class="comment">//如果字符串常量池中有则引用，没有则创建</span></span><br><span class="line"><span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>    <span class="comment">//javac在编译期间已经确定结果一定为”ab&quot;</span></span><br><span class="line">s1 + s2      <span class="comment">//javac在编译期间已经不能确定结果一定为”ab&quot;，因为s1和s2是变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p>
</li>
<li><p>利用串池的机制。来避免创建重复的字符串对象</p>
</li>
<li><p>字符串拼接的原理时StringBuilder</p>
</li>
<li><p>字符串常量拼接的原理时编译期优化</p>
</li>
<li><p>可以使用intern方法，将字符串对象放入串池</p>
<ul>
<li>1.8时，串池有则不放入，没有则放入，会把串池中的对象返回</li>
<li>1.6时，串池有则不放入，没有则把对象赋值一份，放入串池，会把串池中的对象返回</li>
</ul>
</li>
<li><p>设置StringTable桶的个数减少哈希冲突</p>
<ul>
<li>-XX:StringTableSize&#x3D;(1009 - ….)   最少是1009个</li>
</ul>
</li>
<li><p>将字符串对象入池优化</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>栈、本地方法栈、程序计数器是线程私有的</li>
<li>堆、方法区&#x2F;元空间是线程共享的</li>
</ul>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><ul>
<li><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行</p>
</li>
<li><p>JMM定义的是线程本地内存和主内存的抽象关系，用于屏蔽各种硬件和操作系统的内存访问差异</p>
<ul>
<li>可见性：当线程修改了共享变量，其他线程能立即知道改变更</li>
<li>原子性：要么都发生，要么都不发生</li>
<li>有序性：按顺序执行</li>
</ul>
</li>
<li><p>本地内存是一个抽象的概念，并不真实存在，是一种规范，它包括了缓存，写缓冲区，寄存器、编译器</p>
<ul>
<li>写缓冲区：可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用</li>
</ul>
</li>
<li><p>从 java 源代码到最终实际执行的指令序列，会分别经历三种重排序</p>
<ol>
<li>编译器优化重排序<ul>
<li>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
</ul>
</li>
<li>指令级并行的重排序<ul>
<li>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
</ul>
</li>
<li>内存系统的重排序<ul>
<li>由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li>
</ul>
</li>
</ol>
</li>
<li><p>happens-before</p>
<ul>
<li>先行发生原则，判断数据是否存在竞争，线程是否安全<ul>
<li>次序规则：一个线程内的前一步操作后的结果对后一步来说一定是可见的</li>
<li>锁定规则：同一个锁的unlock操作一定先于lock操作</li>
<li>volatile变量规则：写操作后的数据一定是可以被读到的</li>
<li>传递规则：如果A先行于B，B先行于C，那么A一定先行于C</li>
<li>线程启动规则：Thread对象的start方法先行于线程中的所有操作</li>
<li>线程中断规则：interrupt方法先行于interrupted方法才能检测出线程中断事件</li>
<li>线程终止规则：线程中的所有操作都先行于线程的终止检测 isAlive</li>
<li>对象终结规则：初始化方法的执行一定先行于终止方法finalizefang’fa</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><ul>
<li>魔数与class文件的版本</li>
<li>常量池<ul>
<li>变量的属性、类型和名称</li>
<li>方法的属性、类型和名称</li>
</ul>
</li>
<li>访问标志</li>
<li>类索引、父类索引、接口索引</li>
<li>字段表属性</li>
<li>方法表属性</li>
<li>属性表属性</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ol>
<li>加载<ul>
<li>根据类的全限定名，将类的信息加载进方法区</li>
<li>在堆中生成一个对象指向该类，作为方法区的数据访问入口</li>
<li>如果这个类没有父类，会先加载他的父类</li>
</ul>
</li>
<li>验证<ul>
<li>验证类是否符合JVM规范，例如检查class文件的魔数，符号引用验证</li>
</ul>
</li>
<li>准备<ul>
<li>为静态变量分配空间，如果静态变量是基本数据类型的话为其设置默认值</li>
</ul>
</li>
<li>解析<ul>
<li>将类中的符号引用解析为直接引用</li>
</ul>
</li>
<li>初始化<ul>
<li>初始化即调用 <cinit>()V 方法，虚拟机会保证这个类的构造方法的线程安全</li>
<li>为静态变量赋值</li>
<li>初始化是懒惰的，使用时才初始化<ul>
<li>类在main方法中</li>
<li>类的静态变量或静态方法被访问</li>
<li>子类初始化时父类会在其之前初始化</li>
<li>子类访问父类的静态变量，只会触发父类初始化</li>
<li>new、class.forName</li>
</ul>
</li>
</ul>
</li>
<li>使用</li>
<li>销毁</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>Bootstrap ClassLoader 一级<ul>
<li>加载 JAVA_HOME&#x2F;jre&#x2F;lib 下的类，无法直接访问</li>
<li>C语言实现的，所以打印时为null</li>
</ul>
</li>
<li>Extension ClassLoader 二级<ul>
<li>加载 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下的类，显示为null</li>
</ul>
</li>
<li>Application ClassLoader 三级<ul>
<li>加载 classpath下的类，线程上下文加载器</li>
</ul>
</li>
<li>自定义类加载器 四级<ul>
<li>加载自定义位置的类，通过接口实现，常见于tomcat中</li>
<li>步骤：<ul>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写findClass方法</li>
<li>读取类文件的字节码</li>
<li>调用父类的defineClass方法来加载类</li>
<li>使用者调用该自定义类加载器的loadClass方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><ul>
<li>JDK1.2之后才有该模型</li>
<li>避免类的结构混乱，保护核心类不被篡改，安全</li>
<li>就是调用类加载器的loadClass方法，所经历的过程<ul>
<li>检查该类是否已经加载，有加载则返回</li>
<li>没加载找上级，让上级loadClass，上级有加载则返回</li>
<li>没加载再找上级，如果没上级了，则找BootstrapClassLoader，有则返回</li>
<li>每一层都找不到，调用findClass方法（每个类加载器自己扩展）来加载</li>
</ul>
</li>
</ul>
<h3 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h3><ul>
<li>执行方法区中的字节码文件</li>
<li>修改程序计数器的数据</li>
<li>垃圾收集线程</li>
</ul>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><ul>
<li>将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>将字节码解释为针对所有平台都通用的机器码</li>
</ul>
<h3 id="JIT即时编译器"><a href="#JIT即时编译器" class="headerlink" title="JIT即时编译器"></a>JIT即时编译器</h3><ul>
<li>将字节码编译为机器码，存入CodeCache中，下次遇到相同的代码，直接执行缓存中的，无需重复解释</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>gc root 对象不可被回收</li>
<li>GCRoots对象包括：虚拟机运行过程中的核心类对象，虚拟机栈中的局部变量表引用的对象，方法区中类静态属性引用和常量引用对象，本地方法栈中的引用的对象，被加锁的对象，活动线程中引用的对象</li>
<li>引用队列<ul>
<li>ReferenceQueue</li>
</ul>
</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>强引用<ul>
<li>在堆中创建对象并用一个变量引用为强引用</li>
</ul>
</li>
<li>软引用<ul>
<li>SoftReference&lt;&gt;(软引用, 引用队列)</li>
<li>垃圾回收过后内存仍然不足则会回收软引用，前提是没用强引用引用它</li>
<li>当软引用的对象被回收时，软引用会进入引用队列</li>
</ul>
</li>
<li>弱引用<ul>
<li>WeakReference&lt;&gt;(软引用, 引用队列)，用于解决内存泄漏问题</li>
<li>垃圾回收过后会回收软引用，前提是没用强引用引用它</li>
<li>当弱引用的对象被回收时，弱引用会进入引用队列</li>
<li>full gc 会清除所有弱引用对象</li>
</ul>
</li>
<li>虚引用<ul>
<li>也称幽灵引用，一旦创建就被回收了，所以需要队列cun’chu</li>
<li>当虚引用的对象被回收时，虚引用会进入引用队列</li>
<li>引用队列会定期查看引用队列中是否有虚引用</li>
<li>有虚引用的话会调用虚引用的clean方法调用unsafe.freeMemory()方法释放直接内存</li>
</ul>
</li>
<li>终结器引用<ul>
<li>当对象重写了终结方法finalize()并且没用强引用时，它就会被垃圾回收</li>
<li>对象没有强引用时，JVM会创建终结器引用引用该对象，并将终结器引用加入引用队列</li>
<li>finalizeHandler会定期查看引用队列中是否有终结器引用</li>
<li>有终结器引用时会调用引用对象的finalize方法</li>
</ul>
</li>
</ul>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ul>
<li>引用计数法（已过时）<ul>
<li>当对象没有被强引用所指向时在gc时就进行清除</li>
<li>有A引用B，B引用A无法清除的问题</li>
</ul>
</li>
<li>标记+清除算法<ul>
<li>标记是使用<strong>可达性分析算法</strong>（沿着根对象寻找），<strong>三色标记法</strong>标记存活对象</li>
<li>记录起始位置和结束位置，新数据直接覆盖旧数据，速度快</li>
<li>空间碎片多不连续</li>
</ul>
</li>
<li>标记+清除+整理算法（老年代）<ul>
<li>可以进行整理解决标记清除算法产生碎片的问题，</li>
<li>但移动对象会涉及地址改变，速度慢</li>
</ul>
</li>
<li>复制算法（新生代）<ul>
<li>将不回收的数据迁移到另一个相同大小的区域，然后交换这两个区域</li>
<li>效率高，不会产生内存碎片，但会占用双倍的的内存空间，浪费空间</li>
</ul>
</li>
</ul>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><ul>
<li><p>新生代</p>
<ul>
<li>伊甸园 + 幸存区from + 幸存区to</li>
<li>8：1：1</li>
<li>伊甸园满了触发 minor gc<ul>
<li>minor gc 会暂停所有线程STW</li>
<li>把存活的对象复制到幸存区to，且寿命+1</li>
<li>然后交换幸存区to和幸存区from的位置</li>
<li>当幸存区的对象寿命超过阈值（默认是15），就将其加入老年代</li>
</ul>
</li>
<li>使用的是复制算法</li>
</ul>
</li>
<li><p>老年代</p>
<ul>
<li><p>使用标记清除+整理算法</p>
</li>
<li><p>当老年代内存不足时触发minor gc，如果空间仍不足则触发full gc</p>
</li>
<li><p>触发老年代GC的时机</p>
<ul>
<li><p>老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开</p>
</li>
<li><p>老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC</p>
</li>
<li><p>新生代Minor GC后的存活对象大于Survivor，那么就会进入老年代，此时老年代内存不足full gc</p>
</li>
<li><p>就是“-XX:CMSInitiatingOccupancyFaction”参数</p>
<p>如果老年代可用内存大于历次新生代GC后进入老年代的对象平均大小，但是老年代已经使用的内存空间超过了这个参数指定的比例，也会自动触发Full GC。</p>
</li>
</ul>
</li>
<li><p>对象直接进入老年代的情况</p>
<ul>
<li>大对象直接进入老年代<ul>
<li>需要设置-XX:PretenureSizeThreshold，只在Serial和ParNew收集器下有效</li>
<li>单位是字节</li>
</ul>
</li>
<li>对象动态年龄判断<ul>
<li>当Survivor区内的对象总大小超过50%（可以设置），那么这些对象中年龄最大的都会直接进入老年代，对象动态年龄判断一般在minor gc后触发</li>
</ul>
</li>
<li>年龄15岁，cms为6岁的会进入老年代</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="CMS（Concurrent-mark-sweep"><a href="#CMS（Concurrent-mark-sweep" class="headerlink" title="CMS（Concurrent mark sweep)"></a>CMS（Concurrent mark sweep)</h4><ul>
<li>注重响应时间，但对cpu压力大</li>
<li>可以并发标记，并发清除，存在并发漏标,不会STW<ul>
<li>使用标记清除算法，有内存碎片</li>
<li><strong>三色标记法</strong>解决并发漏标，会STW</li>
</ul>
</li>
<li>有并发失败兜底策略（Failback Full GC）</li>
<li>有一些Bug<ul>
<li>依然会产生漏标</li>
<li>浮动垃圾上升老年代的Bug</li>
</ul>
</li>
</ul>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><ul>
<li>jdk1.9默认</li>
<li>注重吞吐量和响应时间<ul>
<li>超大堆内存，将堆划分为大小相等的Region<ul>
<li>每个区都可以充当（eden、survivor、old、humongous(用于存放大对象)）</li>
</ul>
</li>
<li>单区域是标记+整理算法，区域之间是复制算法</li>
<li>当新生代大小超过阈值时触发新生代回收，使用标记复制法到幸存区（跨区域）</li>
<li>当老年代占堆内存45%是触发<strong>并发标记</strong>，采用<strong>原始快照法</strong>解决漏标问题，处理漏标记录依然需要STW</li>
<li>并发标记结束后。开始<strong>混合收集</strong>，会选择回收价值高的老年代，eden，survivor，可能需要执行多次</li>
<li>并发失败兜底策略（Failback Full GC）</li>
</ul>
</li>
</ul>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><ul>
<li><p>从GC Roots对象为起点开始向下搜索引用的对象，找到的都标记为非垃圾对象，其余没找到的都标记为垃圾对象</p>
<ul>
<li>GC Roots：线程栈中的本地变量、方法区中的静态变量、本地方法栈的变量等等</li>
</ul>
</li>
<li><p>不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少<strong>要经历两次标记</strong>过程</p>
</li>
<li><p>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <strong>finalize</strong>() 方法。</p>
</li>
<li><p>当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。</p>
</li>
<li><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。</p>
</li>
<li><p>这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，因为如果一个对象在 finalize() 方法中执行缓慢，将很可能会一直阻塞 F-Queue 队列，甚至导致整个内存回收系统崩溃。</p>
</li>
<li><p>在HotSpot的实现中，是使用一组称为<code>OopMap</code>的数据结构来达到直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
</li>
<li><p>OopMap数据结构存储GCRoot对象，但是随着系统的运行会导致OopMap会逐渐变大，所以也并不会存储所有的GCRoot对象，而是在一个所谓的安全点进行记录GCRoot对象。</p>
</li>
<li><p>实际上，HotSpot的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）——即程序执行时只有在到达安全点时才能暂停。</p>
</li>
<li><p>Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
</li>
<li><p>对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。</p>
</li>
<li><p>这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</p>
<ul>
<li>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</li>
<li>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ul>
</li>
<li><p>使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要<strong>安全区域（Safe Region）</strong>来解决。</p>
</li>
<li><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
</li>
<li><p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
</li>
</ul>
<h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><ul>
<li><p>没处理的对象为白色，孩子对象未处理的为灰色，自己和孩子对象都处理了为黑色</p>
</li>
<li><p>记录标记过程中的变化，主要有两种解决方法</p>
</li>
<li><p>Incremental Update <strong>CMS解决方案</strong></p>
<ul>
<li>只要引用发生改变，被改变引用的对象需要被记录</li>
<li>通过写屏障，黑-&gt;白 时 黑变灰</li>
<li>有BUG<ul>
<li>依然会产生漏标，当黑变灰后另一个垃圾回收线程将其又变黑，白漏标<ul>
<li>CMS后续解决方案是再从头到尾扫一边，虽然有优化但效率还是低</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Snapshot At The Beginning, SATB <strong>G1解决方案</strong> （<strong>原始快照法</strong>）</p>
<ul>
<li>记录标记过程的新增对象</li>
<li>记录被删除引用关系的对象<ul>
<li>灰-&gt;白 断开了，记录白，下次排查，有黑-&gt;白不清除，反之清除</li>
<li>但是判断白是否有引用比较困难，但是G1每个分区头部有记录哪些分区引用了当前分区，Rset（记忆集）</li>
</ul>
</li>
</ul>
</li>
<li><p>最后在STW时处理这些记录</p>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>​		对象头（markword）+ 类型指针（classpointer） + 数据（data） + （数组Length） + 对齐区（padding）</p>
<ul>
<li><p>markword：</p>
<ul>
<li>32位虚拟机中占4字节，64位占8字节</li>
</ul>
<table>
<thead>
<tr>
<th align="center">结构</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hashcode:                      | age:    | biased_lock:  0 | 01</td>
<td align="center">普通状态</td>
</tr>
<tr>
<td align="center">thread:       | epoch:     | age:    | biased_lock:  1 | 01</td>
<td align="center">偏向状态</td>
</tr>
<tr>
<td align="center">ptr_to_lock_record:                                                  | 00</td>
<td align="center">轻量级锁</td>
</tr>
<tr>
<td align="center">ptr_to_heavyweight_monitor:                                | 10</td>
<td align="center">重量级锁</td>
</tr>
<tr>
<td align="center">垃圾收集器信息                                                | 11</td>
<td align="center">GC状态</td>
</tr>
</tbody></table>
</li>
<li><p>classpointer：</p>
<ul>
<li>表示这个对象属于哪个类型，正常情况下4个字节，因为经过压缩</li>
<li>当系统内存超过32g将会膨胀到8个字节</li>
</ul>
</li>
<li><p>data：存放对象数据</p>
</li>
<li><p>如果对象是数组还有一个Length，4字节</p>
</li>
<li><p>padding：如果整个对象不能给8整除，补齐，追求效率</p>
</li>
</ul>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul>
<li><p>直接指针引用</p>
<ul>
<li>变量指向堆中对象，对象中的类型指针指向方法区中类型</li>
<li>垃圾回收时变量指向要改变</li>
</ul>
</li>
<li><p>句柄</p>
<ul>
<li>变量指向一组指针，这组指针一个指向堆中对象，一个指向方法区中类型</li>
<li>好处是对象小，垃圾回收时不用频繁改动变量指向，改动的是指针组中的指向</li>
</ul>
</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>使用new关键字</li>
<li>使用Class.newInstance</li>
<li>使用Constructor.newInstance</li>
<li>使用Clone方法<ul>
<li>对象必须实现Cloneable接口，重写clone方法，调用父类的clone方法</li>
<li>在Object中这个方法是protected的，重写才能调用</li>
</ul>
</li>
<li>使用反序列化<ul>
<li>对象需要实现Serializable接口</li>
</ul>
</li>
</ul>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><ul>
<li><p>JVM 的方法调用指令有五个，分别是：</p>
<ul>
<li><p>invokestatic：调用静态方法；</p>
</li>
<li><p>invokespecial：调用实例构造器构造方法、私有方法和父类方法；</p>
</li>
<li><p>invokevirtual：调用虚方法；</p>
</li>
<li><p>invokeinterface：调用接口方法，运行时确定具体实现；</p>
</li>
<li><p>invokedynamic：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。</p>
</li>
</ul>
</li>
<li><p>其中，invokestatic 和 invokespecial 用于静态绑定，invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法和接口方法。</p>
</li>
<li><p>静态绑定在编译期就已经确定，这是因为静态方法、构造器方法、私有方法和父类方法可以唯一确定。这些方法的符号引用在类加载的解析阶段就会解析成直接引用。因此这些方法也被称为非虚方法，与之相对的便是虚方法。</p>
</li>
<li><p>虚方法的方法调用与方法实现的关联（也就是分派）有两种，一种是在编译期确定，被称为静态分派，比如方法的重载；一种是在运行时确定，被称为动态分派，比如方法的覆盖。对象方法基本上都是虚方法。</p>
</li>
<li><p>这里需要特别说明的是，final 方法由于不能被覆盖，可以唯一确定，因此 Java 语言规范规定 final 方法属于非虚方法，但仍然使用 invokevirtual 指令调用。</p>
</li>
<li><p>静态绑定、动态绑定的概念和虚方法、非虚方法的概念是两个不同的概念。</p>
</li>
<li><p>以 invokevirtual 指令为例，在执行时，大致可以分为以下几步：</p>
<ol>
<li>先从操作栈中找到对象的实际类型 class</li>
<li>找到 class 中与被调用方法签名相同的方法，如果有访问权限就返回这个方法的直接引用，如果没有访问权限就报错 java.lang.IllegalAccessError </li>
<li>如果第 2 步找不到相符的方法，就去搜索 class 的父类，按照继承关系自下而上依次执行第 2 步的操作；</li>
<li>如果第 3 步找不到相符的方法，就报错 java.lang.AbstractMethodError</li>
</ol>
<p>可以看到，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p>
</li>
<li><p>商用虚拟机为了保证性能，通常会使用虚方法表和接口方法表，而不是每次都去判断。以虚方法表为例，虚方法表在类加载的解析阶段填充完成，其中存储了所有方法的直接引用。也就是说，动态分派在填充虚方法表的时候就已经完成了。</p>
</li>
<li><p>在子类的虚方法表中，如果子类覆盖了父类的某个方法，则这个方法的直接引用指向子类的实现；而子类没有覆盖的那些方法，比如 Object 的方法，直接引用指向父类或 Object 的实现。</p>
</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li><p>分配回收成本较高，但读写性能高，不受JVM内存回收管理</p>
</li>
<li><p>NIO中的 ByteBuffer对象.allocateDirect(1024) 可以申请直接内存</p>
<ul>
<li>这个对象创建时是调用的Unsafe对象的allocateMemory()和setMemory() 方法完成直接内存的分配</li>
<li>当这个ByteBuffer对象被回收时，然后会由ReferenHandler线程通过虚引用类型 Cleaner.clean 方法调用unsafe.freeMemory()方法来回收直接内存</li>
</ul>
</li>
<li><p>推荐使用unsafe对象手动的管理直接内存</p>
</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ul>
<li>JVM将执行状态分成了5个层次<ul>
<li>0层：解释执行</li>
<li>1层：使用c1即时编译器执行，不带profiling</li>
<li>2层：使用c1即时编译器执行，带基本的profiling</li>
<li>3层：使用c1即时编译器执行，带完全的profiling</li>
<li>4层：使用c2即时编译器执行</li>
</ul>
</li>
<li>profiling是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数</li>
<li>对于不常用的代码，采取解释执行，对于热点代码，采取编译执行</li>
</ul>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><ul>
<li>如果被调用的方法是热点方法，且其内部代码不长时，会进行内联</li>
<li>所谓的内联就是把调用的方法内部的代码拷贝至调用者的位置上，还会进行常量折叠</li>
</ul>
<h3 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h3><ul>
<li>尽量使用局部变量，而不使用成员变量和静态成员变量</li>
</ul>
<h3 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h3><ul>
<li>当通过反射调用方法超过膨胀阈值时，会转换成类调用</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/JVM/" data-id="clrj8k01l006y4wuw6woi4bgx" data-title="JVM虚拟机" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/基础/Maven" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Maven/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.684Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Maven/">Maven</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mvn clean</td>
<td></td>
<td>清除target</td>
</tr>
<tr>
<td>mvn compile</td>
<td></td>
<td>编译</td>
</tr>
<tr>
<td>mvn test</td>
<td></td>
<td>单元测试</td>
</tr>
<tr>
<td>mvn package</td>
<td></td>
<td>打包</td>
</tr>
<tr>
<td>mvn install</td>
<td></td>
<td>打包到本地仓库</td>
</tr>
<tr>
<td>mvn deploy</td>
<td></td>
<td>打包到远程仓库</td>
</tr>
</tbody></table>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>dependencyManagement</strong></p>
<ul>
<li>只是声明依赖，并不引入，子类需要声明引用</li>
</ul>
<p><strong>scope</strong></p>
<ul>
<li>provided 目标环境已存在，不用打包</li>
</ul>
<p><strong>properties</strong></p>
<ul>
<li>版本管理</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Maven/" data-id="clrj8k01m00754wuwcxhw7w21" data-title="Maven" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/基础/JUC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/JUC/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.683Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/JUC/">JUC并发编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h3><ul>
<li>解决<strong>可见性</strong>问题：因为CPU和内存间存在缓存，存在主从不一致的情况</li>
<li>解决<strong>有序性</strong>问题：因为编译程序执行指令时为了提高缓存使用效率，会调整指令的执行次序</li>
<li>解决<strong>原子性</strong>问题：因为有多线程、多进程、分数复用CPU，导致存在资源共享的问题</li>
</ul>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><ul>
<li>多个线程访问同一个共享变量就会出现线程安全问题</li>
<li>private 和 final可以一定程度上提供线程安全</li>
<li>线程安全的方法组合起来就不能保证线程安全了</li>
<li>在多线程的情况下满足JMM规范就可以避免线程安全问题</li>
<li>线程安全程度<ul>
<li>不可变<ul>
<li>final、枚举、Number部分子类（Long、Double、BigInteger、BigDecimal）、使用<code>Collections.unmodifiableXXX()</code> 包装的集合</li>
<li>不可变类：DateFormatter、String</li>
</ul>
</li>
<li>绝对线程安全<ul>
<li>调用者都不需要任何额外的同步措施</li>
</ul>
</li>
<li>相对线程安全<ul>
<li>有一定的安全，但有意外的情况，例如顺序的连续调用</li>
<li>通过一些同步方法来保证安全</li>
</ul>
</li>
<li>线程兼容<ul>
<li>对象本身不安全，需要通过一些同步方法来保证安全</li>
</ul>
</li>
<li>线程对立<ul>
<li>即使使用了同步方法也无法保证线程安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul>
<li>多线程读写同一个共享资源，这个共享资源就称为临界区</li>
</ul>
<h3 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h3><ul>
<li>多个线程同时在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件</li>
</ul>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ul>
<li>继承Thread<ul>
<li>代价比较大，不建议</li>
<li>内部实现了Runnable接口</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>本质上并不是创建线程，实际执行还是需要通过线程调用</li>
</ul>
</li>
<li>实现Callable接口<ul>
<li>本质上并不是创建线程，实际执行还是需要通过线程调用</li>
<li>可以有返回值（FutureTask），需要实现call方法</li>
<li>内部是FutureTask实现了RunnableFutrue接口，这个接口继承了Runnable和Future接口</li>
<li>内部实现也是执行的run方法，在方法中创建了Callable对象并执行call方法，将结果值返回</li>
</ul>
</li>
<li>线程池创建<ul>
<li>合理利用线程资源，减少频繁创建销毁的开销</li>
<li>内部创建的worker线程也是实现了Runnable接口</li>
</ul>
</li>
</ul>
<h3 id="守护线程和非守护线程"><a href="#守护线程和非守护线程" class="headerlink" title="守护线程和非守护线程"></a>守护线程和非守护线程</h3><ul>
<li>守护线程就像是守护其他线程一样，其他的完成了他也就结束了</li>
<li>非守护线程都运行结束了，即使守护线程还没结束也会直接结束</li>
<li>main主线程是一个非守护线程</li>
<li>setDaemon(true) 将线程设置为守护线程<ul>
<li>垃圾回收器（gc）就是一个守护线程</li>
<li>Tomcat中的 Acceptor 和 Poller 线程也是守护线程</li>
</ul>
</li>
</ul>
<h3 id="Java的线程和操作系统的线程有区别吗？"><a href="#Java的线程和操作系统的线程有区别吗？" class="headerlink" title="Java的线程和操作系统的线程有区别吗？"></a>Java的线程和操作系统的线程有区别吗？</h3><ul>
<li>java线程分为守护线程和用户线程</li>
<li>在window上线程是一样的，在Unix上采用Pthread实现</li>
<li>jdk1.2之前是jvm自己有一套线程管理机制，即和操作系统上的不一样</li>
<li>jdk1.2之后采用了操作系统原生的内核级线程，将线程的调度交给了操作系统内核</li>
<li>总的来说，java的线程就是操作系统的线程，Java线程与操作系统线程一对一映射，依赖于操作系统的具体实现</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>sleep()</p>
<ul>
<li>Thread提供的方法，不会释放锁</li>
<li>使当前线程进入阻塞状态，可通过interrupt()打断</li>
<li>睡眠结束后线程未必会立刻得到执行，等cpu轮转</li>
</ul>
<p>wait &#x2F; notify</p>
<ul>
<li><p>object的方法，必须与synchronized一起使用，会释放锁</p>
<ul>
<li>在多个线程之间通信需要保证线程间对共享变量的修改是可见的</li>
<li>synchronized就可以保证可见性</li>
</ul>
</li>
<li><p>实现多线程之间的通信</p>
</li>
<li><p>调用 wait() 方法让当前线程进入waitSet中等待</p>
</li>
<li><p>通过 notify() &#x2F; notifyAll() 唤醒等待中的线程</p>
</li>
<li><p>防止虚假唤醒</p>
</li>
</ul>
<p>&#x3D;&#x3D;yield&#x3D;&#x3D;</p>
<ul>
<li>调度执行其它同优先级的线程<ul>
<li>如果有，当前线程挂起等待相应的线程执行结束</li>
<li>如果没有，则继续运行当前线程</li>
</ul>
</li>
</ul>
<p>interrupt</p>
<ul>
<li>interrupt()设置打断标记为true<ul>
<li>睡眠中的线程被打断不会将标记设置为true</li>
</ul>
</li>
<li>isInterrupted() 判断线程是否被打断 不会清除标记</li>
<li>interrupted() 判断线程是否被打断 会清除标记 即设置为false</li>
</ul>
<p>&#x3D;&#x3D;Join&#x3D;&#x3D;</p>
<ul>
<li>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，直到目标线程结束</li>
</ul>
<p>Park</p>
<ul>
<li>让当前线程停下来</li>
<li>如果打断标记为false则停止线程 ，如果打断标记为true则不会停止线程<ul>
<li>即只能打断一次</li>
</ul>
</li>
</ul>
<p>优先级设置</p>
<ul>
<li>setPriority() 为线程设置新的优先级。默认是5</li>
<li>getPriority() 返回线程的当前优先级</li>
</ul>
<p>Fork &#x2F; join</p>
<ul>
<li><p>体现的是一种分治思想，把递归交给线程做</p>
</li>
<li><p>默认会创建与cpu核心数数量相同的线程池</p>
</li>
<li><p>需要继承RecursiveTask&lt;V&gt;（有返回结果）或RecursiveAction（无返回结果）</p>
<ul>
<li>覆盖重写compute()方法，实现任务拆分</li>
</ul>
</li>
<li><p>创建ForkJoinPoll线程池，执行RecursiveTask实现类对象</p>
</li>
</ul>
<h2 id="生命周期-运行状态"><a href="#生命周期-运行状态" class="headerlink" title="生命周期 &#x2F; 运行状态"></a>生命周期 &#x2F; 运行状态</h2><p>cpu层面</p>
<ul>
<li>创建：create</li>
<li>就绪：Runnable </li>
<li>运行：run</li>
<li>等待：wait</li>
<li>终结：Terminated</li>
</ul>
<p>java层面，在Thread类中有一个枚举类，规定了java线程的六种生命周期</p>
<ul>
<li>新建 - New</li>
<li>运行 &amp; 就绪 -Runnable </li>
<li>阻塞 - Blocker（Waiting、Time_Wating）</li>
<li>销毁 - Terminated</li>
</ul>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><ul>
<li>是Java提供的同步关键字，可以修饰在方法和类上，可以以代码块形式使用</li>
<li>可以通过锁的对象来控制锁的作用范围<ul>
<li>锁静态对象或类对象，那么就是一个全局锁</li>
<li>锁普通实例对象，那就是取决于对象的生命周期</li>
</ul>
</li>
</ul>
<h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><p>轻量级锁</p>
<ul>
<li>锁对象虽然是多线程访问的，但是线程间不存在竞争，此时Synchronized会优化为一个轻量级锁</li>
</ul>
<p>偏向锁</p>
<ul>
<li><p>在轻量级锁的情况下，线程每次访问锁对象时都需要进行CAS操作，增加了开销</p>
</li>
<li><p>java6时引入了偏向锁来优化，在cas前会判断线程id和锁对象的对象头中的线程id是否一致，一致直接通过</p>
</li>
<li><p>偏向锁默认是开启的，但是默认也是延迟的，即看不出实际的效果</p>
<ul>
<li>可以设置 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟</li>
<li><code>-XX:-UseBiasedLocking</code> 关闭偏向锁</li>
</ul>
</li>
<li><p>偏向锁关闭的情况</p>
<ul>
<li>锁升级</li>
<li>对象调用了hashcode</li>
<li>调用wait&#x2F;notify</li>
</ul>
</li>
<li><p>当撤销偏向锁的次数超过了阈值，整个类的所有对象都会变为不可偏向</p>
</li>
</ul>
<p>重量级锁（Monitor锁 &#x2F; 管程锁）</p>
<ul>
<li>结构<ul>
<li>WaitSet：</li>
<li>EntryList：阻塞队列</li>
<li>Owner：持有的线程</li>
</ul>
</li>
<li>加锁流程<ol>
<li>当线程获取重量级锁时，Owner指向当前线程</li>
<li>其他线程获取锁时会会先进行自旋获取锁，失败一定次数后进入EntryList等待<ul>
<li>jdk 1.6 后自旋是自适应的，会根据之前线程的平均自旋次数自动调整自旋的次数</li>
</ul>
</li>
<li>线程释放锁后，唤醒EntryList中等待的线程来竞争锁，是非公平的</li>
</ol>
</li>
</ul>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>锁膨胀</p>
<ul>
<li>循环的粒度太小导致频繁的加锁释放锁，JIT即时编译器会将锁的粒度变大来优化</li>
</ul>
<p>自旋优化</p>
<ul>
<li>重量级锁竞争时会先通过自旋尝试获取锁，没获取到再进入阻塞队列</li>
<li>有一定的次数，也有自适应的自旋</li>
</ul>
<p>锁粗化</p>
<ul>
<li>多个细粒度的加锁流程会被优化为一个大粒度的锁，减少频繁的加锁释放锁</li>
</ul>
<p>锁消除</p>
<ul>
<li>JIT即时编译器判断锁对象不会被共享时会消除锁</li>
</ul>
<h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><ul>
<li>可以保证在多线程环境下共享变量的可见性<ul>
<li>对于增加了 volatile 关键字修饰的共享变量，JVM会自动增加一个#Lock汇编指令，这个指令会根据CPU 型号自动添加<strong>总线锁</strong>或<strong>缓存锁</strong></li>
</ul>
</li>
<li>通过增加内存屏障防止多个指令之间的重排序<ul>
<li>因为CPU引入了 StoreBuffer机制，而这一种优化机制会导致 CPU 的乱序执行，Volatile通过内存屏障来避免CPU重排序</li>
<li>跳过编译器的指令重排序</li>
</ul>
</li>
</ul>
<h2 id="JUC工具包"><a href="#JUC工具包" class="headerlink" title="JUC工具包"></a>JUC工具包</h2><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><ul>
<li>AtomicBoolean、AtomicInteger、AtomicLong<ul>
<li>底层使用的Unsafe提供的Cas实现线程安全的计算</li>
</ul>
</li>
<li>AtomicReference、AtomicMarkableReference、AtomicStampedReference、AtomicIntegerArray</li>
<li>…FieldUpdater</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><ul>
<li><p>全称是AbstractQueuedSynchronizer，是一个多线程同步器和阻塞式锁的框架，很多JUC组件的底层都是由它实现的，如Lock、CountDownLatch、Semaphore等</p>
</li>
<li><p>本质上来说，AQS提供两种锁的机制，分别是排他锁和共享锁，用state属性来表示资源的状态</p>
</li>
<li><p>提供了一个volatile修饰的int类型的state</p>
<ul>
<li>锁记录线程是否持有</li>
<li>Semaphore记录有多少资源</li>
<li>CountDownLatch中作为计数器</li>
</ul>
</li>
<li><p>提供了基于FIFO的等待队列（双向链表），类似于Monitor的EntryList</p>
</li>
<li><p>提供条件变量ConditionObject来实现等待队列，也是一个双向链表，</p>
<ul>
<li>唤醒机制，调用了await的线程会在这个队列中等待唤醒</li>
<li>支持多个条件变量。类似于Monitor的WaitSet</li>
</ul>
</li>
</ul>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul>
<li><p>锁的粒度由lock和unlock之间包裹的代码范围决定，作用域则取决于lock实例的生命周期</p>
</li>
<li><p>基于AQS，内部有一个sync抽象静态内部类，它有两个实现类</p>
</li>
<li><p>支持公平锁和非公平锁，默认非公平</p>
<ul>
<li>NonfairSync 非公平同步器</li>
<li>FailSync 公平同步器<ol>
<li>自旋获取锁，会判断在自己之前是否有线程</li>
<li>加入队列执行 addWaiter方法和 acquireQueued方法</li>
</ol>
</li>
</ul>
</li>
<li><p>可重入、可打断、支持锁超时、多条件变量，支持非竞争获取锁</p>
</li>
<li><p>锁的竞争是使用 CAS 机制来实现的</p>
</li>
</ul>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><ul>
<li><p>基于AQS实现的，将state拆成了两部分</p>
<ul>
<li>写锁占state的低16位，读锁是state高16位</li>
<li>使用了ThreadLocal解决多线程读时无法判断线程的重入次数<ul>
<li>ThreadLocal记录了线程重入次数</li>
</ul>
</li>
</ul>
</li>
<li><p>读读不加锁，类似数据库意向共享锁</p>
</li>
<li><p>内部分别使用读锁保护数据的read方法，写锁保护write方法</p>
</li>
<li><p>读锁不支持条件变量</p>
</li>
<li><p>持有读锁时去获取写锁，会导致获取写锁永久等待</p>
</li>
<li><p>读写锁用的是同一个Sycn同步器，所以等待队列，state也是同一个</p>
</li>
<li><p>有写锁饥饿问题</p>
<ul>
<li>当有大量读操作持有锁时会导致写锁等待</li>
<li>新的读操作需要排到写操作之后执行才能避免写锁饥饿<ul>
<li>即每个读锁获取锁资源前先判断是否有等待的写锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul>
<li><p>是一种线程隔离机制，它提供了多线程环境下对于共享变量访问的安全性</p>
</li>
<li><p>ThreadLocal本身不存储数据，像是一个工具类，去操作Thread中的ThreadLocalMap</p>
</li>
<li><p>ThreadLocalMap是ThreadLocal的一个内部类</p>
<ul>
<li>ThreadLocalMap是基于Entry数组实现的</li>
<li>key是ThreadLocal对象本身，value就是要存的数据</li>
</ul>
</li>
<li><p>真正存数据的地方是Thread中的成员遍历ThreadLocalMap</p>
</li>
<li><p>Thread的key是弱引用，在GC时会被清除，因为存在内存泄露的风险</p>
<ul>
<li>如果想用强引用类型的可以使用ThreadLocal的子类InheritableThreadLocal</li>
<li>get时遇到key为null值，会将其value置为null</li>
<li>set时遇到key为null值，会替换key-value，还会删除改位置一定范围内的key为null的键值，范围和map中的元素个数有关</li>
</ul>
</li>
<li><p>推荐使用后用remove删除元素，因为value是会出现内存泄漏的问题的</p>
</li>
<li><p>推荐设置ThreadLocal对象为static final 的，这样Gc就不会删除了，避免了内存泄漏</p>
</li>
<li><p>每个ThreadLocal会对每一个线程创建一个ThreadLocalMap，第一次使用才会创建</p>
<ul>
<li>key是ThreadLocal实例，value是数据</li>
<li>初始容量是16，扩容2倍，负载因子是2&#x2F;3, 大于等于阈值时扩容</li>
</ul>
</li>
<li><p>开放寻址法解决hash冲突</p>
<ul>
<li>插入位置有数据时，接着遍历找没数据的位置后插入</li>
</ul>
</li>
<li><p>存在ABA问题，可以通过版本号解决</p>
</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul>
<li><p>本质上还是HashMap，只是做了并发安全的处理</p>
</li>
<li><p>扩容时采用了多线程并发扩容的机制，也是通过创建新的数组然后数据qian’yi</p>
</li>
<li><p>提供的方法是保证线程安全的，但是多个方法同时使用不是线程安全的</p>
</li>
<li><p>结构</p>
<ul>
<li><p>1.7：segment段+HashEntry数组+链表</p>
</li>
<li><p>1.8：数组+链表 &#x2F; 红黑树</p>
</li>
</ul>
</li>
</ul>
<h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><ul>
<li>原子累加器，用一个原子整型模拟锁</li>
<li>用了@Contended解决了伪共享的问题</li>
</ul>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><ul>
<li>相当于wait&#x2F;notify</li>
</ul>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><ul>
<li>jdk8加入的，用于优化读性能，使用读写锁时配合使用</li>
<li>支持乐观读，读取完毕后做一次戳校验，通过则表示这期间没有写操作，数据可以安全使用，如果没通过需要重新读取数据</li>
<li>不支持条件变量、不可重入</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>信号量，用于限制访问共享资源线程的上限，限流</li>
</ul>
<h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><ul>
<li>用来进行线程同步协作，内部维护一个计数器，线程完成计算减一</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><ul>
<li>用来进行线程同步协作，内部维护一个计数器，等待线程满足某个计数，即可调用wait进行等待，再等待满足某个计数再继续执行</li>
<li>计数要和线程数一致</li>
</ul>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><ul>
<li>1.8 引入的一个基于事件驱动的异步回调类</li>
<li>使用异步线程去执行一个任务的时候，在任务结束以后触发一个后续的动作</li>
<li>提供了 5 种不同的方式<ol>
<li>thenCombine：把两个任务组合在一起，当两个任务都执行结束后触发事件回调</li>
<li>thenCompose：把两个任务组合在一起，这两个任务串行执行，也就是第一个任务执行完以后自动触发执行第二个任务</li>
<li>thenAccept：</li>
</ol>
</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>是一种资源复用的思想，目的是减小线程频繁创建和销毁带来的开销，因为线程创建会涉及到cpu的上下文切换，内存分配等工作</li>
<li>仅适合短链接的场景，使用时推荐手动创建ThreadPool对象而不是shi’yong</li>
<li>核心参数<ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：救急线程的空闲时间</li>
<li>unit：时间单位</li>
<li>workQueue：阻塞队列<ul>
<li>默认是LinkedBlockingQueue</li>
</ul>
</li>
<li>threadFactory：线程工厂<ul>
<li>设置线程的信息，起名，设置守护线程、优先级等等</li>
<li>当任务没有核心线程去执行时会加入阻塞队列，队列满了会创建救急线程</li>
</ul>
</li>
<li>handler：拒绝策略<ul>
<li>AbortPolicy：抛出异常，默认</li>
<li>CallerRunsPolicy：主线程帮忙处理任务</li>
<li>DiscardOldestPolicy：抛弃等待队列头节点任务，即最早的任务</li>
<li>DiscardPolicy：抛弃当前任务</li>
</ul>
</li>
</ul>
</li>
<li>处理机制<ul>
<li>当有新的任务进来时<ul>
<li>如果核心线程数没满，即使有空闲的核心线程也会创建新的核心线程来处理任务</li>
<li>如果核心线程满了，就把任务加入等待队列</li>
<li>如果队列满了，创建救急线程处理队列中的任务</li>
<li>如果最大线程数和等待队列都满了，则根据拒绝策略处理任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ul>
<li>newFixedThreadPool<ul>
<li>固定的线程池</li>
<li>都是工作线程</li>
</ul>
</li>
<li>newSingleThreadExecutor<ul>
<li>单例线程池，只有一个工作线程</li>
<li>顺序消费</li>
</ul>
</li>
<li>newCachedThreadPool<ul>
<li>没有工作线程，任务进来后丢进阻塞队列，然后创建救急线程去执行</li>
<li>频繁的创建和销毁线程，性能不好</li>
</ul>
</li>
<li>newScheduleThreadPool<ul>
<li>定时任务的线程池</li>
<li>阻塞队列是DelayWorkQueue，底层是堆</li>
</ul>
</li>
<li>newWorkStealingPool<ul>
<li>基于ForkJoinPool实现的</li>
<li>每个线程都有一个阻塞队列，当线程对应的阻塞队列为空时，会去访问其他线程的阻塞队列并取出任务执行</li>
<li>会将任务进行拆分，然后并行处理，并将所有返回的结果合并</li>
</ul>
</li>
</ul>
<h3 id="属性-状态"><a href="#属性-状态" class="headerlink" title="属性 &#x2F; 状态"></a>属性 &#x2F; 状态</h3><ul>
<li>crl<ul>
<li>原子整形</li>
<li>32位，高三位是线程池的状态，低29位是线程池的数量</li>
<li>状态<ul>
<li>111 &#x3D; -1：Running，正常处理任务，刚构建出来时的状态</li>
<li>000 &#x3D; 0：Shutdown，不接收新任务，会处理完所有的任务<ul>
<li>shutdownNow方法会直接进入stop状态</li>
</ul>
</li>
<li>001 &#x3D; 1：stop，不接收新任务，所有的任务中断<ul>
<li>本质上是执行interrupt方法</li>
</ul>
</li>
<li>010 &#x3D; 2：Tidying，过度阶段</li>
<li>011 &#x3D; 3：Terminated，关闭线程池<ul>
<li>可以实现该方法，实现一些关闭前的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/JUC/" data-id="clrj8k01l006u4wuw30p4clsl" data-title="JUC并发编程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/基础/Java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Java/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.683Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Java/">JavaSE</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="面向对象语言"><a href="#面向对象语言" class="headerlink" title="面向对象语言"></a>面向对象语言</h3><ul>
<li><p>封装</p>
<ul>
<li>将数据和操作封装为一个不可分割的整体</li>
<li>隐藏内部的实现细节，对外暴露安全的访问方法</li>
<li>提高了安全性和复用性，减少耦合</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>从已有对象中派生出一个类，这个类具有父类的属性和方法</li>
<li>private方法不会被继承</li>
<li>提高了复用性，增加了耦合性</li>
</ul>
</li>
<li><p>多态</p>
<ul>
<li><p>条件：继承，子类对象指针指向父类、满足里氏替换原则</p>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：提高代码的可扩展性</li>
<li>缺点：无法使用子类特有方法</li>
</ul>
</li>
<li><p>分为编译时多态和运行时多态</p>
<ul>
<li>编译时多态：方法的重载</li>
<li>运行时多态：程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="rt-jar、dt-jar、tools-jar"><a href="#rt-jar、dt-jar、tools-jar" class="headerlink" title="rt.jar、dt.jar、tools.jar"></a>rt.jar、dt.jar、tools.jar</h3><ul>
<li>rt.jar<ul>
<li>代表runtime JAR，包含Core Java API的所有类，包含所有核心Java 运行环境的已编译calss文件</li>
<li>位于JRE的lib目录下，包含了JVM信任的class文件，JVM加载时不会对其他class文件进行严格的安全检查</li>
<li>是一个类似zip的压缩文件，精确称为 Java archive（Jar），存储了Java class文件和程序所需的全部资源。它还可以包含&#x3D;&#x3D;mainfest&#x3D;&#x3D;文件，还可以包含&#x3D;&#x3D;Main-Class条目&#x3D;&#x3D;，变成可执行JAR</li>
</ul>
</li>
<li>dt.jar<ul>
<li>是系统用来编译一个类的时候用到的，即执行javac的时候用到。</li>
</ul>
</li>
<li>tools.jar<ul>
<li>dt.jar是关于运行环境的类库，主要是swing包。</li>
</ul>
</li>
</ul>
<h3 id="Fail-Fast和Fail-Safe"><a href="#Fail-Fast和Fail-Safe" class="headerlink" title="Fail-Fast和Fail-Safe"></a>Fail-Fast和Fail-Safe</h3><ul>
<li>Fail-Fast：一旦发现遍历时有修改，则立刻抛异常，例如ArrayList，vector<ul>
<li>ArrayList内部的modCount记录了修改次数，当遍历时会获取modCount</li>
<li>遍历过程会比较当前modCount和获取时的值，不一致抛异常</li>
</ul>
</li>
<li>Fail-Safe：遍历的同时有修改，会有相应的策略，例如CopyOnWriteArrayList</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><ul>
<li>修饰的字段不参与序列化，只能修饰变量</li>
<li>当这个变量可以通过其他变量来获得时就可以不参加序列化，即添加transient修饰<ul>
<li>例如：三角形的长，宽，面积，则面积可以不参与序列化</li>
<li>Logger对象也不需要</li>
</ul>
</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>修饰的静态变量是不参与序列化的</li>
</ul>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul>
<li>修饰的变量不会被cpu所缓存</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try &#x2F; catch &#x2F; finally"></a>try &#x2F; catch &#x2F; finally</h4><h4 id="throw-throws"><a href="#throw-throws" class="headerlink" title="throw &#x2F; throws"></a>throw &#x2F; throws</h4><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th></th>
<th>长度 &#x2F; 字节数</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int</td>
<td></td>
<td>4字节</td>
</tr>
<tr>
<td>long</td>
<td></td>
<td>8字节</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>4字节</td>
</tr>
<tr>
<td>double</td>
<td></td>
<td>8字节</td>
</tr>
<tr>
<td>decimal</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul>
<li>String<ul>
<li>使用双引号创建字符串和使用new创建字符串是不一样的</li>
</ul>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>自底向上的抽象，将共性方法抽取出来作为父类</li>
<li>有抽象方法的类是抽象类，但抽象类也可以有其他普通方法</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p>自顶向下，对行为的规范，体现了模板设计思想</p>
</li>
<li><p>1.8之前只能有抽象方法，1.8之后可以有默认方法、静态方法</p>
<ul>
<li>静态方法只能被接口调用</li>
<li>默认方法，作用是实现接口演化，为老接口扩展新功能，并且其实现类不用重新实现该新方法从，但是所有实现类都会默认携带这个新方法，有一点违背接口隔离原则</li>
</ul>
</li>
<li><p>只能有static final 修饰的成员变量</p>
</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="hashcode-equals"><a href="#hashcode-equals" class="headerlink" title="hashcode() &#x2F; equals()"></a>hashcode() &#x2F; equals()</h4><ul>
<li>在集合中存储自定义对象类型最好重写这两个方法</li>
<li>重写hashcode()是为了对象的key在整个hashmap中有更好的分布，提高查询性能</li>
<li>重写equals()是为了防止两个对象的hash值一样，通过比较值来区分</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul>
<li>可以在运行期间获取类的各种信息，常用于一些动态修改属性值的操作</li>
<li>如果对象为private等类型，可使用setAccessible(true)暴力获取</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul>
<li>@Target：描述注解能够作用的位置</li>
<li>@Retention：描述注解被保留的阶段</li>
<li>@Documented：描述注解是否被抽取到api文档</li>
<li>@Inherited：描述注解是否被子类继承</li>
</ul>
<h4 id="预定义注解"><a href="#预定义注解" class="headerlink" title="预定义注解"></a>预定义注解</h4><ul>
<li><p>@Override：检测方法是否覆盖重写父类方法</p>
</li>
<li><p>@Deprecated：标注的内容表示已过时</p>
</li>
<li><p>@suppressWarnings：压制警告</p>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ol>
<li>本质上就是一个接口，可定义方法，需要有返回值</li>
<li>创建一个。。。。实现功能</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://pdai.tech/images/java/java-basic-exception-1.png" alt="img"></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>Throwable<ul>
<li>包含了线程创建时线程执行堆栈的快照，提供了printStackTrace()等接口用于获取堆栈信息</li>
</ul>
</li>
<li>Error<ul>
<li>是程序无法处理的异常，例如虚拟机运行错误、堆栈溢出等等</li>
<li>无法检测的异常</li>
</ul>
</li>
<li>Exception<ul>
<li>程序可以捕获且处理的异常</li>
<li>分为运行时异常和编译时异常<ul>
<li>运行时异常：RuntimeException类及其子类</li>
<li>编译时异常：需要处理才能编译通过的异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul>
<li>需要继承RuntimeException</li>
<li>定义错误码和错误消息，还有各种参数的构造函数，包含异常信息，在抛异常的时候传入</li>
</ul>
<h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><ul>
<li>使用try&#x2F;catch手动捕获<ul>
<li>自己对异常进行处理</li>
</ul>
</li>
<li>直接抛出方法外，让调用方对异常进行处理</li>
<li>使用异常拦截器拦截统一处理（推荐）</li>
</ul>
<h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><ul>
<li>底层是通过异常表Exception Table</li>
<li>异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下<ul>
<li><strong>from</strong> 可能发生异常的起始点</li>
<li><strong>to</strong> 可能发生异常的结束点</li>
<li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li>
<li><strong>type</strong> 异常处理者处理的异常的类信息</li>
</ul>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li>可以在定义类或方法时不传入特定类型的对象或参数，更具通用性</li>
<li>可以控制类的上限和下限</li>
<li>静态方法和异常中不能使用类的泛型</li>
<li>如果没有指定泛型的类型，默认是Object</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li>常用于集中管理相同类型的信息，避免硬编码于代码中</li>
</ul>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>就是将对象转换成字节序列，实现持久化和网络传输</li>
<li>方式<ul>
<li>实现Serializable接口</li>
<li>实现Externalizable接口<ul>
<li>实现writeExternal()</li>
<li>实现readExternal()</li>
</ul>
</li>
</ul>
</li>
<li>transient可以防止属性序列化，因为序列化可能会破坏单例</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li>有序，可重复，可null</li>
<li>底层是数组，增加、删除、扩容都是通过数组的复制</li>
<li>可以利用CPU缓存，&#x3D;&#x3D;局部性原理&#x3D;&#x3D;</li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>占用内存多，可null</li>
<li>底层是一个双向链表</li>
<li>内部维护了First和last节点，所以对首尾的操作方便</li>
<li>&#x3D;&#x3D;在遍历时会判断从前往后较快还是从后往前较快&#x3D;&#x3D;</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li>线程安全，速度慢，早期使用Elements遍历<ul>
<li>Enumeration接口是迭代器前身</li>
</ul>
</li>
</ul>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><ul>
<li>底层实现采用写入时拷贝的思想，增删改会将数组拷贝一份，在拷贝的数据上更改，不影响其他线程的并发读，读写分离</li>
</ul>
<h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><ul>
<li>用作栈或队列</li>
<li>初始容量8，扩容两倍</li>
<li>底层是循环数组，维护了 head 和 tail，非线程安全，不可存null值</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><ul>
<li>优先级队列，不可null</li>
<li>能保证每次取出的元素都是队列中权值最小的</li>
<li>底层是小顶堆结构，用数组实现，是按层序遍历树排列</li>
<li>初始容量11，扩容通过数组的复制，最大长度是数组的最大值</li>
</ul>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><ul>
<li><p>获取队列元素时队列为空会阻塞等待至队列不为空时，存储元素时队列满了会阻塞至队列直到队列可用</p>
</li>
<li><p>可以很好的实现生产者消费者模型</p>
</li>
<li><p>ArrayBlockingQueue</p>
<ul>
<li>有界阻塞队列，</li>
<li>基于循环数组实现，需要提前初始化数组</li>
<li>内部维护一把锁，ReentrantLock 和 Condition</li>
</ul>
</li>
<li><p>LinkedBlockingQueue</p>
<ul>
<li>无界阻塞队列</li>
<li>内部使用了两把锁，分别锁头尾指针，允许两个线程同时执行</li>
<li>保证了头尾节点的线程安全</li>
</ul>
</li>
</ul>
<h4 id="LinkedQueue"><a href="#LinkedQueue" class="headerlink" title="LinkedQueue"></a>LinkedQueue</h4><p>ConcurrentLinkedQueue</p>
<ul>
<li>内部维护两把CAS锁，允许两个线程同时执行</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul>
<li>非线程安全，不重复，无序，底层hash表</li>
<li>对HashMap进行了一个封装，内部都是调用的hashmap的方法，适配器模式<ul>
<li>key存值，value存的是常量</li>
</ul>
</li>
</ul>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul>
<li>有序，不重复</li>
<li>底层哈希表</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li>无序，可null，数组是懒惰创建的</li>
<li>底层<ul>
<li>1.7：数组+链表</li>
<li>1.8：数组+链表 or 红黑树</li>
</ul>
</li>
<li>默认16，扩容2倍，数组复制<ul>
<li>1.7：<ul>
<li>大于等于阈值且插入时的位置不为空时扩容</li>
</ul>
</li>
<li>1.8：<ul>
<li>大于阈值就扩容，不改变原链表或红黑树的顺序</li>
</ul>
</li>
</ul>
</li>
<li>put元素时<ul>
<li><p>1.7</p>
<ul>
<li>插入后超过阈值则扩容</li>
<li>将key和value封装为entry对象</li>
<li>头插法插入到当前节点下链表的头部（扩容死链出现的原因）</li>
</ul>
</li>
<li><p>1.8</p>
<ul>
<li>插入前超过阈值或链表长度大于8时则扩容</li>
<li>判断当前位置下是链表还是红黑树<ul>
<li>链表：将entry尾插，节点数大于8转换为红黑树</li>
<li>红黑树：将node插入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常见问题<ul>
<li><p>HashMap用红黑树？为什么不用AVL树 </p>
<ul>
<li><p>用树结构主要是用来避免DoS攻击，防止链表超长时性能下降</p>
</li>
<li><p>红黑树插入删除快，AVL慢，因为AVL旋转次数更多，平衡和调试更难，但AVL读取快，适合读取密集型任务</p>
</li>
</ul>
</li>
<li><p>HashMap红黑树何时会退化？</p>
<ul>
<li><p>当因为扩容时导致树的节点少于6时会退化为链表</p>
</li>
<li><p>当删除树的节点时，主要看root，root.left，root.right，root.left.left</p>
<ul>
<li>如果删除前以上节点还存在则不会退化为链表，反之退化</li>
</ul>
</li>
</ul>
</li>
<li><p>HashMap树化阈值为什么为8？</p>
<ul>
<li>hash值如果足够随机，则在hash表内按泊松分布，在负载因子为0.75的情况下，链表长度超过8的概率为 6*10^-7^</li>
</ul>
</li>
<li><p>索引如何计算？</p>
<ul>
<li>计算对象的hashCode()，再调用HashMap的hash()方法进行第二次哈希运算，最后 &amp; (容量 - 1) 得到索引<ul>
<li>二次哈希值 &#x3D; 原始哈希code ^ 原始哈希code&gt;&gt;&gt;16</li>
<li>注意这里的容量必须是2的n次幂</li>
</ul>
</li>
</ul>
</li>
<li><p>已经有hashCode方法为什么还要提供hash方法？</p>
<ul>
<li>为了使哈希分布更加均匀，减少哈希碰撞</li>
</ul>
</li>
<li><p>容量为何是2的n次幂？</p>
<ul>
<li><p>在HashMap中进行二次hash时可以用按位与运算代替掉取模运算，从而提升一定的计算性能</p>
</li>
<li><p>容量是2的n次幂存在一个问题，当要存储的元素奇偶分布不均时，哈希分布就不那么均匀了</p>
</li>
<li><p>把容量设置为一个质数可以解决这个问题</p>
</li>
<li><p>设置为质数可以在第一次hash时就能有不错的散列分布</p>
</li>
<li><p>如果想要好的性能则选2的n次幂，想要更好的散列分布则选质数</p>
</li>
</ul>
</li>
<li><p>扩容时如何确定新位置？</p>
<ul>
<li>1.8才有的优化<ul>
<li><p>在扩容时会将元素的二次hash值 和 未扩容前的原始容量 进行按位与（**&amp;**）运算</p>
<ul>
<li><p>如果结果为0，表示这些元素扩容后位置不会发生改变</p>
</li>
<li><p>如果结果不为0，则表示这些元素将移动到新的位置</p>
</li>
<li><p>新的位置 &#x3D; 原始位置 + 原始容量</p>
</li>
</ul>
</li>
<li><p>会把结果为0的和结果不为0的串成两条链表，批量操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>扩容因子为什么默认是0.75？ </p>
<ul>
<li><p>在空间占用和查询时间之间取得较好的平衡</p>
</li>
<li><p>大于这个值，空间节省了，但是链表较长影响性能</p>
</li>
<li><p>小于这个值，冲突减少了，但链表扩容频繁，空间占用多</p>
</li>
</ul>
</li>
<li><p>多线程下hashMap存在什么问题？</p>
<ul>
<li><p>jdk7有扩容死链问题</p>
<ul>
<li>是因为1.7扩容后的链表会以头插法插入</li>
<li>当多个线程同时进行扩容时，一个线程扩容后次序改变了，另一个线程再扩容导致死链</li>
</ul>
</li>
<li><p>jdk8有数据丢失问题</p>
<ul>
<li>当多个线程同时往map的同一个位置存放数据时，容易出现覆盖丢失数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul>
<li>非线程安全，有序，可null</li>
<li>底层是哈希表+双向链表（存储顺序）</li>
</ul>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><ul>
<li>单线程，线程安全，速度慢，不可null</li>
<li>底层是哈希表</li>
<li>初始容量是11，每次扩容是：容量 × 2 + 1，因为容量为质数有较好的hash分布</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul>
<li>不能重复，有序，非线程安全</li>
<li>底层红黑树</li>
</ul>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><ul>
<li>key是弱引用，gc时回收</li>
</ul>
<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul>
<li>Comparator&lt;T&gt;：</li>
<li>Supplier&lt;T&gt;：返回一个指定类型的数据</li>
<li>Consumer&lt;T&gt;：用于消费数据</li>
<li>Predicate&lt;T&gt;：对数据进行判断</li>
<li>Function&lt;T,R&gt;：将一个类型的数据转换为另一个类型的数据</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Stream()</td>
<td>将集合转换为流</td>
<td></td>
</tr>
<tr>
<td>Stream.of(数组)</td>
<td>将集合转换为流</td>
<td></td>
</tr>
<tr>
<td>reduce()</td>
<td>实现聚合计算，求和</td>
<td></td>
</tr>
<tr>
<td>mapToXXX()</td>
<td>映射为对应的类型</td>
<td></td>
</tr>
<tr>
<td>orElse() &#x2F; orElseGet()</td>
<td>找不到值则返回给定的值</td>
<td>使用方法时，即使没有值，也会执行 orElse 内的方法</td>
</tr>
<tr>
<td>Collect</td>
<td>收集为指定类型的集合</td>
<td></td>
</tr>
</tbody></table>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li>为一个类创建一个代理类，这个代理类可以调用类中的方法</li>
</ul>
<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><p>​    是Java提供的一种热插拔机制，只要在META-INF目录下定义该类的全路径信息，就可以在Java启动时自动加载对应的类</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>equals()</p>
<ul>
<li>equal是Object 的方法，和他功能相似的是运算符 &#x3D;&#x3D;</li>
<li>&#x3D;&#x3D; 比较的是地址，equal比较的是值</li>
<li>&#x3D;&#x3D; 比较快，&#x3D;&#x3D; 是运算符</li>
<li>equal 源码中也是用的 &#x3D;&#x3D; 进行判断，但是引用类型重写了equals方法<ul>
<li>重写需要满足 自反性、对称性、传递性、一致性、非空性</li>
</ul>
</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><ul>
<li><p>Unsafe提供了非常底层的方法，包括操作内存，线程调度、CAS、系统、内存屏障、对象操作、Class</p>
</li>
<li><p>使Java拥有了类似c语言一样的指针，所以不安全</p>
</li>
<li><p>LookSupport中的unpark也是调用的unsafe的方法</p>
</li>
<li><p>Unsafe不能直接调用</p>
<ul>
<li><p>通过反射获得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">theUnsafe.setAccessible(true);</span><br><span class="line">Unsafe unsafe = theUnsafe.get(null);</span><br><span class="line"></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
</li>
<li><p>Unsafe提供了一个静态方法getUnsafe可以获取Unsafe实例，但是必须使用引导类加载器加载Unsafe类才能使用，因为有CallerSensitive注解标注，为危险方法</p>
<ul>
<li>命令行中输入：<code>java -Xbootclasspath/a: $&#123;path&#125; // 其中path为调用Unsafe相关方法的类所在jar包路径</code></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/Java/" data-id="clrj8k01l00724wuw6jbt8pve" data-title="JavaSE" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/中间件/服务发现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.680Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E4%B8%AD%E9%97%B4%E4%BB%B6/">Java中间件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">服务发现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul>
<li>ZK是一个树形结构</li>
<li>每一个节点都称为ZNode，每个节点保存数据和节点信息</li>
<li>节点可以拥有子节点，也允许少量数据存储</li>
<li>节点分为四大类<ul>
<li>Persistent  持久化节点</li>
<li>Ephemeral  临时节点</li>
<li>Persistent_Sequential 持久化顺序节点</li>
<li>Ephemeral  _Sequential 持久化临时节点</li>
</ul>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>启动服务<ul>
<li><code>./zkServer.sh start</code></li>
</ul>
</li>
<li>查看服务状态<ul>
<li><code>./zkServer.sh status</code></li>
</ul>
</li>
<li>停止服务<ul>
<li><code>./zkServer.sh stop</code></li>
</ul>
</li>
<li>重启服务<ul>
<li><code>./zkServer.sh restart</code></li>
</ul>
</li>
<li>连接zk<ul>
<li><code>./zkCLi.sh -server ip:port</code></li>
</ul>
</li>
<li>创建节点值<ul>
<li><code>create /节点path value</code></li>
</ul>
</li>
<li>设置节点值<ul>
<li><code>set /节点path value</code></li>
</ul>
</li>
<li>获取节点值<ul>
<li><code>get /节点path</code></li>
</ul>
</li>
<li>删除节点值<ul>
<li><code>delete /节点path</code></li>
</ul>
</li>
<li>删除有子节点的节点值<ul>
<li><code>deleteall /节点path</code></li>
</ul>
</li>
<li>创建临时节点<ul>
<li><code>create -e /path value</code></li>
</ul>
</li>
<li>创建顺序节点<ul>
<li><code>create -s /path value</code></li>
</ul>
</li>
<li>查询节点详细信息<ul>
<li><code>ls -s /path</code><br><img src="/../../../blog/source/images/image-20220716152537751.png" alt="image-20220716152537751"></li>
</ul>
</li>
</ul>
<h3 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h3><ul>
<li><p>建立连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重试策略</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;ip地址&quot;</span>, session过期时间, 连接过期时间, 重试策略);</span><br><span class="line"><span class="comment">//第二种方式，建造者模式</span></span><br><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder().connectString(<span class="string">&quot;ip地址&quot;</span>)</span><br><span class="line">    	.sessionTimeoutMs()</span><br><span class="line">    	.connectionTimeoutMs()</span><br><span class="line">    	.retryPolicy(retryPolicy).namespace(<span class="string">&quot;&quot;</span>).build();</span><br><span class="line"><span class="comment">//开启连接</span></span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Create</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//创建节点，没传数据的话，则会将当前客户端的ip地址存储</span></span><br><span class="line">    <span class="comment">//.withMode(CreateMode.*)设置节点类型，默认是持久化</span></span><br><span class="line">    <span class="comment">//.creatingParentsIfNeeded()创建多级节点，路径名/节点名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().forPath(<span class="string">&quot;路径名&quot;</span>, <span class="string">&quot;数据&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Get</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//查询节点</span></span><br><span class="line">    <span class="type">byte</span>[] data = client.getData().forPath(<span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">    <span class="comment">//查询子节点</span></span><br><span class="line">    List&lt;String&gt; path = client.getChildren().forPath(<span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">    <span class="comment">//查询节点状态，保存在status中</span></span><br><span class="line">    <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    client.getData().storingStatIn(status).forPath(<span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Set</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过status.getVersion()获取version</span></span><br><span class="line">    <span class="comment">//.withVersion(version)</span></span><br><span class="line">    client.setData().forPath(<span class="string">&quot;路径名&quot;</span>, <span class="string">&quot;数据&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Delete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    client.delete().forPath(<span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">    <span class="comment">//删除带有子节点的节点</span></span><br><span class="line">    client.delete().deletingChildrenIfNeeded().forPath(<span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">    <span class="comment">//保证删除成功</span></span><br><span class="line">    client.delete().guaranteed().forPath(<span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">    <span class="comment">//失败回调</span></span><br><span class="line">    client.delete().guaranteed().inBackground((client, event) -&gt; &#123;</span><br><span class="line">        <span class="comment">//回调逻辑</span></span><br><span class="line">    &#125;).forPath(<span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><ul>
<li><p>Curator引入了Cache实现服务端的事件监听</p>
<ul>
<li><p>NodeCache：监听一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">NodeCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建NodeCache对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, <span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">    <span class="comment">//注册监听</span></span><br><span class="line">    nodeCache.getListenable().addListener(()-&gt;&#123;</span><br><span class="line">        <span class="comment">/*节点发生变化后执行的逻辑*/</span></span><br><span class="line">        <span class="comment">//获取节点此时的数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//开启监听</span></span><br><span class="line">    nodeCache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PathChildrenCache：监听一个节点的子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PathChildrenCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建PathChildrenCache对象</span></span><br><span class="line">    <span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client, <span class="string">&quot;路径名&quot;</span>, 是否缓存数据);</span><br><span class="line">    <span class="comment">//注册监听</span></span><br><span class="line">    pathChildrenCache.getListenable().addListener((client, event) -&gt; &#123;</span><br><span class="line">        <span class="comment">/*节点发生变化后执行的逻辑*/</span></span><br><span class="line">        <span class="comment">//获取节点此时的数据</span></span><br><span class="line">        PathChildrenCache.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> event.getType(); <span class="comment">//获取类型</span></span><br><span class="line">        <span class="keyword">if</span>(type.equals(PathChildrenCache.Type.CHILD_UPDATED)) <span class="comment">//判断类型是否是Update</span></span><br><span class="line">            <span class="type">byte</span>[] data = event.getData.getData();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//开启监听</span></span><br><span class="line">    pathChildrenCache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TreeCache：监听所有节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TreeCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建TreeCache对象</span></span><br><span class="line">    <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCache</span>(client, <span class="string">&quot;路径名&quot;</span>);</span><br><span class="line">    <span class="comment">//注册监听</span></span><br><span class="line">    treeCache.getListenable().addListener((client, event) -&gt; &#123;</span><br><span class="line">        <span class="comment">/*节点发生变化后执行的逻辑*/</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//开启监听</span></span><br><span class="line">    treeCache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul>
<li>核心思想：当客户端需要获取锁时，则创建节点，使用完锁后，删除该节点<ul>
<li>客户端获取锁时，在lock节点下创建临时顺序节点</li>
<li>获取lock下所有子节点<ul>
<li>若发现自己创建的节点序号最小，那么获取锁，使用完后释放锁并删除节点</li>
<li>若发现自己创建的节点序号不是最小，那么找到那个最小的节点，对其注册监听器，监听其删除事件</li>
</ul>
</li>
<li>监听到最小节点被删除时，再次判断自己的创建的节点是否是序号最小的<ul>
<li>是就获取锁，使用完后释放锁并删除节点</li>
<li>不是就重复上面的步骤</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentiaBackoffRetry</span>(<span class="number">3000</span>,<span class="number">10</span>);</span><br><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">    .connectString(<span class="string">&quot;地址&quot;</span>)</span><br><span class="line">    .sessionTimeoutMs(<span class="string">&quot;会话超时时间 毫秒&quot;</span>)</span><br><span class="line">    .connectionTimeoutMs(<span class="string">&quot;连接超时时间 毫秒&quot;</span>)</span><br><span class="line">    .retryPolicy(retryPolicy)</span><br><span class="line">    .builder();</span><br><span class="line"><span class="comment">//开启连接</span></span><br><span class="line">client.start();</span><br><span class="line"><span class="comment">//创建锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/lock&quot;</span>);</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">lock.acquire(超时时间，时间单位);</span><br><span class="line"></span><br><span class="line">---临界区---</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">lock.release();</span><br></pre></td></tr></table></figure>

<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul>
<li>Leader选举，获得半数以上选票<ul>
<li>Serverid：服务器ID，值越大，选中Leader可能性越大</li>
<li>Zxid：数据ID，值越大，选中Leader可能性越大</li>
</ul>
</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li><p>在&#x2F;data下创建myid文件，内容是服务器ID</p>
</li>
<li><p>编辑&#x2F;conf下的zoo.cfg文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server.服务器ID=服务器ip地址:服务器之间通信端口:服务器之间投票选举端口</span></span><br><span class="line"><span class="string">server.服务器ID=服务器ip地址:服务器之间通信端口:服务器之间投票选举端口</span></span><br><span class="line"><span class="string">server.服务器ID=服务器ip地址:服务器之间通信端口:服务器之间投票选举端口</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>Leader 领导者<ul>
<li>处理事务请求</li>
<li>集群内部各服务器调度者</li>
</ul>
</li>
<li>Follower 追随者<ul>
<li>处理非事务请求，转发事务请求给Leader</li>
<li>参与Leader选举投票</li>
</ul>
</li>
<li>Observer 观察者<ul>
<li>处理非事务请求，转发事务请求给Leader</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" data-id="clrj8k01k006n4wuwaa50gbt2" data-title="服务发现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/中间件/消息队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.680Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E4%B8%AD%E9%97%B4%E4%BB%B6/">Java中间件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MQ协议"><a href="#MQ协议" class="headerlink" title="MQ协议"></a>MQ协议</h1><p>MOM（Message Oriented Middleware 面向消息中间件）</p>
<ul>
<li>PO  面向过程</li>
<li>OO 面向对象</li>
<li>AO  面向切面</li>
</ul>
<p>JMS（Java Message Service）</p>
<ul>
<li>Java消息服务协议，是一种MOM的设计实现</li>
<li>标准的生产、发送、接收消息</li>
<li>ActiveMQ是该协议的典型实现</li>
</ul>
<p>STOMP（Streaming Text Orientated Message Protocol）</p>
<ul>
<li>面向文本流的消息协议，是一种MOM的设计实现</li>
<li>可互操作的连接格式，允许客户端与任意的STOMP消息代理进行交互</li>
<li>ActiveMQ是该协议的典型实现，RabbitMQ可通过插件实现</li>
</ul>
<p>AMQP（Advanced Message Queuing Protocol）</p>
<ul>
<li>高级消息队列协议，是一种MOM的设计实现</li>
<li>是一个应用层协议，是一种标准，不受客户端&#x2F;中间件&#x2F;语言的限制</li>
<li>RabbitMQ是该协议的典型实现</li>
</ul>
<p>MQTT（Message Queuing Telemetry Transport）</p>
<ul>
<li>消息队列遥测传输，即时通信协议，是一种二进制协议，也是一种MOM的设计实现</li>
<li>用于服务器和低功耗LOT设备间的通信，支持所有平台，可以把所有联网物品和外部连接起来</li>
<li>RabbitMQ可通过插件实现</li>
</ul>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>Producer<ul>
<li>消息生产者</li>
<li>Producer Group<ul>
<li>一类Producer集合，发送一类消息，发送逻辑一致</li>
</ul>
</li>
</ul>
</li>
<li>Consumer<ul>
<li>消息消费者，后台异步消费</li>
<li>Push Consumer<ul>
<li>服务端向消费者端推送消息</li>
</ul>
</li>
<li>Pull Consumer<ul>
<li>消费者端向服务端定时拉取消息</li>
</ul>
</li>
<li>Consumer Group<ul>
<li>一类Consumer集合，消费一类消息，消费逻辑一致</li>
</ul>
</li>
</ul>
</li>
<li>NameServer<ul>
<li>组织协调者</li>
<li>收集Broker的工作情况</li>
</ul>
</li>
<li>Broker<ul>
<li>pic的核心，负责消息的发送，接收，高可用等（是真正干活的）</li>
<li>需要定时发送自身情况到NameServer，10秒发送一次，超过2分钟没发，NameServer会认为该Broker失效</li>
</ul>
</li>
<li>Topic<ul>
<li>在Broker中</li>
<li>不同类型的消息以不同的Topic进行区分</li>
<li>MessageQueue<ul>
<li>消息队列，用于存储消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">CreateTopic</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置nameserver的地址</span></span><br><span class="line">    producer.setNameservAddr(<span class="string">&quot;ip地址:端口号&quot;</span>);</span><br><span class="line">    <span class="comment">//启动生产者</span></span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="comment">//创建topic</span></span><br><span class="line">    producer.createTopic(<span class="string">&quot;broker名称&quot;</span>, <span class="string">&quot;topic名称&quot;</span>, 队列数量);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li>生产者需要在构造时创建或加入分组</li>
<li>信息需要设置topic、broke名，可以添加tags，队列数量</li>
<li>发送消息<ul>
<li>同步：send(message)<ul>
<li>message需要设置topic、tags、消息内容（字节数组）</li>
</ul>
</li>
<li>异步：send(message, new SendCallback(){  &#x2F;&#x2F;重写两个方法 })</li>
</ul>
</li>
</ul>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li>订阅topic，设置接收的信息类型（可以根据tags选择）</li>
<li>创建监听器（并发 &#x2F; 顺序）<ul>
<li>消息过滤器(需要开启)<ul>
<li>消费者接收消息是可以进行筛选<ul>
<li>MessageSelector.bySql(“”)</li>
</ul>
</li>
<li>生产者发送信息时可为信息设置一些属性<ul>
<li>message.putUserProperty(name, value)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果需要实现顺序消费消息<ul>
<li>生产者需要将信息存入同一个topic中同一个队列</li>
<li>消费者需要按顺序从同一条队列中取消息<ul>
<li>监听器选择MessageListenerOrderly</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li>使用TransactionMQProducer，设置NamesrvAddr，设置事务监听器（TransactionListener），需要传入事务监听器实现类<ul>
<li>实现类需要实现executeLocalTransaction（业务实现）和checkLocalTransaction（回查）</li>
</ul>
</li>
<li>事务回查<ul>
<li>在executeLocalTransaction中需要设置各个阶段事务的状态，存储在一个Map集合中，事务id为key</li>
<li>在checkLocalTransaction中，从Map中根据事务id从Map中获取事务状态返回</li>
</ul>
</li>
<li>使用Spring<ul>
<li>实现<code>PicLocalTransactionListener</code> 接口</li>
<li>添加<code>@PicTransactionListener(txProducerGroup = &quot;生产者组名&quot;)</code></li>
<li>保存事务的状态</li>
</ul>
</li>
</ul>
<h2 id="消息推送"><a href="#消息推送" class="headerlink" title="消息推送"></a>消息推送</h2><h3 id="消费者推送模式"><a href="#消费者推送模式" class="headerlink" title="消费者推送模式"></a>消费者推送模式</h3><ul>
<li>push模式<ul>
<li>服务端有消息就推送给客户端，需要建立长连接，客户端多时消耗资源</li>
</ul>
</li>
<li>pull模式<ul>
<li>客户端轮询服务端，有消息就拉取，存在实时性问题</li>
</ul>
</li>
<li>长轮询<ul>
<li>使用长轮询解决了push和pull的问题，即长连接+轮询</li>
</ul>
</li>
</ul>
<h3 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h3><ul>
<li>集群（默认）<ul>
<li>某个消费者可以接收</li>
</ul>
</li>
<li>广播<ul>
<li>每个消费者都可以接收</li>
</ul>
</li>
<li>通过 <code>setMessageModel</code> 设置</li>
</ul>
<h3 id="重复消息"><a href="#重复消息" class="headerlink" title="重复消息"></a>重复消息</h3><ul>
<li>消费端处理业务保证幂等性</li>
<li>每条消息都有唯一的编号，判断消息是否处理过即可</li>
<li>不保证消息不重复，需要在业务端处理</li>
</ul>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><ul>
<li>零拷贝（mmap+write） </li>
<li>文件系统采用Linux Ext4</li>
<li>往磁盘写入是顺序写入的，由ConsumeQueue和CommitLog配合<ul>
<li>CommitLog 真正存储数据的文件</li>
<li>ConsumeQueue 存储消息在CommitLog 中的位置信息</li>
</ul>
</li>
</ul>
<h2 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h2><ul>
<li>同步刷盘<ul>
<li>写入磁盘后再返回成功</li>
</ul>
</li>
<li>异步刷盘<ul>
<li>写入内存后就返回成功，内存积累一定信息后批量刷盘</li>
</ul>
</li>
</ul>
<h2 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h2><h3 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li>设置重试次数<ul>
<li><code>setRetryATimesWhenSendFaild(次数)</code></li>
</ul>
</li>
<li>在发送消息时指定超时时间<ul>
<li><code>send(message, 超时时间)</code></li>
</ul>
</li>
<li>并不是所有的异常都会触发重试</li>
</ul>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li>异常失败<ul>
<li>每次重试的时间间隔不同，不能修改</li>
<li>重新获取的消息id是不同的，但是内容是相同的</li>
</ul>
</li>
<li>超时失败<ul>
<li>RQ服务器会不断重试发送，直到发送成功</li>
</ul>
</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><ul>
<li>单master<ul>
<li>风险最大</li>
</ul>
</li>
<li>多master<ul>
<li>全是master</li>
<li>一个机器宕机，未消费的信息不可订阅，实时性受到影响</li>
</ul>
</li>
<li>多master多slave<ul>
<li>异步复制<ul>
<li>master和slave之间有短暂消息延迟，毫秒级，速度快，磁盘损坏丢失少量信息</li>
</ul>
</li>
<li>同步双写<ul>
<li>master和slave同时写，速度慢，消息无延迟，高可用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2><p><img src="/../../../blog/source/images/image-20230411170928441.png" alt="image-20230411170928441"></p>
<ul>
<li>channel：操作MQ的工具</li>
<li>exchange：路由消息到队列中</li>
<li>queue：缓存消息</li>
<li>virtualHost：虚拟主机<ul>
<li>多租户，相互隔离</li>
<li>创建角色后需要为其分配虚拟主机</li>
<li>类似命名空间</li>
</ul>
</li>
</ul>
<h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><h3 id="基本消息队列（BasicQueue）"><a href="#基本消息队列（BasicQueue）" class="headerlink" title="基本消息队列（BasicQueue）"></a>基本消息队列（BasicQueue）</h3><h3 id="工作消息队列（WorkQueue）"><a href="#工作消息队列（WorkQueue）" class="headerlink" title="工作消息队列（WorkQueue）"></a>工作消息队列（WorkQueue）</h3><h3 id="发布订阅（Publish、Subscribe）"><a href="#发布订阅（Publish、Subscribe）" class="headerlink" title="发布订阅（Publish、Subscribe）"></a>发布订阅（Publish、Subscribe）</h3><ul>
<li>Fanout Exchange：广播</li>
<li>Direct Exchange：路由</li>
<li>Topic Exchange：主题</li>
</ul>
<h2 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者&#x2F;消费者"></a>生产者&#x2F;消费者</h2><h4 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h4><ol>
<li>创建连接<ul>
<li>通过连接工厂（ConnectionFactory）</li>
<li>设置地址、端口、虚拟主机、用户名、密码</li>
</ul>
</li>
<li>建立连接</li>
<li>创建通道</li>
<li>创建队列</li>
<li>发送消息</li>
<li>关闭通道和连接</li>
</ol>
<h3 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h3><ol>
<li>创建连接<ul>
<li>通过连接工厂（ConnectionFactory）</li>
<li>设置地址、端口、虚拟主机、用户名、密码</li>
</ul>
</li>
<li>建立连接</li>
<li>创建通道</li>
<li>创建队列<ul>
<li>防止队列不存在，因为消费者有可能先建立了连接</li>
</ul>
</li>
<li><h2 id="订阅信息-消费信息-回调函数异步处理消息"><a href="#订阅信息-消费信息-回调函数异步处理消息" class="headerlink" title="订阅信息 &#x2F; 消费信息- 回调函数异步处理消息"></a>订阅信息 &#x2F; 消费信息<br>- 回调函数异步处理消息</h2></li>
</ol>
<h2 id="手动事务消息"><a href="#手动事务消息" class="headerlink" title="手动事务消息"></a>手动事务消息</h2><ul>
<li>提供了一套api实现</li>
<li>会导致Channel阻塞，造成吞吐量下降</li>
</ul>
<h2 id="生产者确认机制（Publisher-Confirm）"><a href="#生产者确认机制（Publisher-Confirm）" class="headerlink" title="生产者确认机制（Publisher Confirm）"></a>生产者确认机制（Publisher Confirm）</h2><ul>
<li>新版本扩展</li>
<li>类似的事务消息基本一致</li>
</ul>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" data-id="clrj8k01k006r4wuwd6uvbqsk" data-title="消息队列" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Note/后端/Java/中间件/文件服务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.679Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E4%B8%AD%E9%97%B4%E4%BB%B6/">Java中间件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/">OSS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>是一个对象存储服务，存储非结构化存储，GoLang写的</li>
<li>Bucket<ul>
<li>Object</li>
</ul>
</li>
</ul>
<h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><ul>
<li>本质上就是分块上传，主要区别在于粒度的划分</li>
<li>minio默认的合并分块时最小得是5m，小于这个值的话会报错</li>
<li>合并分块后一般需要校验是否完整，可以使用 md5 实现</li>
<li>具体流程<ul>
<li>前端在上传分块之前先检查该文件在minio上是否存在<ul>
<li>传一个待上传文件的md5值，后端在数据库和minio中查询是否存在即可</li>
<li>有可能出现数据库有minio没有，也要上传</li>
</ul>
</li>
<li>开始上传分块，需要先判断分块是否存在<ul>
<li>传一个待上传分块的md5值和分块的序号（一般就是分块的文件名），后端在minio中查询是否存在即可</li>
</ul>
</li>
<li>上传分块<ul>
<li>使用md5的前两位作为minio上文件的存储目录</li>
<li>使用md5值作为文件名</li>
</ul>
</li>
<li>合并分块</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/" data-id="clrj8k01j006l4wuwdmjy8kcu" data-title="OSS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E4%B8%AD%E9%97%B4%E4%BB%B6/">Java中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A1%86%E6%9E%B6/">Java框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web3/">Web3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3/">力扣</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A8%A1%E5%9D%97/">模块</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/">计算机知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/defi/" rel="tag">defi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/language/" rel="tag">language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solidity/" rel="tag">solidity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web3/" rel="tag">web3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" rel="tag">代码随想录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%A2%98100/" rel="tag">力扣热题100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%9B%E6%89%A3%E9%A2%98/" rel="tag">力扣题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%A5%9E/" rel="tag">左神</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%93/" rel="tag">库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag">技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97/" rel="tag">模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B/" rel="tag">模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E5%BF%B5/" rel="tag">理念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9Fan-quan/" rel="tag">系统an&#39;quan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" rel="tag">系统设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%84%E8%8C%83/" rel="tag">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E6%88%90/" rel="tag">集成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E7%BE%A4/" rel="tag">集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/defi/" style="font-size: 10px;">defi</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/language/" style="font-size: 10px;">language</a> <a href="/tags/solidity/" style="font-size: 10px;">solidity</a> <a href="/tags/web3/" style="font-size: 12.86px;">web3</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 20px;">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 10px;">代码随想录</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 10px;">优化</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 10px;">剑指offer</a> <a href="/tags/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%A2%98100/" style="font-size: 10px;">力扣热题100</a> <a href="/tags/%E5%8A%9B%E6%89%A3%E9%A2%98/" style="font-size: 10px;">力扣题</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">基础</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E5%B7%A6%E7%A5%9E/" style="font-size: 10px;">左神</a> <a href="/tags/%E5%BA%93/" style="font-size: 10px;">库</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 18.57px;">开发</a> <a href="/tags/%E6%8A%80%E5%B7%A7/" style="font-size: 11.43px;">技巧</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12.86px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" style="font-size: 17.14px;">数据结构和算法</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 14.29px;">框架</a> <a href="/tags/%E6%A8%A1%E5%9D%97/" style="font-size: 15.71px;">模块</a> <a href="/tags/%E6%A8%A1%E5%9E%8B/" style="font-size: 11.43px;">模型</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 12.86px;">源码</a> <a href="/tags/%E7%90%86%E5%BF%B5/" style="font-size: 14.29px;">理念</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9Fan-quan/" style="font-size: 10px;">系统an'quan</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">系统设计</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E8%A7%84%E8%8C%83/" style="font-size: 10px;">规范</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a> <a href="/tags/%E9%9B%86%E6%88%90/" style="font-size: 10px;">集成</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 10px;">集群</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 12.86px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E8%8B%B1%E8%AF%AD/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E5%9C%BA%E6%99%AF%E9%A2%98/">场景题</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 JianHong<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>