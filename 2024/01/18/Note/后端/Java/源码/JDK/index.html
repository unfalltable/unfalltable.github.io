<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JDK源码 | JianHong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Unsafe简介  因为使Java拥有了类似c语言一样的指针，所以不安全Unsafe  Unsafe不能直接调用  通过反射获得 123Field theUnsafe &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);theUnsafe.setAccessible(true);Unsafe unsafe &#x3D; theUnsafe.get(n">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK源码">
<meta property="og:url" content="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E6%BA%90%E7%A0%81/JDK/index.html">
<meta property="og:site_name" content="JianHong">
<meta property="og:description" content="Unsafe简介  因为使Java拥有了类似c语言一样的指针，所以不安全Unsafe  Unsafe不能直接调用  通过反射获得 123Field theUnsafe &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);theUnsafe.setAccessible(true);Unsafe unsafe &#x3D; theUnsafe.get(n">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-01-18T13:12:24.702Z">
<meta property="article:modified_time" content="2023-08-04T01:33:58.000Z">
<meta property="article:author" content="JianHong">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="JianHong" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JianHong</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Note/后端/Java/源码/JDK" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E6%BA%90%E7%A0%81/JDK/" class="article-date">
  <time class="dt-published" datetime="2024-01-18T13:12:24.702Z" itemprop="datePublished">2024-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JDK源码
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>简介</p>
<ul>
<li><p>因为使Java拥有了类似c语言一样的指针，所以不安全Unsafe</p>
</li>
<li><p>Unsafe不能直接调用</p>
<ul>
<li><p>通过反射获得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> theUnsafe.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Unsafe提供了一个静态方法getUnsafe可以获取Unsafe实例，但是必须使用引导类加载器加载Unsafe类才能使用，因为有@CallerSensitive注解标注，为危险方法</p>
<ul>
<li>命令行中输入：<code>java -Xbootclasspath/a: $&#123;path&#125;   // 其中path为调用Unsafe相关方法的类所在jar包路径 </code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作内存</p>
<ul>
<li>主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法</li>
<li>为什么要使用堆外内存<ul>
<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。</li>
<li>提升程序I&#x2F;O操作的性能。通常在I&#x2F;O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
</li>
<li>应用：<ul>
<li>DirectByteBuffer，在NIO框架中通常作为缓冲池使用，内部的内存分配逻辑都由Unsafe提供<ul>
<li><code>unsafe.allocateMemory(内存大小)</code><ul>
<li>分配内存，返回基地址</li>
</ul>
</li>
<li><code>unsafe.setMemory(base, size, (byte) 0)</code><ul>
<li>设置内存，内存初始化</li>
</ul>
</li>
<li><code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap))</code><ul>
<li>跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放</li>
<li>Cleaner继承自虚引用，当DirectByteBuffer对象仅被Cleaner对象引用时，</li>
<li>gc时会将DirectByteBuffer对象回收，Cleaner对象会调用clean() 方法来进行堆外内存的释放。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CAS（CompareAndSwap）</p>
<ul>
<li>是一个本地方法</li>
<li>AtomicInteger 使用 unsafe提供的CAS</li>
<li>Unsafe只提供了 compareAndSwapObject、compareAndSwapInt、compareAndSwapLong 方法</li>
<li>赋值阶段源码中都是通过do-while判断</li>
<li>原理：<ul>
<li><p>通过循环判断预期值来决定是否更新值</p>
</li>
<li><p>如果是多处理器，需要添加lock前缀（Lock#信号），内存屏障</p>
</li>
<li><p>这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)</p>
<ul>
<li><p>总线锁：将cpu和内存之间的通信锁住，其他cpu不能操作内存中的数据，开销比较大，相当于加了悲观锁</p>
</li>
<li><p>缓存锁：使用缓存锁定，将原子操作放在cpu缓存中进行</p>
<ul>
<li>缓存锁定：<ul>
<li>发生共享内存的锁定时，不会锁内存，而是修改内存地址，通过<strong>MESI缓存一致性</strong>保证原子性</li>
</ul>
</li>
<li>缓存一致性：<ul>
<li>如果这块内存被两个以上的处理器缓存，会阻止这块内存区域的同时修改</li>
<li>当处理器对缓存中的数据修改后，会通知其他处理器删除其内部这块内存的缓存，或者从主内存中重新读取</li>
</ul>
</li>
<li>如果操作的数据跨多个缓存行时，处理器会使用总线锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>线程调度</p>
<ul>
<li>线程挂起、恢复、锁机制</li>
<li>park、unpark、monitorEnter、monitorExit、tryMonitorEnter</li>
</ul>
<p>Class相关</p>
<ul>
<li>提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等</li>
<li>获取属性在内存中的位置</li>
<li>获取数组第一个元素在内存中的偏移地址，还可以获取下标的增量地址</li>
</ul>
<p>系统相关</p>
<ul>
<li>addressSize：返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）</li>
<li>pageSize：内存页的大小，此值为2的幂次方</li>
</ul>
<p>内存屏障</p>
<ul>
<li>loadFence：禁止load操作重排序</li>
<li>storeFence：禁止store操作重排序</li>
<li>fullFence：禁止load、store操作重排序</li>
</ul>
<p>对象操作</p>
<ul>
<li>主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法</li>
<li>Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响</li>
</ul>
<h3 id="getUnsafe"><a href="#getUnsafe" class="headerlink" title="getUnsafe()"></a>getUnsafe()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass(); <span class="comment">//getCallerClass方法需要启动类加载的类才可以调用</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getAndAddInt"><a href="#getAndAddInt" class="headerlink" title="getAndAddInt()"></a>getAndAddInt()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2); <span class="comment">//检验</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重新分配内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//分配内存  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//释放内存  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//在给定的内存块中设置值  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//从一个内存块拷贝到另一个内存块  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset, Object destBase, <span class="type">long</span> destOffset, <span class="type">long</span> bytes)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取值，不管java的访问限制，其他有类似的getInt，getDouble，getLong，getChar等等  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">getObject</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//设置值，不管java的访问限制，其他有类似的putInt,putDouble，putLong，putChar等等  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//从一个给定的内存地址获取本地指针，如果不是allocateMemory方法的，结果将不确定  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">getAddress</span><span class="params">(<span class="type">long</span> address)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//存储一个本地指针到一个给定的内存地址,如果地址不是allocateMemory方法的，结果将不确定  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putAddress</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> x)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//该方法返回给定field的内存地址偏移量，这个值对于给定的filed是唯一的且是固定不变的  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//报告一个给定的字段的位置，不管这个字段是private，public还是保护类型，和staticFieldBase结合使用  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field f)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取一个给定字段的位置  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//确保给定class被初始化，这往往需要结合基类的静态域（field）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">ensureClassInitialized</span><span class="params">(Class c)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//可以获取数组第一个元素的偏移地址  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayBaseOffset</span><span class="params">(Class arrayClass)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//可以获取数组的转换因子，也就是数组中元素的增量地址。将arrayBaseOffset与arrayIndexScale配合使用， 可以定位数组中每个元素在内存中的位置  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayIndexScale</span><span class="params">(Class arrayClass)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取本机内存的页数，这个值永远都是2的幂次方  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">pageSize</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//告诉虚拟机定义了一个没有安全检查的类，默认情况下这个类加载器和保护域来着调用者类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class <span class="title function_">defineClass</span><span class="params">(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len, ClassLoader loader, ProtectionDomain protectionDomain)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义一个类，但是不让它知道类加载器和系统字典  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class <span class="title function_">defineAnonymousClass</span><span class="params">(Class hostClass, <span class="type">byte</span>[] data, Object[] cpPatches)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//锁定对象，必须是没有被锁的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//解锁对象  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//试图锁定对象，返回true或false是否锁定成功，如果锁定，必须用monitorExit解锁  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//引发异常，没有通知  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">throwException</span><span class="params">(Throwable ee)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//CAS，如果对象偏移量上的值=期待值，更新为x,返回true.否则false.类似的有compareAndSwapInt,compareAndSwapLong,compareAndSwapBoolean,compareAndSwapChar等等。  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,  Object expected, Object x)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 该方法获取对象中offset偏移地址对应的整型field的值,支持volatile load语义。类似的方法有getIntVolatile，getBooleanVolatile等等  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">getObjectVolatile</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">//线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，也正是使用这两个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取系统在不同时间系统的负载情况  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getLoadAverage</span><span class="params">(<span class="type">double</span>[] loadavg, <span class="type">int</span> nelems)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//创建一个类的实例，不需要调用它的构造函数、初使化代码、各种JVM安全检查以及其它的一些底层的东西。即使构造函数是私有，我们也可以通过这个方法创建它的实例,对于单例模式，简直是噩梦。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">allocateInstance</span><span class="params">(Class cls)</span> <span class="keyword">throws</span> InstantiationException;  </span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li><p>扩容</p>
<ul>
<li>使用无参构造方法创建时默认初始容量是0，使用add方法添加元素就触发扩容</li>
<li>第一次扩容容量变为10，当存满了会再触发扩容，默认是1.5倍</li>
<li>扩容是创建一个新数组，再将原数组内容拷贝到新数组</li>
<li>扩容后容量 &#x3D; 扩容前容量 &gt; 1 +扩容前容量 (即1.5倍)</li>
<li>因为每次扩容都比较小，所以要尽量避免频繁的扩容，当预知要保存多少元素时，就在创建时指定ArrayList的初始大小，或者使用ensureCapacity手动扩容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组最大值 = 整型最大值 - 8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到最大的数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 太大超过int最大值就变成负数了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>add(E e)、addAll(Collection&lt;? extends E&gt; c)</p>
<ul>
<li>检查剩余空间是否需要扩容，modCount++</li>
<li>添加到数组末尾</li>
<li>更新size</li>
</ul>
</li>
<li><p>add(int index, E element)、addAll(int index, Collection&lt;? extends E&gt; c)</p>
<ul>
<li>检查下标是否越界</li>
<li>检查剩余空间是否需要扩容，modCount++</li>
<li>原数组的值复制到新数组，插入区间前后的元素复制到新数组不包含插入区间的位置</li>
<li>然后在插入区间插入新增的元素</li>
<li>更新size</li>
</ul>
</li>
<li><p>set(int index, E element)</p>
<ul>
<li>检查下标是否越界</li>
<li>保存老值，新值插入index位置</li>
<li>返回老值</li>
</ul>
</li>
<li><p>get(int index)</p>
<ul>
<li>检查下标是否越界</li>
<li>返回指定下标的值，需要注意类型转换</li>
</ul>
</li>
<li><p>remove(int index)</p>
<ul>
<li>检查下标是否越界，modCount++</li>
<li>保存老值</li>
<li>数组从index下标之后的元素都往前移（通过复制）</li>
<li>为了让GC起作用，最后一个位置会显式赋<code>null</code>值</li>
<li>返回老值</li>
</ul>
</li>
<li><p>remove(Object o)</p>
<ul>
<li>删除第一个满足<code>o.equals(elementData[index])</code>的元素</li>
</ul>
</li>
<li><p>trimToSize() 将底层数组的容量调整为当前列表保存的实际元素的大小</p>
<ul>
<li><p>modCount++</p>
</li>
<li><p>判断 size 是否 小于数组大小</p>
<ul>
<li>如果size &#x3D;&#x3D; 0 则为空数组</li>
<li>size !&#x3D; 0 则 将数组复制到一个size &#x3D; 数组长度的新数组</li>
</ul>
</li>
</ul>
</li>
<li><p>indexOf(Object o)、lastIndexOf(Object o)</p>
<ul>
<li><p>判断 o 是否为 null</p>
</li>
<li><p>遍历数组找下标</p>
<ul>
<li>o 为 null 则用 &#x3D;&#x3D; 判断</li>
<li>o 不为 null 则用 equals 判断</li>
</ul>
</li>
<li><p>找到返回下标，找不到返回-1</p>
</li>
</ul>
</li>
<li><p>Fail-Fast机制</p>
<ul>
<li>通过记录modCount参数，迭代器遍历的时候遇到并发的修改时会报错</li>
</ul>
</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li><p>getFirst() 、getLast()</p>
<ul>
<li>定义个一个常量来接收 first 或者 last</li>
<li>如果指向 null，抛<code>NoSuchElementException</code>异常</li>
<li>有值就返回</li>
</ul>
</li>
<li><p>get(int index)</p>
<ul>
<li>检查下标是否合法，是否越界</li>
<li>返回 node(index).item</li>
</ul>
</li>
<li><p>set(int index, E element)</p>
<ul>
<li>判断下标是否合法，是否越界</li>
<li>Node x &#x3D; node(index) </li>
<li>E oldVal &#x3D; x.item</li>
<li>x.item &#x3D; element</li>
<li>return  oldVal</li>
</ul>
</li>
<li><p>remove(Object o)</p>
<ul>
<li><p>判断 o 是否为 null</p>
</li>
<li><p>遍历链表找值符合的节点</p>
<ul>
<li>o 为 null 则用 &#x3D;&#x3D; 判断</li>
<li>o 不为 null 则用 equals 判断</li>
</ul>
</li>
<li><p>找到则用 unlink() 删除节点，成功返回true</p>
</li>
</ul>
</li>
<li><p>remove(int index)</p>
<ul>
<li>检查下标是否越界</li>
<li>用 unlink( node(index) ) 删除节点</li>
</ul>
</li>
<li><p>removeFirst()、removeLast()</p>
<ul>
<li>定义一个常来接收 first &#x2F; last</li>
<li>first &#x2F; last 为null 抛NoSuchElementException异常</li>
<li>不为空则调用 unlinkFirst() &#x2F; unlinkLast()</li>
</ul>
</li>
<li><p>unlink(Node&lt;E&gt; x)</p>
<ul>
<li>定义三个常量保存节点的值 element、前驱节点 prev、后继节点 next</li>
<li>先处理前驱，在处理后继，注意防止空指针异常<ul>
<li>判断 prev 是否为null<ul>
<li>为 null 说明是第一个节点要删除，直接 first &#x3D; next</li>
<li>不为 null，则 prev.next &#x3D; next，x.prev &#x3D; null</li>
</ul>
</li>
<li>判断 next 是否为null<ul>
<li>为 null 则说明是最后一个节点要删除，直接 last &#x3D; prev</li>
<li>不为 null，则 next.prev &#x3D; prev，x.next &#x3D; null</li>
</ul>
</li>
</ul>
</li>
<li>将x的值置为 null。更新 size，modCount++</li>
<li>返回被删除的值 element</li>
</ul>
</li>
<li><p>unlinkFirst(Node&lt;E&gt; f)</p>
<ul>
<li><p>定义两个常量保存节点的值 element，后继节点 next</p>
</li>
<li><p>将 f 的值和后继节点置为 null</p>
</li>
<li><p>然后 first &#x3D; next</p>
</li>
<li><p>判断 next 是否等于 null</p>
<ul>
<li>为 null，则 last &#x3D; null</li>
<li>不为 null，则 next.prev &#x3D; null</li>
</ul>
</li>
<li><p>size–</p>
</li>
<li><p>modCount++</p>
</li>
<li><p>返回被删除的值 element</p>
</li>
</ul>
</li>
<li><p>unlinkLast(Node&lt;E&gt; l)</p>
<ul>
<li>定义两个常量保存节点的值 element，前驱节点 prev</li>
<li>将 l 的值和前驱节点置为 null</li>
<li>然后 last &#x3D; prev</li>
<li>判断 prev 是否等于 null<ul>
<li>为 null，则 first &#x3D; null</li>
<li>不为 null，则 prev.next &#x3D; null</li>
</ul>
</li>
<li>size–</li>
<li>modCount++</li>
<li>返回被删除的值 element</li>
</ul>
</li>
<li><p>add(E e)</p>
<ul>
<li>调用 linkLast(e)</li>
<li>返回 true</li>
</ul>
</li>
<li><p>add(int index, E element)</p>
<ul>
<li>判断下标是否合法，是否越界</li>
<li>如果 下标 &#x3D; size，说明是在链表最后插入，调用 linkLast(element)</li>
<li>下标 !&#x3D; size，则调用 linkBefore(element, node(index))</li>
</ul>
</li>
<li><p>linkLast(E e)</p>
<ul>
<li>定义两个常量保存 尾节点 l，新节点 newNode（根据 e 创建）</li>
<li>last &#x3D; newNode</li>
<li>判断 l 是否为 null<ul>
<li>为 null，说明链表中无节点，所以 first &#x3D; newNode</li>
<li>不为 null，说明链表中有节点，所以 l.next &#x3D; newNode</li>
</ul>
</li>
<li>size++</li>
<li>modCount++</li>
</ul>
</li>
<li><p>node(int index) </p>
<ul>
<li>判断 index 在链表前半段还是后半段，通过比较 size &gt;&gt; 1<ul>
<li>前半段：从前往后遍历找<ul>
<li>x &#x3D; first</li>
<li>for x &#x3D; x.next</li>
</ul>
</li>
<li>后半段：从后往前遍历找<ul>
<li>x &#x3D; last</li>
<li>for x &#x3D; x.prev</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>addAll(Collection&lt;? extends E&gt; c)</p>
<ul>
<li>调用addAll(size, c) 实现</li>
</ul>
</li>
<li><p>addAll(int index, Collection&lt;? extends E&gt; c)</p>
<ul>
<li><p>判断下标是否合法</p>
</li>
<li><p>将集合c转化为Object数组 a</p>
</li>
<li><p>得到 a的长度 numNew，判断是否等于0，等于0返回false</p>
</li>
<li><p>创建两个节点指针 pred、succ</p>
</li>
<li><p>判断 index 是否等于 size</p>
<ul>
<li>等于，相当于在链表最后添加，则 succ &#x3D; null，pred &#x3D; last</li>
<li>不等于，则 succ &#x3D; node(index)，pred &#x3D; succ.prev</li>
</ul>
</li>
<li><p>遍历 for (Object o : a) </p>
<ul>
<li>E e &#x3D; (E) o      强制类型转换</li>
<li>根据值和前驱 pred 创建节点 newNode </li>
<li>判断 pred 是否为 null<ul>
<li>为 null，则 first &#x3D; newNode</li>
<li>不为 null，pred.next &#x3D; newNode</li>
</ul>
</li>
<li>pred &#x3D; newNode</li>
</ul>
</li>
<li><p>判断 succ 是否为 null</p>
<ul>
<li>为 null，则 last &#x3D; pred</li>
<li>不为 null，则 pred.next &#x3D; succ，succ.prev &#x3D;  pred</li>
</ul>
</li>
<li><p>size +&#x3D; numNew</p>
</li>
<li><p>modCount++</p>
</li>
<li><p>return true</p>
</li>
</ul>
</li>
<li><p>clear()</p>
<ul>
<li>遍历<ul>
<li>先取得当前节点的next节点</li>
<li>然后当前节点的所有属性置为 null</li>
<li>x &#x3D; next</li>
</ul>
</li>
<li>first &#x3D; last &#x3D; null</li>
<li>size &#x3D; 0</li>
<li>modCount++</li>
</ul>
</li>
<li><p>indexOf(Object o)</p>
<ul>
<li>定义一个index &#x3D; 0</li>
<li>判断 o 是否为 null <ul>
<li>为 null，遍历时走 &#x3D;&#x3D; 判断</li>
<li>不为 null，遍历时走 equals判断</li>
</ul>
</li>
<li>找到返回index，找不到返回 -1</li>
</ul>
</li>
<li><p>lastIndexOf(Object o)</p>
<ul>
<li>定义一个index &#x3D; size</li>
<li>从后往前遍历，也是先判断 o 是否为 null 走不同的判断逻辑</li>
<li>找到返回index，找不到返回 -1</li>
</ul>
</li>
<li><p>peek()、peekFirst()、peekLast() </p>
<ul>
<li>定义一个常量 f 接收 first</li>
<li>如果 f 为 null 返回 null，不为 null 返回 f.item</li>
</ul>
</li>
<li><p>poll()、pollFirst()、pollLast()</p>
<ul>
<li>定义一个常量 f 接收 first</li>
<li>如果 f 为 null 返回 null，不为 null 返回 unlinkFirst(f)</li>
</ul>
</li>
<li><p>removeLastOccurrence(Object o)</p>
<ul>
<li><p>判断 o 是否为 null </p>
<ul>
<li>为 null，遍历时走 &#x3D;&#x3D; 判断</li>
<li>不为 null，遍历时走 equals判断</li>
</ul>
</li>
<li><p>找到用 unlink(x) 并返回true，找不到返回 false</p>
</li>
</ul>
</li>
<li><p>element()</p>
<ul>
<li>调用 getFirst()</li>
</ul>
</li>
<li><p>remove()</p>
<ul>
<li>调用 removeFirst()</li>
</ul>
</li>
<li><p>offer(E e)</p>
<ul>
<li>add(e)</li>
</ul>
</li>
<li><p>offerLast(E e)</p>
<ul>
<li>调用 addLast(e)</li>
<li>返回 true</li>
</ul>
</li>
<li><p>push(E e)</p>
<ul>
<li>调用 addFirst(e)</li>
</ul>
</li>
<li><p>pop()</p>
<ul>
<li>调用 removeFirst()</li>
</ul>
</li>
<li><p>removeFirstOccurrence(Object o)</p>
<ul>
<li>调用 remove(o)</li>
</ul>
</li>
</ul>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><ul>
<li>addFirst(E e)<ul>
<li>判断 e 是否为null，为 null 就抛异常</li>
<li>就是在 head 之前插入，插入后head-1<ul>
<li>elements [ head &#x3D; (head - 1) &amp; (elements.length - 1) ] &#x3D; e</li>
</ul>
</li>
<li>判断是否需要扩容， 如果 head &#x3D;&#x3D; tail 就需要扩容</li>
</ul>
</li>
<li>addLast(E e)<ul>
<li>判断 e 是否为null，为 null 就抛异常</li>
<li>就是在 tail 的位置插入，插入后 tail+1<ul>
<li>elements[tail] &#x3D; e</li>
</ul>
</li>
<li>判断下标是否越界，越界就要扩容<ul>
<li>( tail &#x3D; ( tail + 1 ) &amp; ( elements.length - 1) ) &#x3D;&#x3D; head，为 true 就要扩容</li>
</ul>
</li>
</ul>
</li>
<li>doubleCapacity()<ul>
<li>只有在 head &#x3D;&#x3D; tail 的时候才需要扩容，源码中用 assert 判断，不满足条件则抛AssertionError异常</li>
<li>保存 head 的值（下标） p，数组的长度 n</li>
<li>计算 head 右边元素的个数 r &#x3D; n - p</li>
<li>计算扩容后的数组大小 newCapacity &#x3D; n &lt;&lt; 1，如果 newCapacity &lt; 0 则抛IllegalStateException异常 （就是太大了，超出in最大值就会变负数）</li>
<li>根据 newCapacity 创建一个新数组</li>
<li>将旧数组的值复制到新数组 a，分两步复制<ul>
<li>先复制 head 右边的数据到新数组</li>
<li>再复制 head 左边的数据到新数组</li>
</ul>
</li>
<li>将 elements 替换为新数组 a</li>
<li>head &#x3D; 0，tail &#x3D; n</li>
</ul>
</li>
<li>pollFirst()<ul>
<li>取得 head 位置的值 result</li>
<li>判断是否为 null，为 null 则说明数组为 null ，直接返回 null</li>
<li>将 head 位置的值置为 null</li>
<li>更新 head<ul>
<li>head &#x3D; (head + 1) &amp; (elements.length - 1)</li>
</ul>
</li>
<li>返回 result</li>
</ul>
</li>
<li>pollLast()<ul>
<li>获得 tial 前一位的值 t<ul>
<li>t &#x3D; (tail - 1) &amp; (elements.length - 1)</li>
</ul>
</li>
<li>取得 t 位置上的值 result</li>
<li>判断  result  是否为 null，为 null 则说明数组为 null ，直接返回 null</li>
<li>将 t 位置上的值置为 null</li>
<li>更新 tail<ul>
<li>tail &#x3D; t</li>
</ul>
</li>
<li>返回 result</li>
</ul>
</li>
<li>peekFirst()<ul>
<li>返回 elements[head] 的值</li>
</ul>
</li>
<li>peekLast()<ul>
<li>返回 elements[(tail - 1) &amp; (elements.length - 1)] 的值</li>
</ul>
</li>
</ul>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><ul>
<li><p>add(E e)、offer(E e)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)<span class="comment">//不允许放入null元素</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>siftUp(int k, E x)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];<span class="comment">//取得父节点的值e</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// x 大于 e 则不用交换了，直接退出</span></span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>element()、peek()</p>
<ul>
<li>如果 size &#x3D;  0，返回 null</li>
<li>返回 (E) queue[ 0 ]</li>
</ul>
</li>
<li><p>remove()、poll()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) queue[s];</span><br><span class="line">    queue[s] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>siftDown(int k, E x)</p>
<ul>
<li><p>得到 size 的一半 half</p>
</li>
<li><p>循环 k &lt; half </p>
<ul>
<li>得到左孩子的下标  child &#x3D; (k &lt;&lt; 1) + 1</li>
<li>得到左孩子下标对应的值 c</li>
<li>得到右孩子的下标 right &#x3D; child + 1</li>
<li>如果 right &lt; size 并且 c &gt; queue[right]，则 c &#x3D; queue[child &#x3D; right]，就是找左右孩子小的那一个</li>
<li>如果 x &lt; c 退出循环</li>
<li>queue[k] &#x3D; c，因为 x &gt; c</li>
<li>交换后从 k &#x3D; child</li>
</ul>
</li>
<li><p>queue[ k ] &#x3D; x</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">    	<span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove(Object o)</p>
<ul>
<li><p>遍历数组找到符合值的下标 i &#x3D; indexOf(o)</p>
</li>
<li><p>如果 i &#x3D; -1 ，返回 false</p>
</li>
<li><p>得到数组最后一个元素的下标 s &#x3D; –size</p>
</li>
<li><p>如果 s &#x3D;&#x3D; i，说明要删除的是最后一个元素，则 queue[i] &#x3D; null</p>
</li>
<li><p>s !&#x3D; i</p>
<ul>
<li>取出数组最后一个元素的值 moved</li>
<li>queue[ s ] &#x3D; null</li>
<li>siftDown(i, moved)</li>
</ul>
</li>
<li><p>返回 true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">moved</span> <span class="operator">=</span> (E) queue[s];</span><br><span class="line">        queue[s] = <span class="literal">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ul>
<li><p>get() 与hashmap的get方法几乎一致</p>
</li>
<li><p>addEntry(int hash, K key, V value, int bucketIndex)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="built_in">this</span>;</span><br><span class="line">    after.before = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>removeEntryForKey(Object key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">removeEntryForKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></span><br><span class="line">            e.before.after = e.after;</span><br><span class="line">            e.after.before = e.before;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="源码-1-8"><a href="#源码-1-8" class="headerlink" title="源码 1.8"></a>源码 1.8</h4><ul>
<li><p>put( K key, V value )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>putVal( int hash, K key, V value, boolean onlyIfAbsent, boolean evict )</p>
<ul>
<li><p>判断 p 是否和要插入的 key 相等，这个 p 是这个位置上的第一个元素</p>
<ul>
<li>相等则用 e 接收这个节点（保留）</li>
<li>不相等判断 p 是不是树节点<ul>
<li>是树节点，调用红黑树的插入 ( ( TreeNode&lt;K,V&gt; ) p ).putTreeVal( this, tab, hash, key, value )，并用 e 接收返回值</li>
<li>是链表节点<ul>
<li>遍历链表节点<ul>
<li>用 e 接收 p.next，判断 e 是否为null<ul>
<li>为 null 直接插入p.next</li>
<li>如果链表长度大于等于8，则需要转化为红黑树，调用 treeifyBin(tab, hash)，跳出循环</li>
</ul>
</li>
<li>如果在该链表中找到了相等的 key (&#x3D;&#x3D; 或 equals)，跳出循环</li>
<li>p &#x3D; e</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果 e !&#x3D; null，说明存在旧值的key与要插入的key相等<ul>
<li>取得 e.value 为 oldValue</li>
<li>覆盖旧值 e.value &#x3D; value</li>
<li>返回旧值 oldValue</li>
</ul>
</li>
</ul>
</li>
<li><p>++modCount</p>
</li>
<li><p>如果因为插值 size &gt; 扩容阈值，就执行扩容 resize()</p>
</li>
<li><p>返回 null</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个 tab 接收数组，p 接收下标的第一个元素，n 接收数组长度，i 接收下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发扩容，0 -&gt; 16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// pqu如果p为 null，说明该位置还没有值，直接插入即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 数组该位置有数据</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//局部变量e储存插入的位置，k储存p的</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>resize()</p>
<ul>
<li><p>定义一个节点数组保存原始数据 oldTab</p>
</li>
<li><p>定义一个 oldCap 保存旧数组容量，oldThr 保存旧阈值，定义 newCap, newThr 为 0</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 使用指定容量的构造函数创建时，因为没put所以 oldCap&lt;=0</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 使用无参构造函数创建并第一次put的时候</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果走了上面第一个if 中的 if 和 第一个 if 的else if 时</span></span><br><span class="line"><span class="comment">//newThr是没有值的，所以需要赋值，需要判断是哪一种情况</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">threshold = newThr;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建新数组并转移数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用新的数组大小初始化新的数组</span></span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"><span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 第一条链表</span></span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>get(Object key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> getNode(hash(key), key) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value</span><br></pre></td></tr></table></figure>
</li>
<li><p>getNode(int hash, Object key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//表不为空，长度大于0，下标处有值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;  ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//大于一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125;<span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><ul>
<li><p>左旋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		p                         pr(r)</span></span><br><span class="line"><span class="comment">	   / \                        / \</span></span><br><span class="line"><span class="comment">	 pl   pr(r)       ==&gt;        p   rr</span></span><br><span class="line"><span class="comment">	      / \                   / \</span></span><br><span class="line"><span class="comment">	    rl   rr               pl  rl</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="literal">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右旋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		p                         pl(l)</span></span><br><span class="line"><span class="comment">	   /  \                        / \</span></span><br><span class="line"><span class="comment">   (l)pl   pr       ==&gt;          ll   p</span></span><br><span class="line"><span class="comment">	/ \                              / \</span></span><br><span class="line"><span class="comment">  ll   lr                           lr  pr</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="literal">null</span>) </span><br><span class="line">            l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寻找节点后继</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; <span class="title function_">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素，即最左的元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先，即parent.right = t的</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>get</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)<span class="comment">//不允许key值为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>put()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    Entry&lt;K,V&gt; t = <span class="built_in">this</span>.root;</span><br><span class="line">    <span class="comment">//如果根节点为null，当前节点直接作为根节点</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent; <span class="comment">//定义一个父亲节点</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key); <span class="comment">//与当前值比较大小</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找 插入的值小于当前值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找 插入的值大于当前值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value); <span class="comment">//当前值等于插入值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>); <span class="comment">//非叶子节点</span></span><br><span class="line">    <span class="comment">//到达叶子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);<span class="comment">//创建并插入新的entry</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);<span class="comment">//调整（旋转和变色）</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整插入的情况</span></span><br><span class="line"><span class="comment">/*         左三               右三                     3树左                     3树右</span></span><br><span class="line"><span class="comment">			a（黑）         a（黑）                    a（黑）                  a（黑）</span></span><br><span class="line"><span class="comment">	   	   /                 \                       /   \                     /   \</span></span><br><span class="line"><span class="comment">	 	 b（红）               b（红）            b（红） c（红）            b（红）  c（红）</span></span><br><span class="line"><span class="comment">    	/                       \                 /                                   \</span></span><br><span class="line"><span class="comment">   	   x（红）                    x（红）        x（红）                                x（红）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.color = RED;<span class="comment">//新插入的节点都是红色的</span></span><br><span class="line">    <span class="comment">//父节点为红色时需要调整</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">//x的父节点是爷爷节点的左节点（处理左三和3树左的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">//取出父亲节点的父亲节点的右节点（叔叔节点）</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//判断是否是3树左，如果叔叔节点为空是false，不为空则是3树左的情况</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">//x的父亲设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">//叔叔节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">//爷爷节点设置为红色</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">//x指向爷爷节点，如果爷爷节点的父节点也是红接着处理</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//左3</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//x是父节点的右节点（非完全左3），需要先左旋为左3，再右旋</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       </span><br><span class="line">                    rotateLeft(x);                        <span class="comment">//在旋转时会改回父子间的指向</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x是父节点的左节点</span></span><br><span class="line">                setColor(parentOf(x), BLACK);             <span class="comment">//x的父亲设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);     <span class="comment">//爷爷节点设置为红色</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));       <span class="comment">//右旋 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//x的父节点是爷爷节点的右节点（处理右三和3树右的情况）</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//取出父亲节点的父亲节点的左节点（叔叔节点）</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//判断是否是3树右，如果叔叔节点为空是false，不为空则是3树右的情况</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">//x的父亲设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">//叔叔节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">//爷爷节点设置为红色</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">//x指向爷爷节点，如果爷爷节点的父节点也是红接着处理</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//右3</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//x是父节点的左节点（非完全右3），需要先右旋为右3，再左旋</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       </span><br><span class="line">                    rotateRight(x);                        <span class="comment">//在旋转时会改回父子间的指向</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">//x的父亲设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">//爷爷节点设置为红色</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">//左旋 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;			<span class="comment">//根节点必须为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	删除的情况：</span></span><br><span class="line"><span class="comment">		1.删除节点是叶子节点，直接删除</span></span><br><span class="line"><span class="comment">		2.删除节点有左孩子或者右孩子，删除节点后让其左孩子或右孩子指向向删除节点的父节点</span></span><br><span class="line"><span class="comment">		3.删除节点有左右孩子节点，需要找到当前节点的后继节点，替代当前节点                    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//情况3，将其转换成情况2来处理</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="literal">null</span> &amp;&amp; p.right != <span class="literal">null</span>) </span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s; <span class="comment">//p指向它的后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//情况2</span></span><br><span class="line">	<span class="comment">//有左孩子取左孩子，没有就取右（因为我们找的是后继节点，是不会有左孩子的，但源码为了代码健壮性）</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="literal">null</span> ? p.left : p.right);</span><br><span class="line">	<span class="comment">//有右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//左孩子或右孩子指向向删除节点的父节点</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) <span class="comment">//父节点为空说明是根节点，直接替换</span></span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left) <span class="comment">//是父节点的左孩子，重新修改指向</span></span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">//是父节点的右孩子，重新修改指向</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>; <span class="comment">//被删除的节点的引用全部置为null，gc处理</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)			 <span class="comment">//如果删除节点的颜色为黑色需要进行调整</span></span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; </span><br><span class="line">	<span class="comment">//无左右孩子且父节点为null，即删除的节点是根节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="literal">null</span>;	      </span><br><span class="line">    &#125; </span><br><span class="line">	<span class="comment">//情况1</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="literal">null</span>;</span><br><span class="line">            p.parent = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	情况1：被删除的节点有左右孩子的节点，需要通过改变节点指向和变色就可以解决的</span></span><br><span class="line"><span class="comment">	情况2：被删除的节点无左右孩子的节点，用父亲节点替代，再用一个兄弟节点的子节点替代父亲节点</span></span><br><span class="line"><span class="comment">		情况2.1：兄弟节点有一个孩子，旋转成有右孩子的情况，在进行左旋</span></span><br><span class="line"><span class="comment">		情况2.2：兄弟节点有两个孩子，直接进行左旋</span></span><br><span class="line"><span class="comment">	情况3：被删除的节点无左右孩子的节点，用父亲节点替代，但是兄弟节点没有子节点可以替代父亲节点	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">//情况2，3</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="comment">//x是左孩子的情况</span></span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            <span class="comment">//找到x的兄弟节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="comment">//判断sib是否是x的兄弟节点，只有sib是黑色时才是兄弟节点，红色需要调整</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 兄弟变黑</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 兄弟父亲变红</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 左旋，将左孩子变成右孩子</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 修改找到真正的兄弟节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况3，兄弟节点无左右孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 设置兄弟节点为红色</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 删除的节点指向x的父亲，递归条件</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//情况2，兄弟节点有一个或俩个子节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有右孩子，需要右旋为有左孩子的情况</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 将兄弟节点的左节点变黑</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 将兄弟节点变红</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 右旋</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 兄弟节点重新指向为父亲节点的右节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 兄弟节点要变成父亲节点的颜色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 父亲节点变黑</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 兄弟节点的右孩子变黑</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 左旋</span></span><br><span class="line">                x = root;                               <span class="comment">// 结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//x是右孩子的情况，不会出现这种可能</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// </span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// </span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// </span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// </span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// </span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// </span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// </span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// </span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// </span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// </span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// </span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// </span></span><br><span class="line">                x = root;                               <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况1，变黑，指向在前面已经修改完毕了</span></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="CallerSensitive"><a href="#CallerSensitive" class="headerlink" title="@CallerSensitive"></a>@CallerSensitive</h3><ul>
<li>该注解标注的方法为危险方法，调用该注解标注的方法的对象必须也需要有该注解，且改对象必须有启动类加载</li>
<li>开发者自己写的@CallerSensitive不可被识别即无法调用该危险方法</li>
<li>可以通过jvm参数 <code>-Xbootclasspath/a: path</code> 伪装为启动类</li>
</ul>
<h3 id="FunctionInterface"><a href="#FunctionInterface" class="headerlink" title="@FunctionInterface"></a>@FunctionInterface</h3><ul>
<li>接口中只有一个抽象方法，即可搭配lamda表达式使用</li>
</ul>
<h3 id="Contended"><a href="#Contended" class="headerlink" title="@Contended"></a>@Contended</h3><ul>
<li>防止缓存行，伪共享</li>
<li>对齐填充，因为一个缓存行是64字节，当读取的目标数据小于64字节时，可以填充一些无意义的数据使其字节接近或达到64字节，这样就可以使一个缓存行只被一个线程所持有</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E6%BA%90%E7%A0%81/JDK/" data-id="clrj8pzxx008s6wuwaq1vem01" data-title="JDK源码" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E6%BA%90%E7%A0%81/MyBatis/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          MyBatis源码
        
      </div>
    </a>
  
  
    <a href="/2024/01/18/Note/%E5%90%8E%E7%AB%AF/Java/%E6%A8%A1%E5%9D%97/%E6%90%9C%E7%B4%A2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">搜索</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E4%B8%AD%E9%97%B4%E4%BB%B6/">Java中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A1%86%E6%9E%B6/">Java框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web3/">Web3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3/">力扣</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A8%A1%E5%9D%97/">模块</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/">计算机知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/defi/" rel="tag">defi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/language/" rel="tag">language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solidity/" rel="tag">solidity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web3/" rel="tag">web3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" rel="tag">代码随想录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%A2%98100/" rel="tag">力扣热题100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%9B%E6%89%A3%E9%A2%98/" rel="tag">力扣题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%A5%9E/" rel="tag">左神</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%93/" rel="tag">库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag">技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97/" rel="tag">模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B/" rel="tag">模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E5%BF%B5/" rel="tag">理念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9Fan-quan/" rel="tag">系统an&#39;quan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" rel="tag">系统设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%84%E8%8C%83/" rel="tag">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E6%88%90/" rel="tag">集成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E7%BE%A4/" rel="tag">集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/defi/" style="font-size: 10px;">defi</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/language/" style="font-size: 10px;">language</a> <a href="/tags/solidity/" style="font-size: 10px;">solidity</a> <a href="/tags/web3/" style="font-size: 12.86px;">web3</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 20px;">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 10px;">代码随想录</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 10px;">优化</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 10px;">剑指offer</a> <a href="/tags/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%A2%98100/" style="font-size: 10px;">力扣热题100</a> <a href="/tags/%E5%8A%9B%E6%89%A3%E9%A2%98/" style="font-size: 10px;">力扣题</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">基础</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E5%B7%A6%E7%A5%9E/" style="font-size: 10px;">左神</a> <a href="/tags/%E5%BA%93/" style="font-size: 10px;">库</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 18.57px;">开发</a> <a href="/tags/%E6%8A%80%E5%B7%A7/" style="font-size: 11.43px;">技巧</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12.86px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" style="font-size: 17.14px;">数据结构和算法</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 14.29px;">框架</a> <a href="/tags/%E6%A8%A1%E5%9D%97/" style="font-size: 15.71px;">模块</a> <a href="/tags/%E6%A8%A1%E5%9E%8B/" style="font-size: 11.43px;">模型</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 12.86px;">源码</a> <a href="/tags/%E7%90%86%E5%BF%B5/" style="font-size: 14.29px;">理念</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9Fan-quan/" style="font-size: 10px;">系统an'quan</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">系统设计</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E8%A7%84%E8%8C%83/" style="font-size: 10px;">规范</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a> <a href="/tags/%E9%9B%86%E6%88%90/" style="font-size: 10px;">集成</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 10px;">集群</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 12.86px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E8%8B%B1%E8%AF%AD/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E5%9C%BA%E6%99%AF%E9%A2%98/">场景题</a>
          </li>
        
          <li>
            <a href="/2024/01/18/Note/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 JianHong<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>