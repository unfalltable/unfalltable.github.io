[{"title":"计算机基础","path":"/2024/01/18/Note/面试/计算机基础/","content":"计算机网络 http和rpc的区别 http的缓存机制 https如何保证安全传输 tcp滑动窗口，三次握手 HTTPS是怎么保证安全的 DNS协议 tcp和udp的区别 对称加密 VLAN 操作系统 进程、线程、协程 进程 线程 协程 分配系统资源 分配cpu 分配线程资源 内存独立 内存共享 内存共享 问题 僵尸、孤儿进程 死锁 不能调用阻塞操作 特点 相互隔离、通讯效率低，切换开销大 多线程、通讯效率高，切换开销小 不用锁、效率极高、切换开销极小，占用内存小 通信 mq、信号量、socket、共享内存 volatile、wait&#x2F;notify、ThreadLocal 同步 互斥、条件变量、锁、信号量 并发、并行 并发 并行 组成 进程管理、存储管理、设备管理、文件管理、程序接口、用户界面 成员变量和静态变量是否是线程安全的？ 没有共享则安全 如果共享了 如果只有读操作，则线程安全 如果有写操作，则需要考虑线程安全 局部变量是否线程安全？ 局部变量是线程安全的 但是引用局部变量的对象则有可能出现线程安全问题 如果该引用对象没有逃离方法的作用域，则线程安全 逃离了则需要保证线程安全 多线程解决什么问题？本质是什么？ 由于cpu、缓存、io设备之间的速度有极大的差异，为了合理使用cpu的高性能，平衡三者的差异，主要体现在 cpu增加了缓存，均衡cpu与内存（导致可见性问题） 操作系统增加了进程线程，分时复用，均衡cpu与IO（导致原子性问题） 编译程序优化指令执行次序，重排序（导致有序性问题） 什么是多线程的上下文切换 死锁 发生原因 如何避免 线程安全 如何理解","tags":["面试"],"categories":["面试"]},{"title":"场景题","path":"/2024/01/18/Note/面试/场景题/","content":"QQ号如何保证申请不重复 使用类似布隆过滤器的机制实现判断qq是否存在 查询年龄大于16岁，性别为女，注册日期范围为2019年的人数，复合索索引怎么建？ 500w多万数据，qps很高的情况下查询慢怎么解决 放redis也依旧很热怎么处理 计算100的阶乘 假设日志文件记录每个接口请求耗时，怎么快速找到接口耗时＞500ms的请求？ 做SDK怎么提升性能 为什么分开部署比集中部署更消耗CPU 两个线程交替打印，请保证线程安全 用Semaphore实现，比较好，两个线程都可以正常结束，业务代码比较好写 可以将打印封装为一个对象，内部使用synchronized和wait()方法，通过参数控制交替打印 数据库有1000万数据，Redis只能缓存20w数据，怎么保证Redis中存的都是热点数据 使用allkeys-lru淘汰策略，留下的都是经常访问的热点数据 1~2亿数据如何缓存 需要使用Redis分布式集群 负载均衡策略有 哈希取余分区 哈希环 哈希插槽 某搜索公司每天的用户搜索是海量的，求top100热词 hash分流成小文件，各个小文件自身构建大顶堆，拿出各个文件大顶堆堆顶，组成全局大顶堆，弹出堆顶，把堆顶下的再加入全局大顶堆 40亿个无符号整数，找出在0 ~ 2^32^ - 1(4294967295) 范围中没出现的数 最多使用1GB内存 使用一个 2^32^ &#x2F; 8大小的 byte数组约500MB 遍历40亿个数，出现的为1，没出现的为0 最多使用3kb内存，但只要找到一个没出现的数即可 3kb如果用来创建整形数组，最大可以创建768大小的数组 我们创建一个512大小的数组即可 遍历40亿个数，将每个数除于 2^32^ &#x2F; 512（8388608） 然后将对应的数组下标++，最后不够8388608的区间就是没出现的所在区间 在不够的区间再分成512份继续以上操作 最多使用有限的变量，找到一个没出现的数 将40亿数据二分，哪边没满 2^32^ &#x2F; 2 的继续二分 现有1T的数据，内存只有1G，该怎么对他们进行排序 申请1g可以创建的接近2的次方的大根堆，遍历1t的数据，记录小的记录，输出到结果文件上 现有40亿条数据，内存只有1G，找出现次数最多的数 将这40亿条数据用hash算法算出其hash值，然后模上100 将取模后值相等的数放在同一个文件下 再用hash表将这100给文件进行排序找出出现次数最大的数 这样得到100个各个文件出现次数最大的数 再排序这100个数得到出现次数最大的数 1000W数据入库，实时返回成功条数 分片读取到内存，对数据进行检验，利用多线程批量入库","tags":["面试"],"categories":["面试"]},{"path":"/2024/01/18/Note/面试/数据库/","content":"MySQL count(*)、count(1)、count(字段) 对比 索引 失效情况 索引下推 自增id和uuid的区别 连接查询 on 条件判断类型不同怎么判断 in查询参数太多怎么办 创建临时表，in后接子查询该临时表 InnoDB、MyISAM、Memory区别 InnoDB如何解决幻读问题 间隙锁和临键锁 一条sql的执行过程 B+tree的能存放的数据有多少 假设一行数据的大小为1k，一个结点可以存放16行这样的数据，InnoDB的指针占6字节，主键假设为bigint，占用8字节 高度2：即一个主键，第二层都是叶子结点 n * 8 + (n + 1) * 6 &#x3D; 16 * 1024 n &#x3D; 1170 1171 * 16 &#x3D; 18736 高度3： 1171 * 1171 * 16 &#x3D; 21939856 查询计划 定位慢查询 B数和B+树的区别 redo log 两阶段提交过程 MySQL三种log日志以及作用 开启事务的完整过程 数据库三范式是什么 第一范式：属性不可再分割 第二范式：有主键，而且其他字段要依赖主键 第三范式：消除传递依赖 悲观锁和乐观锁 悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。 乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量 树形表如何查询 树形表一般都会建立一个标记字段，例如parent_id 使用表的自链接查询，向下递归 1select * from t t1 inner join t t2 on t1.id = t2.parent_id 向上递归 123456with recursive t1 as&#123;\tselect * from t t2 where id = &#x27;1-1-1&#x27;\tunion all select t3.* from t t3 inner join t1 on t1.parent_id = t3.id&#125;select * from t1 order by t1.id 最左前缀法则怎么优化order by 只传入必要的查询字段、过滤字段、排序字段，并为这些字段建立索引 MVCC 实现 可重复读 怎么实现 出现幻读的情况 更新一个查不到的数据 一个查（没用for update），一个加，再查就幻读了 用for update 避免 Next Key Lock（行锁+间隙锁） 底层 锁一个记录的一个范围 前开后闭 先加间隙锁，然后才加行锁 对非索引字段的加间隙锁，会导致锁表 主从延迟 怎么解决 设置延迟读取 忍受大法 数据库同步写方案 选择性强制读主 中间件选择路由法 缓存路由大法 undo log binlog BufferPool 如何管理Page页 ChangeBuffer 为什么仅适用于非唯一普通索引 当前读和快照读 锁 行锁、表锁、页锁 读锁、写锁 乐观锁、悲观锁 共享锁、排他锁 Redis 哪些场景使用了Redis Redis内存用完了会发生什么 不同的内存淘汰策略会发生的情况不同 如何保证缓存与数据库一致性 redis防止表单重复提交是怎么实现的 Redis内存满了 &#x2F; 内存不够用"},{"title":"中间件","path":"/2024/01/18/Note/面试/中间件/","content":"WEB 简述一下伪共享的概念以及如何避免 是什么 怎么解决 @Contended，除了需要的内容之外用无意义的数据填充缓存行 okhttp如何处理网络缓存的 epoll和poll的区别 BIO&#x2F;NIO&#x2F;IO多路复用 BIO有什么缺陷 针对C10K这样的需求，NIO靠什么解决 NIO的选择器selector可以做到一个线程监听多个socket 多路复用操作系统函数select()的工作原理 准备需要监听的socket集合，用一个rset保存socketId 调用select函数会涉及到用户态和内核态的切换 还需要复制rset集合到内核态 循环监听rset中记录的socket，有就绪的就将其对应的rset位置位 然后把内核态的rset复制到用户态中去 select()默认监听socket的数量为什么是1024 select()第一遍O(n)未发现就绪的socket，如果后续某一个socket就绪后。select是如何感知的？是不停的轮询吗 第一遍未发现就绪的socket后，会将当前线程保留到每个需要监听的socket的等待队列中 然后当前线程从工作队列中移除 这时客户端向服务端发送了数据，数据通过网线到网卡，网卡的DMA将数据写进内存，数据传输结束后会触发网络传输完毕中断程序，cpu会将当前正在运行的线程挂起然后执行这个中断程序的逻辑 根据内存中的数据包分析出是哪个socket的数据，而且tcp&#x2F;ip协议传输的数据包是有端口号的，这样就能找到对应的socket实例 然后数据导入到socket的读缓冲区，然后会检查socket的等待队列，有等待的队列就将其加入cpu工作队列 然后select函数又会执行了，就能发现就绪的socket了 poll()和select()主要区别是什么 参数不一样 select用的是bitmap，长度是1024 poll使用的数组，长度很大 数组中的结构是pollfd，里面是fd、events、revents 为什么会有epoll这个技术，产生的背景是 为了解决select和poll的缺陷 用户态和内核态频繁切换 不能反映是哪个socket就绪了，每次需要遍历判断 epoll的工作原理是 epoll_create 在内核态创建一个eventpoll对象 eventpoll对象的就绪列表数据是如何维护的呢 需要先描述一遍将socket加入epoll对象监听列表的过程 当有socket进入就绪队列后，会检查epoll对象的等待队列 如果等待队列中有进程，则将其加入cpu工作队列 epoll怎么得知哪些socket是就绪的 epoll_wait中会传入一个epoll_events 并将其置为1，然后拷贝到数组指针中，然后将这个数组返回给用户空间 epoll_wait可以设置为非阻塞吗 默认是阻塞的 调用时可以传入参数来设置 设置为0就是非阻塞的 eventpoll对象中存放需要检查的socket信息是采用的什么数据结构？为什么 红黑树，因为经常有增删改，稳定的O(logN) epoll往监听事件列表中添加一个新事件过程 内核程序会把当前eventpoll对象追加到socket的等待队列中 socket接收完客户端发送的数据后触发中断程序 根据内存中的数据找到对应的socket的读缓冲区，发现等待队列中的是一个eventpoll对象引用 然后会将当前socket的引用加入到epoll对象的监听列表末尾 MQ RabbitMQ RocketMQ Kafka 优点 消息可靠性高，功能全面，性能好，高并发 高吞吐、高性能、高可用、功能齐全 吞吐量大，性能好，集群高可用 缺点 消息堆积影响性能，erlang不好定制 生态不成熟、只支持Java 数据丢失，功能单一 吞吐量 万级 十万级 百万级 速度 微秒级 毫秒级 毫秒级 使用场景 大部分场景 全场景 日志分析，大数据采集 为什么使用消息队列 解耦： 数据需要多方使用时，如果直接调用对应的服务，耦合度较高，而且扩展&#x2F;剔除不方便，还要确认消息是否重发，是否持久化 有MQ时，数据发送方只需要将数据发送到mq中，哪个服务需要就去mq中取即可 通过mq就将数据发送方跟其他系统解耦了 异步 提高系统的响应速度和吞吐量，不用等到结果就可以提前响应 削峰 以稳定的系统资源应对突发的流量冲击 使用消息队列的缺点 系统可用性降低，MQ宕机，整个业务都会影响 系统的复杂度提高 一致性问题 如何保证消息队列的高可用 RabbitMQ 镜像集群模式 Kafka 副本机制 如何设计一个MQ 首先需要设计一个先进先出FIFO的数据结构，高效，可扩展 扩展为分布式队列，分布式集群管理 基于Topic定制消息路由策略，发送者路由策略，消费者与对列的对应关系，消费者路由策略 实现高效的网络通信，Http 规划日志文件，实现文件高效读写，零拷贝，顺序写（性能高），服务重启快速恢复 死信队列，延迟队列、事务消息 如何保证消息可靠传输 保证消息不能重复 消费者端实现幂等性 每个消息带一个有业务标识的ID，来进行幂等判断，或者使用全局唯一ID RocketMQ可以给每个消息分配了一个MessaheID，但是不太好 保证消息不能丢失 主从间信息同步时 同步同步、两阶段提交（RocketMQ） 镜像集群（RabbitMQ） 生产者发送消息给MQ时 消息发送+回调（kafka、RocketMQ、RabbitMQ） 事务消息机制（RocketMQ） 会先发送一个half消息测试MQ是否有问题 Commit：推送实际消息 RollBack：丢弃该消息 UnKnow：回查，默认15次 手动事务机制、Publisher Comfirm（类似RocketMQ事务消息机制）（RabbitMQ） 事务属于同步机制，对性能影响较大 Comfirm属于异步机制，性能较好（一般使用这个） 有同步、批量、异步等模式 消费者获取MQ消息时 得先关闭MQ的自动ACK确认（RabbitMQ） 保证消费者真正消费之后才删除消息，消费端ACK 不采用异步消费即可 MQ自身接受消息时 保证确实收到并持久化消息，再进行ACK确认 MQ宕机重新选举时可能会丢数据（Kafka） 同步刷盘（RocketMQ） 持久化队列、Quorum（RabbitMQ） 如何保证消息的顺序消费 乱序的原因 消费者端没有顺序的进行消息的消费（RabbitMQ） 消费者多线程的消费消息（Kafka） 一个topic中有多个队列，消息会因为负载均衡保存在不同的队列中 解决方法 生产者 保证一类消息都放在一个队列上 在Producer发消息时注入一个消息队列选择器（MessageQueueSelector）对象 消费者 消费者一次消费整个队列中的消息 Consumer需要注册消息监听，传入MessageQueueOrderly对象 123456consumer.registerMessageListener(new MessageQueueOrderly()&#123; @Overide public ConsumerOrderlyStatus comsumeMessage(List&lt;MessageExt&gt; msgs, ConsumerOrderlyContext context)&#123; &#125;&#125;); RabbitMq 要保证目标exchange只对应一个队列，并且一个队列只对应一个消费者 消费者不直接消费消息，取消息存进一个队列中，再消费 Kafka 生产者通过定制partition分配规则，将相同key的消息分配到同一个partition 如何解决消息积压 熔断隔离、灰度发布、优化线程池配置、消息转发 临时紧急扩容，具体操作步骤和思路如下： 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 队列 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的队列中。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息 RocketMQ 提高消费并行度 批量消费消息 跳过非重要的消息 优化消息消费的过程 MQ消息过期失效 RabbitMQ 可以设置过期时间，如果此时出现消息积压就会丢失大量消息 过期失效的消息只能批量重导了 Mybatis &#x2F; MybatisPlus if标签中的test 进行判断时，&#x3D;&#x3D; 两边的数据类型不同可以判断吗 可以判断，底层是使用的OGNL表达式来解析的，可以支持不同数据类型之间的比较 test后接单引号和双引号的区别 {}和${}的区别 ${}是properties文件种的变量占位符，可以用于标签属性值和sql内部，属于静态文本替换 {}是sql的参数占位符，mybatis会将sql中的#{}替换为？，在sql执行时会用PreparedStatement的set方法来赋值 序给sql中的？设置参数值，可以有效的防止sql注入","tags":["中间件","面试"],"categories":["面试"]},{"path":"/2024/01/18/Note/面试/Web3面试/","content":"区块链基础题 熟悉的框架有哪些 前端知识 链端工具（truffle、remix、hardhat 随机数 做不了绝对的随机数 随机再随机 使用chainlink获取随机数 没有预言机怎么办 利用平均价格 如何防止智能合约被薅羊毛，如何防止外部调用合约 代理合约 最近的热门赛道和项目 共识算法 公钥私钥 比特币问题 转账用户不在线，是否可以转账 可以 转账给不存在的用户可以吗 可以 私钥丢失怎么办 账号就没了 以太坊问题 以太坊中状态树、交易树、收据树的区别 状态树 交易树 收据树 内容 全部用户信息 当前区块交易信息 当前区块收据信息 以太坊中为什么要使用状态树 因为ETH有账户的性质，需要保存账户的信息 使用hash表的话 每次每次构建merkle tree时都需要维护账户信息，代价太大 使用比特币相同的merkle的话 账户更新复杂，查找效率低 因为需要维护账户信息，所以是否排序也是个问题 排序：插入代价较大 不排序：每个全节点的树结构的不唯一 以太坊中可以向不存在的地址转账吗 可以的 会修改链上状态的情况 写入状态变量。 激活事件。 创建其他合约。 使用selfdestruct. 通过调用发送以太币。 调用任何未标记view或pure的函数。 使用低级调用（low-level calls）。 使用包含某些操作码的内联汇编。 默克尔树 项目 NFT项目 安全问题 双花攻击 51%算力攻击"},{"path":"/2024/01/18/Note/面试/Java项目/","content":"Validator支持自定义检测注解吗 支持，需要 Validator字符串长度检测注解@Length如果传入null值会通过吗 会通过，因为只验证长度 MyBatisPlus填充器原理 如果使用子线程会走事务吗 不会，需要修改事务的传播行为才可以 MyBatis一对多分页异常处理 前端md5加密参数后端如何解密并顺序获取参数 将请求体解析到map中 MyBatis深度分页如何优化 springboot可以兼容老的spring项目吗 可以，使用@ImportResource注解导入配置文件 配置文件敏感信息加密 单点登录SSO怎么实现 JWT 权限认证如何实现 RBAC 上传数据的安全性怎么控制 加密 项目中棘手的问题 设计模式 生产问题 调优 组件封装 项目中的日志是如何采集的 ELK 常规采集，一天一采 订单超时取消 DelayQueue延迟队列 时间轮算法 数据库定时任务（如Quartz） Redis ZSet 实现 MQ 延时队列实现 Token的生成方式 使用JWT生成 Header、payload、signature 用设备号&#x2F;设备mac地址作为Token(推荐) 缺点是客户端需要带设备号&#x2F;mac地址作为参数传递，而且服务器端还需要保存 优点是客户端不需重新登录，只要登录一次以后一直可以使用 用session值作为Token 缺点就是当session过期后，客户端必须重新登录才能进行访问数据 优点是方便，实现简单"},{"title":"基础题","path":"/2024/01/18/Note/面试/Java基础题/","content":"JavaSE 谈谈你对面向对象的理解 定义 优缺点 设计模式七大原则 合成复用原则 类与类之间的关系 里氏替换原则 谈谈你对集合的理解 底层实现 区别 Set怎么实现去重 HashTable、HashMap、ConcurrentHashMap的区别 &#x3D;&#x3D; 和 equals 区别 创建对象的方法 异常相关 抽象类和接口 区别 Double运算有什么问题 问题 解决 多态的底层原理 动态绑定 怎么减少hash冲突 拉链法、开放寻址法、多哈希算法、一致性哈希算法 Fail-Fast和Fail-Safe new String(“aa”) 创建了多少个对象 a&#x3D;”123” 和 a &#x3D; new String(“123”)的区别 final原理 String、StringBuffer、StriBuilder 区别 用途 Volatile 作用 原理 集合 list set map queue 元素重复 √ × × null值 速度 底层 数组 map 哈希表 分类 ArrayList LinkedList ArrayDeque PriorityQueue BlockingQueue Vector HashSet LinkedHashSet HashMap HashTable ConcurrentHashMap LinkedHashMap TreeMap WeakHashMap 线程安全 不安全 安全 安全 无contains() 有contains() 有，等价为containsValue() 可null 不可null 不可null 二次hash 一次hash 二次hash 继承AbstractMap 继承Dictionary 继承AbstractMap 初始16 初始11 初始16 扩容 X2 扩容 X2 + 1 扩容 X2 创建时机 put时创建 构造时创建 put时创建 并发度 无 低（synchronized锁） 高（分段锁） 场景 键值的存储 LRU key的顺序取存储键值 HashMap 为什么用红黑树不用AVL树 红黑树何时退化为链表 树化阈值为什么是8 索引如何计算 为什么要进行二次hash 容量为何是2的n次幂 扩容后如何确定新位置 扩容一致为什么是0.75 多线程下存在什么问题 红黑树 特点 方法 Unsafe类 操作内存 cas 内存屏障 JVM JMM内存模型 为什么堆保存对象，栈保存函数参数这些 堆是由程序员手动申请和释放的，栈是由系统自动分配和回收的 JVM中堆保存对象是因为对象的大小和生命周期不确定，需要动态分配和管理 栈保存函数参数和局部变量是因为它们的大小和生命周期相对固定，可以由系统快速分配和回收 类加载机制 字节码文件的内容 类加载的过程 五个阶段、顺序开始、解析阶段开始时机是不确定的，为了支持动态绑定 垃圾回收 引用类型 垃圾回收算法 分代回收 触发老年代GC的时机 对象直接进入老年代的情况 垃圾收集器 CMS G1 可达性分析 三色标记法 优化手段 对象 组成 如何定位 对象的创建方式 字符串常量池 直接内存 动态绑定和静态绑定 类加载器 双亲委派模式 触发老年代GC的时机 对象进入老年代的情况 new Object() 在内存中占用多少字节 调优 对数据量大的任务和数据访问量大的任务怎么调优 JVM问题排查 系统正在运行的 jmap看JVM内存情况 jstack看线程运行情况，阻塞死锁等 jstat看垃圾回收状况 jvisualvm看 如果频繁fullgc但是又回收了大量对象的话 可能是因为对象比较大直接进入了老年代 可以调大年轻代的大小，让这些对象在minorgc时就回收掉 系统已经oom 看dump文件，用jvisualvm分析 JUC 创建线程的方式 四种，底层都是实现的runnable实现 线程的状态 从cpu和java两方面讲 守护线程和非守护线程 锁 什么是锁的可重入 不可重入锁 线程池中的worker工作线程，它继承了AQS实现了锁，这个锁是不可重入的，但是没用到 CAS 原理 优缺点 避免了线程挂起唤醒导致用户态和内核态之间的切换 自旋时间和次数过长比较占用cpu资源 可以像synchronized中的自旋优化一样解决这个问题 也可以像LongAdder的分段锁 ABA问题 虽然可以更新数据，但是不符合原子性 通过添加版本号解决AtomicStampReference volatile 作用 禁用cpu缓存，保证共享变量的可读性 保证代码的有序性 原理 禁用cpu缓存 sleep &#x2F; wait wait sleep 来源 Object的方法 Thread的方法 特点 会释放锁 不会释放锁 wait &#x2F; notify 为什么要写在 synchronized 代码 块中 wail实际上操作的是motor锁中的waitset队列 wait的作用是为了实现线程间的通信，那么就需要能接收到其他线程对共享变量的修改或者通知其他线程共享变量被修改了，synchronized可以保证一定的可见性，它会将修改过后的信息刷进内存中 Synchronize Synchronize 和 Lock 的区别 Synchronize Lock 来源 java关键字 juc接口 场景 竞争小，有很多优化 竞争大，自旋优化 特点 非公平锁，可重入，不可中断 公平锁&#x2F;非公平锁，可重入、可中断，多条件 时机 自动释放锁 手动申请和释放锁 作用对象 修饰方法、修饰类、代码块 修饰一块区域 阻塞 无法实现非阻塞竞争 youtryLock方法实现非阻塞竞争 性能 竞争小时好 竞争大时好些 升级 优化 为什么要优化 重量级锁每次加锁解锁都涉及到用户态和内核态之间的切换，性能影响大 LongAdder ReentrantLock 特性 原理 ReentrantReadWriteLock 中断原理 StampedLock Semaphore CountdownLatch CyclicBarrier ConcurrentHashMap 底层实现原理 1.8优化 ThreadLocal 是什么 ThreadLocal和Synchronized的区别 思路不同 索引的计算 累加常量1640531527 取模 ThreadLocalMap中的key为什么要设置为弱引用 &#x2F; 内存泄漏问题 key的内存泄露ThreadLocal已经通过弱引用解决了，但是还存在value的内存泄漏 推荐使用remove来释放值的内存，因为一般开发中会将ThreadLocal定义为静态final变量，为强引用，所以gc不会清理key CopyOnWriteArrayList AQS 理解 为什么采用双向链表 新线程加入队列时需要判断前驱节点的状态 线程在链表中需要自旋尝试竞争锁，此时需要判断自己是不是头节点 唤醒队列中的节点时为何从后往前 插入节点时插入队尾，新节点会指向队尾节点，但是队尾节点是指向null的，从前往后遍历的话可能会错过节点 取消节点时的指针更改也是先改前驱节点，再改后继节点，所以从后往前遍历可靠性会高一些 线程池 种类 参数 如何设置 很难控制任务类型，cpu密集型，io密集型，混合型 需要通过压测来参考 动态监控和修改线程池 状态 任务执行流程 创建线程流程 为什么要使用线程池 线程池用完了为什么一定要shutdown 源码中对线程启动是通过工作线程worker对象的start方法启动的，会在栈中创建一个线程栈 由于工作线程默认是不会销毁的，所以不会被gc回收 shutdown会将线程池从running状态改为shutdown，工作线程不会再阻塞读取队列 shutdownNow会改为stop状态 还会调用中断方法，将没有在执行任务的方法的中断标记设置为true 为什么要构建空任务的救急线程 避免阻塞队列中的任务因为线程池中没有工作队列，也没有新任务进来创建新的工作线程导致的饥饿问题 线程池是运行设置核心线程数为0的 工作线程被设置了超时，一个任务进入队列时工作线程刚好超时 所以线程池会在任务进入阻塞队列时判断工作线程是否为0，为0创建空任务的救急线程 在execute方法中当任务进入阻塞队列时，判断当前工作线程是否为0，为0创建一个救急线程 线程池如何知道线程的任务已经完成 使用isTerminated方法，当任务都完成返回true，需要先调用shutdown方法和阻塞主线程（不推荐） 用submit执行线程，这种方式会有返回值，通过future.get()方法判断线程是否结束 使用getCompletedTaskCount方法判断 使用CountDownLatch判断，需要提前知道任务数且只能用一次 使用CyclicBarrier判断，可重复使用 Spring相关 spring的单例bean是线程安全的吗 spring的Bean生命周期 AOP 使用的场景 为什么JDK动态代理必须是接口 因为动态代理是通过Proxy.newProxyInstance()方法来实现的，这个方法需要传入被代理类的接口 之所以要传入接口，因为JDK动态代理的底层实现是通过生成一个代理类$Proxy0，这个代理类会继承Proxy类，同时实现被代理类实现的接口，而JDK代理设计的想法就是为了对代理对象的方法进行增强，本质上就是对其接口进行增强，为了体现设计模式中的依赖倒转原则 JDK和CGLIB的区别 事务 失效场景和原因 为什么只能作用在public修饰的方法上 事务的隔离级别 事务的传播行为 @Autowired 失效的情况 和@Resource的区别 @Autowired @Resource 作用 成员、方法 成员、方法 来源 spring提供 JDK提供 注入方式 byType，byName要结合@Qulifier 先byName再byType spring如何处理线程并发问题 ThreadLocal 声明为多例 syn &#x2F; juc 循环依赖 原因 解决 提前暴露对象，将对象的创建和初始化分开 只有一级 &#x2F; 二级缓存能解决吗 即半成平对象和成品对象都放到一个map中，需要在value上打标签，每次获取对象时要取出value判断，很麻烦 前提是整个循环引用过程中没有使用到aop 为什么使用AOP就需要有三级缓存 因为在同一时刻会同时存在原始对象和代理对象，而属性在赋值调用和对外暴露的时候，没办法确定是原始对象还是代理对象，所以我需要在第一次对外暴露的时候，通过一个lambda表达式。类似于回调机制的东西，来把最终版本对象返回回去 缓存的放置时间和删除时间 BeanFactory、ApplicationContext、FactoryBean BeanFactory ApplicationContext FactoryBean 延迟加载Bean 一开始就创建好Bean 用于快速创建Bean spring内部使用 内部间接调用Benfactory，扩展了新功能 BeanFactoryPostProcessor和BeanPostProcessor BeanFactoryPostProcessor BeanPostProcessor 对容器增强 对Bean增强 spring中使用到的设计模式 单例模式：单例Bean并不是实现了单例模式 原型模式：bean指定为prototype 工厂模式：BeanFactory 工厂方法模式：FactoryBean 模板模式：onRefresh、JDBC 策略模式：XmlBeanDefinitionReader、PropertiesBeanDefinitionReader 观察者模式：listner、event、multicast 适配器模式：HandlerAdapter、advice 装饰器模式：BeanWrapper 责任链模式：aop会生成拦截器链 代理模式：aop动态代理 建造器模式：Builder结尾的对象（BeanDefinitionBuilder） @Index 编译时生成一个需要加载的bean的文件，提升性能 @Import 将配置类加入容器 如果导入的类实现了ImportSelector接口，会调用接口声明的方法，该方法会返回类全路径 如果导入的类实现了ImportBeanDefinitionRegistrar接口，会调用接口声明的方法中提供的注册器来注入bean对象 SpringMVC 对MVC的理解 和spring的关系 父子容器关系，spring是父容器 mvc管理controller，spring管理service和dao 执行流程 springboot springboot中为什么引入stater就能有对应的功能 SPI机制 springboot自动装配 微服务分布式 微服务概念 分布式概念 Nacos Nacos和Eureka的区别 nacos配置中心动态刷新的原理 心跳机制机制 服务注册 服务表结构 底层的数据通信基于protocol buffer序列化协议，跨语言，跨平台 可以使用protoc转换类型 如何支持数十万服务压力 集群和负载均衡 Gateway 为什么要使用Gateway 接口的访问ip有变动的可能，由网关来实现服务路由 对请求的客户端进行鉴权 负载均衡、反向代理 隐藏真实请求路径 Feign Feign和OpenFeign的区别","tags":["面试"],"categories":["面试"]},{"title":"计算机网络","path":"/2024/01/18/Note/计算机知识/计算机网络/","content":"Http&#x2F;Https简介Http 超文本传输协议 本质是基于TCP协议通过80端口来传输数据 是一种允许浏览器向服务器获取资源的协议 Https 加密过程 HTTPS协议是由SSL&#x2F;TLS+HTTP协议构建的 采用了非对称加密+对称加密 服务端将公钥A发送给客户端，客户端生成一个密钥X，用公钥A加密后发送给服务端，服务端用密钥A解锁后获得密钥X，这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可 结构Http 起始行（Start Line） 请求包：请求方式（Get&#x2F;Post） + 请求路径（Url） + 版本（Http Version） 响应包：版本（Http Version）+ 状态码 + 状态描述（Reason） 头部（Header） Key-Value 空行（Crlf） 实体（Body） 请求包：数据 响应包：数据 请求流程Http 构建请求包 构建请求行，然后准备发起网络请求 查找缓存 发起网络请求之前，先在浏览器缓存中查询是否有要请求的文件 浏览器缓存是一种在保存在本地的资源副本 有缓存则拦截该请求并返回资源副本 没缓存则发起网络请求 准备IP地址和端口 DNS解析URL获取IP和端口信息 等待TCP队列 Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接 如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成 如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接 建立TCP连接 三次握手 发送HTTP请求 处理流程Http 响应请求，返回相应包 断开连接 如果开启了Keep-Alive则不会断开连接（长连接） 四次挥手断开连接 重定向 TCP&#x2F;UDP简介TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来 UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 一台服务机可同时向多个客户机传输相同的消息。 应用场景 TCP：发信息，文件传输 UDP：视频聊天，直播 区别 TCP有连接，UDP无连接 TCP一对一，UDP一对多 TCP包头的最小长度为20字节, UDP包头为8字节。 TCP面向连接，UDP面向报文 TCP保证数据正确性，UDP可能丢包 TCP保证数据顺序，UDP不保证 连接流程TCP 三次握手 主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我 主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我 主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：”我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了 TCP四次挥手 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1 由B 端再提出反方向的关闭请求,将FIN置1 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束. time-wait的作用 time-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，也就是ACK&#x3D;1的信号结束后，主动关闭连接方所处的状态。 然后time-wait的的持续时间为2MSL. MSL是Maximum Segment Lifetime,译为“报文最大生存时间”，可为30s，1min或2min。2msl就是2倍的这个时间。一般根据实际的网络情况进行确定。 为什么要持续这么长的时间呢 为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源 在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。 名词解释 ACK 是TCP报头的控制位之一，对数据进行确认。确认由接收端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK&#x3D;1时,确认号才有效，当ACK&#x3D;0时，确认号无效，这时会要求重传数据，保证数据的完整性。 SYN： 同步序列号，TCP建立连接时将这个位 置1。 FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。 缓存机制网络模型7层模型 应用层 http、dns、smtp 传报文 表示层 压缩、加密、描述 会话层 数据交换、同步、建立检查、恢复方案 传输层 tcp、udp 网络层 ip协议 传分组和包 数据链路层 传帧 head：报头（发送者、接收者、数据类型） data：数据 物理层 传比特流 5层模型 应用层-传输层-网络层-数据链路层-物理层 重传机制超时重传 超时重传时间是以RTO（数据发送时刻到接收到确认的时刻的差值） 不稳定 实际RTO应略大 如果重发的数据还需要重发，RTO翻倍 快速重传 接收方响应下一个接收的数据 连续响应了三次的话就是需要重传 但是服务端不知道重传一个还是之前所有的，都有可能 SACK 选择性确认 TCP头加一个map，接收方响应时需要传没接收到的数据map 服务端也是连续响应三次后重传 D-SACK TCP头加一个map，接收方响应时需要传重复接收到的数据map 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了; 可以知道是不是「发送方」的数据包被网络延迟了; 可以知道网络中是不是把「发送方」的数据包给复制了; 流量控制 保证发送方和接收方的滑动窗口大小一致 TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况 如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭 如果接受方的窗口为0的ack丢失了，会导致死锁 持续计时器，时间到再发一个询问（重复3次） 设置窗口阈值，避免糊涂窗口 滑动窗口 解决每次发送数据都需要接收ack后才能接着发的问题 不用等待ack，使用缓存实现 TCP 头里有一个字段叫 Window，也就是窗口大小。 这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据 发送方内部通过三个指针表示，接收方内部通过两个指针表示 接收窗口的大小是约等于发送窗口的大小的 拥塞控制为什么需要拥塞控制 A给B发送数据，A迟迟没有收到B的ACK，那么A会觉得B没收到（丢失），A会重新发送 实际情况可能是网络拥塞了，A重复发送数据会导致网络更加拥塞，所以需要拥塞控制 拥塞控制策略 刚开始以指数增长的速度发送数据包（1，2，4…），到达某个阈值后按线性速度发送数据包（1，2，3….），我们也把 A 一次性连续发送多少个数据包称之为拥塞窗口 指数增长阶段称为慢启动，线性增长阶段称为拥塞避免 当增长到某个值后肯定会出现超时事件，可以认为是出现网络拥塞了，暂且称这个值为瓶颈值，此时我们将阈值改为这个瓶颈值的一半，然后拥塞窗口从0开始增长 超时事件还有可能是数据包丢失了 假设A给B发了m1,m2,m3,m4…. 当A连续收到三个确认m2的ACK时，且m3还没有发送超时事件，A就知道B的m3丢失了，A会快速重传m3，然后将阈值修改为瓶颈值的一半，然后拥塞窗口从阈值开始增长 状态码 301：301代表永久性重定向，旧地址被永久移除，客户端向新地址发送请求 302：302代表暂时性重定向，旧地址还在，客户端继续向旧地址发送请求 304(未修改)：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 如果服务器有变更，则从服务器重新下载，返回状态码200 500（服务器内部错误）：服务器遇到错误，无法完成请求 501（尚未实施）：服务器不具备完成请求的功能 502（错误网关）：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503（服务不可用）：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 504（网关超时）：服务器作为网关或代理，未及时从上游服务器接收请求 505（HTTP 版本不受支持）： 服务器不支持请求中所使用的 HTTP 协议版本。 协议ARP IP –&gt; MAC 在TCP&#x2F;IP中属于网络层，在OSI中属于数据链路层 SSl（Https加密协议）四次握手DNS寻址什么是DNS DNS就是域名系统，是因特网中的一项核心服务，是用于实现域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址。通过主机名，得到该主机名对应的IP地址的过程叫做域名解析 解析过程 向浏览器输入一个域名，然后浏览器发起一个DNS解析请求，如果在本地缓存服务器中找不到，则向根服务器查询，根服务器会返回域名对应的顶级域服务器的位置信息 拿到顶级域服务器的位置信息后，就会去询问顶级域服务器，查找对应域名服务器的地址 拿到服务器地址后，查询域名，返回ip地址，缓存到本地服务器中 进入http的链接，顺利访问网站 路由转发原理 二层转发：MAC地址表，广播可能有偶环路，STP防止，同一个VLAN实现 三层转发：路由表，静态路由配置错误有环路，TTL和路由协议解决","tags":["网络"],"categories":["计算机知识"]},{"title":"计算机原理","path":"/2024/01/18/Note/计算机知识/计算机组成原理/","content":"基础概念CPU性能指标 CPU时钟周期：一个CPU内数字脉冲信号振荡的周期 CPU主频：CPU内数字脉冲信号振荡的频率 CPI：平均每条指令执行需要的CPU时钟周期 IPS：每秒执行多少条指令 FLOPS：每秒执行多少次浮点运算 数据通路带宽：数据总线一次所能并行传送信息的位数 吞吐量：单位时间内处理请求的数量 响应时间：计算机发送一个请求到系统做出响应的时间 单位：K &#x3D; 千 &#x3D; 10^3^、M &#x3D; 百万 &#x3D; 10^6^、G &#x3D; 十亿 &#x3D; 10^9^、T &#x3D; 万亿 &#x3D; 10^12^ 计算 CPU时钟周期 &#x3D; 指令条数 * CPI CPU主频 &#x3D; 1 &#x2F; CPU时钟周期 IPS &#x3D; CPU主频 &#x2F; CPI 每条指令耗时 &#x3D; CPI * CPU时钟周期 CPU执行时间 &#x3D; CPU时钟周期 &#x2F; CPU主频 &#x3D; 指令条数 * CPI &#x2F; CPU主频 位运算","tags":["原理"],"categories":["计算机知识"]},{"title":"系统设计","path":"/2024/01/18/Note/计算机知识/系统设计/","content":"YouTuBe视频存储 海量数据存储 通过分布式文件系统 CDN，存储热门视频 视频热门程度不同调用的方式不同 视频压缩 每个视频不同分辨率不同文件，多文件 压缩、转码 大文件切片上传、断点续传 md5检测分片文件完整性","tags":["系统设计"],"categories":["计算机知识"]},{"title":"数据结构和算法","path":"/2024/01/18/Note/计算机知识/数据结构/","content":"数组链表单向链表双向链表字符串字符串匹配KMPManacher确定有限状态自动机队列栈单调栈二叉树哈希表图","tags":["数据结构"],"categories":["计算机知识"]},{"title":"系统安全","path":"/2024/01/18/Note/计算机知识/系统安全/","content":"网络安全XSS攻击 即跨站脚本攻击，就是通过网站注入点向客户端注入可执行解析的payload（脚本代码） 主要获取用户信息，钓鱼，注入密码或广告，后台增删改数据，xss蠕虫 反射性XSS 仅执行一次 存储型XSS DOM型XSS DDos 利用分布式网络将大量恶意请求发送到目标服务器","tags":["系统an'quan"],"categories":["计算机知识"]},{"title":"操作系统","path":"/2024/01/18/Note/计算机知识/操作系统/","content":"进程、线程、协程定义进程 是资源分配的最小单位 有自己独立的内存空间，不同进程之间内存不共享，通讯效率低，切换开销大 僵尸进程 子进程调用exit结束自己的生命，其实没有真正的被销毁，只是释放了该进程所有的资源，之后剩下一个结构 该结构保存了进程的部分信息（进程id，退出状态，运行时间等等） 当父线程通过 wait()&#x2F;waitpid() 方法才会真正销毁 这样设计的目的是父线程可以知道子线程结束时的信息 危害 会一直存在，其进程号被占用，系统能使用的进程号是有限的，可能导致系统无法产生新的进程 解决方法 通过信号机制 将子线程的父线程转变为init进程 杀死导致僵尸线程的父线程 孤儿进程 子进程还没运行结束，父进程已经结束了，那么该子进程称为孤儿进程 后续将被init进程（进程id为1）收养，由init进程销毁 线程 是CPU调度的最小单位 可以有多线程，共享进程的内存空间，通讯效率高，切换开销小 协程 线程中的线程 协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行 协程中不能调用导致线程阻塞的操作，也就是说，协程需要和异步IO结合起来 状态进程 - 线程 新建(New)、就绪(Start)、运行(Running)、阻塞(SLeep &#x2F; wait &#x2F; IO)、死亡(Destroy) 协程 - 通信方式进程 消息队列、共享内存、信号量、Socket 线程 volatile、wait&#x2F;notify机制、ThreadLocal 协程 - 同步方式 线程间 互斥锁、条件变量、读写锁、信号量（PV操作）、信号处理 上下文切换 线程 导致线程上下文切换的原因 线程的cpu时间片用完 垃圾回收 有优先级更高的线程需要运行 线程调用了sleep、yield、wait、join、park、synchronized、lock等 当发生上下文切换时，由操作系统保存当前线程的状态，然后切换到另外一个线程运行，由程序计数器实现 保存的状态有：栈帧的信息（局部变量，操作数栈，返回地址） 频繁的上下文切换会影响性能 线程切换要保存哪些上下文 当前线程Id、线程状态、堆栈和寄存器状态等信息 寄存器主要包括SP PC EAX等寄存器，其主要功能如下： SP:堆栈指针，指向当前栈的栈顶地址 PC:程序计数器，存储下一条将要执行的指令 EAX:累加寄存器，用于加法乘法的缺省寄存器 优点 协程 协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。 执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。 协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。 缺点 协程 对计算密集型的任务也没有太大的好处 并发、并行系统中断软中断硬中断系统调度LRU系统管理进程管理、存储管理、设备管理、文件管理、程序接口、用户界面 寄存器 累加寄存器、基址寄存器、计数寄存器、数据寄存器、变址寄存器、指针寄存器 段寄存器 指令指针寄存器 标志寄存器 用户态和内核态 用户态 只能执行受限的命令，不能直接调用系统资源，需通过内核接口来访问 内核态 可以执行特权命令，调用一切系统资源 用户态 –&gt; 内核态 CPU管理、内存管理、诊断和测试 为了提高IO效率，用户态和内核态都加入了缓冲区 虚拟内存局部性原理浮点数线程安全简介 多个线程访问同一个共享变量就会出现线程安全问题 private 和 final可以一定程度上提供线程安全 线程安全的方法组合起来就不能保证线程安全了 线程安全程度 不可变 final、枚举、Number部分子类（Long、Double、BigInteger、BigDecimal）、使用Collections.unmodifiableXXX() 包装的集合 不可变类：DateFormatter、String 绝对线程安全 调用者都不需要任何额外的同步措施 相对线程安全 有一定的安全，但有意外的情况，例如顺序的连续调用 通过一些同步方法来保证安全 线程兼容 对象本身不安全，需要通过一些同步方法来保证安全 线程对立 即使使用了同步方法也无法保证线程安全 临界区 多线程读写同一个共享资源，这个共享资源就称为临界区 竟态条件 多个线程同时在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件 锁机制死锁 死锁就是多线程之间争夺系统共享资源，然后出现相互等待的情况 互斥：已获取的资源不允许其他进程访问，直到资源释放才能访问 请求和保持：已有资源，然后要访问其他进程占有的资源，但是本身的资源不释放 不可抢占：获取的资源未使用完之前都不可被其他线程访问 循环等待：存在进程之间资源的循环等待 死锁的解决方法 所有资源一次申请，或者逐步申请，用完释放 让使用同一把锁的多个线程的加锁顺序一致 设置获取锁的超时时间，没得到资源则释放已有资源 死锁检测，查代码防止死锁 console工具 jps定位进程，jstack导出dump日志，定位死锁代码 一个线程要获取多把锁容易出现死锁 出现死锁怎么办 重启或者kill 伪共享 CPU在向内存发起IO操作的时候，一次性会读取64个字节的数据作为一个缓存行， 缓存到CPU的高速缓存里面 以缓存行的设计对于CPU来说，可以有效的减少和内存的交互次数，从而避免了CPU 的IO等待，以提升CPU的利用率 因为这种缓存行的设计，导致如果多个线程修改同一个缓存行里面的多个独立变量的时候，基于缓存一致性协议，就会无意中影响了彼此的性能，这就是伪共享 即当一个线程修改了缓存行中的数据时，其他线程需要重新读取缓存行中的数据 解决方式 对齐填充，因为一个缓存行是64字节，当读取的目标数据小于64字节时，可以填充一些无意义的数据使其字节接近或达到64字节，这样就可以使一个缓存行只被一个线程所持有","tags":["操作系统"],"categories":["计算机知识"]},{"title":"分布式微服务思想","path":"/2024/01/18/Note/计算机知识/分布式理念/","content":"分布式 为了解决单体应用带来的各种问题（CAP理论） 优缺点 优点 缺点 依赖网络 维护成本高 CAP无法同时满足 高可用 最大限度保证服务正常、健康的运行，不影响用户的正常使用 实现 合理的负载均衡策略 线程隔离、集群隔离、读写分离，热点数据隔离、爬虫隔离 Nginx限流，Redis+lua限流，应用层限流，降级处理、补偿机制 Nginx限流：流量入口限流，连接数，整体请求数量限制 Redis+lua限流：ip限流，用户限流，防止恶意攻击，采用的令牌桶算法 应用层限流：细粒度，接口限流 CAP理论出现的原因 由于分布式环境下网络的不稳定性，所以需要考虑网络不可达的因素（不能影响到服务的正常响应） 含义 C：consistency-数据一致性 如果系统对一个写操作返回成功，那么之后的读操作必须正确读取到这个写操作的数据 如果系统对一个写操作返回失败，那么之后的读操作不能读取到这个写操作的数据 即对调用者而言数据具有强一致性 A：availability-服务可用性 所有的请求在一定的时间内都可以得到响应，可以终止，不会出现一直等待的情况 P：partition-tolerance-分区容错性 在网络分区的情况下，被分隔的节点仍然能对外提供服务 实际 只能有CP、AP这两种组合，CA在分布式架构中是不可能的，即P必须保证 CAP可以兼得，但是是不完善的，比如通过弱一致性、最终一致性、熔断降级等等来实现 Base理论出现的原因 是CAP理论的一种妥协 含义 基本可用：响应延长、服务降级 软状态：允许存在中间状态，并且该中间状态不会影响系统整体可用性 最终一致性：节点间的数据同步存在时延，但最终会达成一致 也是一种弱一致性 数据一致性模型 弱一致性：某一时刻存在不一致 强一致性：每次都是一致的，牺牲可用性 最终一致性：是弱一致性的特例，结果是一致的即可 因果一致性：有因果关系的操作顺序得到保证 会话一致性：一次会话中，改了之后要能读到 单调读：只能读到当前或更新的数据 单调写：写要有顺序 读写一致性：改了之后要能读到 PACELC 基于CAP理论 PAC - E - L（延迟）C Quorum 不保证强一致性的写，但是读需要是最新，通过版本号 WARO 副本控制协议，保证强一致性，读必须是最新的数据、牺牲可用性 kafka Paxos 解决强一致性的算法，是一种思想&#x2F;协议 or 共识算法，就某个节点的值达成一致 只要Proposer的提案有半数以上的Acceptor接受，则提案通过 Acceptor接受提案即该提案的value被选定了 Acceptor告诉Learners被选定的值 角色： Proposer提议者、Acceptor接收者、Learners记录员 流程 阶段一（Prepare） Proposer收到client请求或发现本地有未提交的值，选择一个提案编号n，向半数以上的Acceptor发送编号为n的Prepare请求 Acceptor收到编号为n的请求 如果已经有提交的value记录，将记录的n和收到的n比较，大于n拒绝反应，反之返回value和编号 如果没有提交的value，判断本地是否有编号，没有就接受该编号 阶段二（accept） 如果Proposer收到半数以上的accept响应该编号n，那么Proposer将n携带上value再发送 Acceptor收到编号为n并且携带value的请求 如果已经有提交的value记录，和n比较，大于n拒绝反应，反之返回value和编号 如果没有提交的value，判断本地是否有编号，没有就接受该编号 如果Proposer收到半数以上的accept响应该编号n，则选定该n和value，同步给Learners 存在的问题 活锁 accept一直被拒绝 交互太多，比较慢，效率低 使用mult-paxos： 一次可以确定多个值 收到accept请求后一段时间内不再接受其他accept请求 Raft 基于paxos的工程化实现，选举算法 角色 leader：处理所有的写请求，并将请求复制到follow follow：响应来自leader和candidate的请求 candidate：选举新的leader 选举 初始化时都是follow节点，全部设置随机睡眠时间，醒了就成为candidate，发起选举 选举成功后，leader需要给其他的follow维持心跳 如果有节点在一定时间内没有收到leader的心跳，那么该follow节点就成为candidate，发起选举 任期 leader产生到重新选举为一任期，保存为一个termId，并将该termId发送给每一个follow节点保存 如果产生了新的leader，判断termId是否是最大的，不是则转化为follow节点 记录日志时会携带termId，代表是在哪个任期写入的日志 每次节点间的rpc通信都需要带上termId，确保只有一个leader Zab 消息广播和奔溃恢复 负载均衡策略 权重 轮询 ip_hash","tags":["理念"],"categories":["计算机知识"]},{"title":"密码学","path":"/2024/01/18/Note/计算机知识/密码学/","content":"加密散列函数MD5对称加密DES 属于分组加密算法，每次处理固定长度的分组，分组大小为64位，需要加密的数据不足64位的倍数会填充 非对称加密RSA 基于数论中一个非常简单的原理：将两个大素数相乘非常容易，但是想要对它们的乘积进行因式分解却极其困难 过程 取两个质数 p , q p &#x3D; 3 ； q &#x3D; 11 质数相乘取 N N &#x3D; p * q &#x3D; 3 * 11 &#x3D; 33 欧拉函数取 T T &#x3D; (p - 1) * (q - 1) &#x3D; 2 * 10 &#x3D; 20 选公钥 E 公钥需要是质数 1 &lt; 公钥 &lt; T 公钥不是T的因子 选私钥 D (D * E) % T &#x3D; 1 加密 (E, N) 数据的每一位进行E次幂计算，再对N求余 解密 (D, N) 密文的每一位进行D次幂计算，再对N求余 SSLRSV（Random Scalar Value） 基于ECDSA（椭圆曲线数字签名算法）的一种加密方式 是签名过程中使用的随机标量值，用于确保签名的随机性和不可预测性。 在签名过程中，RSV的作用是作为哈希函数的输入，与私钥一起生成签名值。具体来说，RSV的选择应该是随机的，并且与私钥和待签名的消息一起哈希，以确保签名的唯一性和不可伪造性。 RSV的计算通常基于随机数生成器生成一个随机的标量值，然后与私钥和消息一起传递给哈希函数进行计算。具体的计算过程取决于所使用的签名算法和哈希函数，不同的非对称加密算法可能具有不同的计算方法和要求。 需要注意的是，RSV的选择和计算必须严格保密，以确保签名的安全性和可信度。此外，为了确保签名的有效性，RSV必须经过适当的验证和过滤，以防止潜在的安全漏洞和攻击。 算法ECDSA签名算法 计算出r, s并返回用于rsv签名 v是一个恢复ID。v的值是由r的奇偶性决定的，如果r是偶数，则v&#x3D;27；如果r是奇数，则v&#x3D;28 过程 选择一条椭圆曲线Ep(a,b)，和基点G。 选择私有密钥k（k&lt;n，n为G的阶），利用基点G计算公开密钥K&#x3D;kG。 产生一个随机整数r（r&lt;n），计算点R&#x3D;rG。 将原数据和点R的坐标值x,y作为参数，计算SHA1做为hash，即Hash&#x3D;SHA1(原数据,x,y)。 计算s≡r - Hash * k (mod n)。 r和s做为签名值。如果r和s其中一个为0，重新从第3步开始执行","tags":["数据结构"],"categories":["计算机知识"]},{"title":"SQL","path":"/2024/01/18/Note/数据库/SQL/","content":"简介概念外键编码utf8和utf8mb4的区别 utf8mb4是utf8的超集,专门用来兼容四字节的 兼容emojo表情和不常用的中文汉字，utf8不兼容 操作符 操作符 作用 备注 IN &#x2F; NOT IN 等于&#x2F;不等于 列表中的任意一个 ANY &#x2F; SOME 和子查询返回的某一个值比较 ALL 和子查询返回的所有值比较 || 拼接字段 函数 函数名 作用 参数 备注 count 统计记录数 *&#x2F;字段&#x2F;常量 sum 求和 avg 平均值 max 最大值 min 最小值 cast 值 as 类型 with as 名 临时表 子查询 8.0之前要用temporary table DATE_FORMAT 时间，格式 CONCAT 连接两个字符 A，B IFNULL 判断是否为空 可能为null的值，如果为空返回的值 只传一个参数相当于if LENGTH 获取长度 字符串 UPPER 大写 LOWER 小写 substr 截取字符串 字符串，开始索引，长度 instr 返回B在A第一次出现的索引 strA,strB trim 去除前后字符 去除的字符，str 只传str则去除空格 lpad 左填充字符 str,结果长度,填充字符 rpad 右填充字符 str,结果长度,填充字符 replace str中的A换成B str,strA,strB round 四舍五入 数值，保留位数 ceil 向上取整 数值 floor 向下取整 数值 truncate 截断 数值，保留位数 mod 取余 数值，除数 rand 获取随机数 now 当前系统日期和时间 curdate 当前系统日期 curtime 当前系统时间 YEAR&#x2F;MONTH&#x2F;DAY 获取指定的部分 STR_TO_DATE 日期转日期 时间，格式 DATE_FORMAT 日期转字符 时间，格式 DATEDIFF 俩个时间的之间的天数 if 判断 判断,true返回的值,false返回的值 listagg() within group(order by 字段) as 别名 行转列 字段，分隔符 Oracle 流程控制If IF(判断,true返回的值,false返回的值) if 条件1 then 语句1; elseif 条件2 then 语句2; 【else 语句n;】 end if; case case(要判断的值) when 常量1 then 要显示的值或语句; ​ when 常量2 then 要显示的值或语句; ​ 【ELSE 以上都不符合要显示的值或语句;】 ​ END case when 判断1 then 要显示的值或语句; when 判断2 then 要显示的值或语句; 【ELSE 以上都不符合要显示的值或语句;】 END Having 对分组筛选后的数据进行操作，用在GROUP BY 后，效果同where GROUP BY 和 HAVING 后都可接别名 筛选条件能写在where后优先现在where后，效率高 多个字段分组用逗号隔开即可 约束 约束 作用 备注 not null 非空 字段不能为空 default 默认值 字段有默认值 primary key 主键 字段具有唯一性，非空 unique 唯一 字段具有唯一性，可以为空 check 检查 mysql中不支持 foreign key 外键 不建议使用 索引索引结构 不同的存储引擎实现的索引结构不同 B+Tree索引：大部分引擎都支持 Hash索引：Memory引擎支持 索引速度快，效率高，但不支持范围索引 无法利用索引排序 R-tree(空间索引)：MyISAM引擎支持 一个特殊索引类型，主要用于地理空间类型 full-text(全文索引)：elasticSearch，InnoDB(5.6之后)、MyISAM支持 索引分类 主键索引 唯一索引 常规索引 全文索引 只能有一个 可以多个 可以多个 可以多个 不能null 可null 可null 可null 值唯一 值唯一 值不唯一 值唯一 只能在字符串、文本上建立 InnoDB中的索引 聚集索引 必须有，而且只有一个，一般是主键索引，没有就选唯一索引，再没有InnoDB会自动生成一个rowid作为隐藏的聚集索引 索引的叶子结点保存了行数据 二级索引 可以有多个 索引的叶子结点存放的是对应的字段值 索引语法 创建索引 create index 索引名 on 表名(字段名) alter table 表名 add index 索引名(字段) 查看索引 show index from 索引名 删除索引 drop index 字段名 on 表名 alter table 表名 drop index 索引名 查看表的索引情况 show index from 表名 show create table 表名 修改索引 只能通过删除索引再添加索引 DQL(数据查询语言–Data Query Language)基础查询select 查询列表 from 表名 起别名 使用as 使用空格 字符串用” “ 去重 DISTINCT +号的作用 运算符 俩个操作数都为数值型，则进行加法运算 其中一方为字符型 字符为数字则进行计算 “100” + 50 -&gt; 150 为字符则字符数值为0 “John” + 100 -&gt; 100 其中一方为null则都为null null + 50 -&gt; null 条件查询select 查询列表 from 表名 where 筛选条件 筛选条件 条件表达式 &gt; &lt; = !&#x3D; &gt;&#x3D; &lt;&#x3D; &lt;&gt;不等于 逻辑表达式 &amp;&amp; || ! and or not 模糊查询 like %任意多个字符，包含0个 _任意当个字符 \\转义字符 也可以使用ESCAPE 转义 ESCAPE ‘$’ &#x3D;&#x3D; \\ 无法显示null值 between and 包含临界值 in(列表1，列表2) 判断值是否属于in列表中 不能使用通配符 is null &lt;&#x3D;&gt; 安全等于,可以搭配null 排序查询select 查询列表 from 表名 where 筛选条件 order by 排序列表 [asc默认升序/desc降序] 注意 order by 后可以用别名 order by 要放在语句的最后 支持多个字段，函数，表达式，别名 连接查询 连接方式 结果 备注 表1，表1 笛卡尔积 自连接，处理自身层级关系数据 表1，表2 表1表2交集 SQL92 表1 inner join 表2 表1表2交集 SQL99 表1 Join 表2 表1 left Join 表2 表1为主表拼接表2 表1 right Join 表2 表2为主表拼接表1 表1 full Join 表2 交集 + 表1有表2没有的+表2有表1没有的 表1 cross Join 表2 笛卡尔积 子查询 查询中嵌套查询 查询 union 查询 合并为一个结果集 查询 union all 查询 合并为一个结果集 子查询 出现在其他语句内部的select语句称为子查询或内查询 内部有子查询的语句为主查询 分类按位置 SELECT后 结果集只能为标量子查询（一行一列） FROM后 将子查询的结果充当一张表，必须起别名 WHERE或HAVING后 标量子查询（单行子查询） 子查询返回的值是一行一列的 列子查询（多行子查询） 子查询返回的值是一列多行的 IN &#x2F; ANY &#x2F; SOME &#x2F; ALL 行子查询（一行多列） 子查询返回的值是一行多列的 (A,B) &#x3D; (select语句) EXISTS后(相关子查询) EXISTS（完整的查询语句） 有结果返回1，没结果返回0 按结果集行列数 标量子查询（一行一列） 列子查询（一列多行） 行子查询（一行多列） 表子查询（多行多列） 特点 子查询的执行优先于主查询 分页查询SQL 语句 limit offset,size offset：起始索引，索引从0开始 size：要显示的个数 注意 limit最后执行 索引从0开始可以省略 page 显示的页数 size每一页显示的条目 limit (page-1)*size,size 联合查询语句A union 语句B union... 将多条查询语句的结果合并成一个表 注意 要求多条查询语句查询的字段个数要一致 要求多条查询语句查询的每一个字段的类型和顺序最好一致 默认情况会自动去重，不想去重可以使用union ALL DML(数据操纵语言–Data Manipulation Language)insert into 表名(字段名...) values(值...); 插入的值的类型要与字段的类型一致或兼容 可以为空的字段可以不写也可以写null 可以省略字段名，但所有字段都得有值 支持多行插入，用逗号分隔 支持子查询 insert into 表名 set 字段名=值... 不支持插入多行 不支持子查询 update 表名 set 字段名=新值,字段名=新值... where 筛选条件 单表修改 update 表1 别名 inner/left/right join 表2 别名 on 连接条件 set 字段名=值。。。 where 筛选条件 多表修改 delete from 表名 where 筛选条件 delete 要删除的表的别名 from 表1 别名 inner/left/right join 表2 别名 on 连接条件 where 筛选条件 删除后自增长列从删除前断点开始 有返回值（能显示删除了几条） 删除后能回滚 truncate table 表名 只能删除整张表，不能使用where 删除后自增长列从1开始 没返回值（不能显示删除了几条） 删除后不能回滚 DDL(数据定义语言–Data Define Language)库的管理create database (if no exists) 库名 创建库 alter database 库名 character set 编码格式 修改库 drop database (if is exists) 库名 删除库 表的管理desc 表名 查看表结构 create table 表名( ​ 字段名 字段类型[(长度)] [约束], ​ 字段名 字段类型[(长度)] [约束], ​ ...) 创建表 alter table 表名 change column 旧字段名 新字段名 新字段类型 修改字段名 alter table 表名 modify column 字段名 新字段类型 修改字段的类型 alter table 表名 add column 新字段名 新字段类型 添加字段 alter table 表名 drop column 字段名 删除字段 alter table 表名 rename to 新表名 修改表名 alter table 表名 modify column 字段名 字段类型 新约束 添加列级约束 alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用] 添加表级约束 drop table (if is exists) 表名 删除表 create table 复制表 like 原始表 复制表的结构 create table 复制表 select 字段1，字段2 from 原始表 where 0 复制表的部分结构 create table 复制表 select * from 原始表 复制表的结构和所有数据 create table 复制表 select 字段1，字段2 from 原始表 where 筛选条件 复制表的结构和部分数据","tags":["数据库"],"categories":["数据库"]},{"title":"Redis","path":"/2024/01/18/Note/数据库/Redis/","content":"简介 Redis是基于AP思想的，是最终一致性 数据全部存储在内存中，操作效率高，速度快 单线程处理，避免了不必要的上下文切换，不用考虑线程安全问题 IO多路复用技术，可以处理高并发的连接请求 事件派发机制 数据类型String 功能 命令 添加&#x2F;修改数据 set key valuemset key1 value1 key2 value2 … 获取数据 get keymget key1 key2… 删除数据 del key 获取字符串长度 strlen key 追加消息 append key value 增加 incr keyinceby &#x2F; incrbyfloat key 数值 减少 decr keydecrby key 数值 设置有效期 setex key seconds 值psetex key millseconds 值 设置一个值，当redis中没有时才能设置成功 setnx key 值 数值超过上限会报错 0 表示失败，1表示成功 nil 表示为null 数据最大存512MB Hash 功能 命令 添加 &#x2F; 修改数据 hset key field value 获取数据 hget key fieldhgetall key 删除数据 hdel key field 添加 &#x2F; 修改多个数据 hmset key field1 value1… 获取多个数据 hmget key field1 field2… 获取key中字段的数量 hlen key 获取key中是否存在指定的字段 hexists key field 获取key中所有的字段名或字段值 hkeys keyhvals key 设置指定字段的数值数据增加指定范围的值 hincrby key field 值hincrbyfloat key field 值 获取一个key中所有的field-value hgetall key 添加一个key中的field，前提是这个field不存在 hsetnx key field 值 一个key对应多个field - value 如果filed少，会优化为类数组 如果field多，会优化为HashMap value只能存字符串 一个key可以存2^32^ - 1 个键值对 hash可以存储少量对象 List 功能 命令 左侧插入元素 LPUSH key 值 移除左侧第一个元素 LPOP key 右侧插入元素 RPUSH key 值 移除右侧第一个元素 RPOP key 返回一段范围内的所有元素 LRANGE key start end 阻塞取元素，没元素会等待一段时间 BLPOP &#x2F; BRPOP key 可以看成双向链表 Set 操作 命令 添加元素 Sadd key 值 移除元素 Sred key 值 返回元素个数 Scard key 判断元素是否存在 Sismember key 值 获取所有元素 Smembers 求key1和key2的交集 Sinter key1 key2 求key1和key2的差集 Sdiff key1 key2 求key1和key2的并集 Sunion key1 key2 类似hashSet SortedSet 操作 命令 添加 Zadd key score 成员 删除 Zrem key 成员 获取分值 Zscore key 成员 获取排名 Zrank key 成员 获取元素个数 Zcard key 统计范围内个数 Zcount key min max 指定元素自增 Zincrby key 自增的值 成员 排序后，取指定排名范围的值 Zrange key min max 排序后，取指定分数范围的值 ZrangeByScore key min max 差集 &#x2F; 交集&#x2F; 并集 Zdiff &#x2F; Zinter &#x2F; Zuinon 排序默认是升序的，Zrev为降序 底层数据结构是跳表 Stream消息队列消费者 添加信息 Xadd key [nomkstream] [maxlen | minId [=|~] threshold [limit count]] *|ID field value... [nomkstream]：队列不存在则创建 [maxlen | minId [&#x3D;|~] threshold [limit count]]：设置队列的最大消息数量 *|ID：消息唯一id，*代表自动生成 field value：要发送的消息 读取消息 Xread [Count count] [block milliseconds] streams key... Id... [Count count]：每次读取的数量 [block milliseconds]：没有消息时的阻塞时长 streams key：队列名 Id：起始id，0代表从第一个消息开始，$代表从最新的消息开始 消费者组 创建消费者组 Xgroup create key groupName Id [mkstream] key：队列名 groupName：消费者组名 Id：$代表队列中最后一个消息，0代表第一个消息 mkstream：队列不存在则创建 读取消息 XreadGroup Group group consumer [Count count] [block milliseconds] [NoAck] streams key... Id... group：消费者组名 consumer ：消费者名 [Count count]：每次读取的数量 block milliseconds：没有消息时的阻塞时长 NoAck：无需手动Ack，自动确认 key：队列名 Id：获取信息的起始ID “ &gt;”：从下一个未消费的信息开始 下标：从pending-list下标位置开始读取 查看pending-list Xpending key group id范围 count GEO 作用 命令 添加地理空间信息 GEOadd 经度 纬度 值 计算两点之间距离 GEOdist 点1 点2 指定点的坐标转换为hash字符串 GEOhash 返回点的坐标 GEOpos 指定圆心，半径，找到园内点，按照离圆心的距离排序（6.2废弃） GEOradius 圆心 半径 指定范围内找点，可以是圆型、矩形，会排序（6.2新增） GEOsearch 与GEOsearch功能一样，但可以把结果存入一个key GEOsearchStore 底层是SortedSet BitMap 作用 命令 指定位置插入0或1 setBIT 获取指定位置值 getBIT 统计1的数量 BITcount 查、改、增 指定位置的值 BITfield 获取数组 BITfield_ro 结果做位运算 BITop 找第一个1 或0 的位置 BITpos HyperLogLog 用于确定非常大的集合的基数，不需要存储其所有值 基于String实现的，当个HLL内存小于16kb 测量结果有小于0.81%的误差 线程模型简介 内部使用文件事件处理器（file event handler），是单线程的 使用的IO多路复用机制同时监听多个socket，将产生事件的socket压入内存队列 事件分派器根据socket上的事件类型来选择对应的事件处理器 在Redis6中引入了多线程机制，主要用于处理回复事件、命令转换 文件事件处理器（file event handler） 首先，Redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。 客户端 socket01 向 Redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。 假设此时客户端发送了一个 set key value 请求，此时 Redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。 如果此时客户端准备好接收返回结果了，那么 Redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok ，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。这样便完成了一次通信。 客户端SpringDataRedis序列化的方式 ​\t自定义redisTemplate，修改序列化器 12345678910111213141516@Beanpublic RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; //创建Template RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); //设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); //设置序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); //key和HashKey采用String序列化 redisTemplate.setKeySerializer(ReidsSerializer.string()); redisTemplate.setHashKeySerializer(ReidsSerializer.string()); //value和HashValue采用Json序列化 redisTemplate.setValueSerializer(jsonRedisSerializer); redisTemplate.setHashValueSerializer(jsonRedisSerializer); return redisTemplate;&#125; 使用StringRedisTemplate，手动序列化Json 预热、雪崩、穿透、击穿缓存预热 主从之间数据吞吐量较大、数据同步操作频度高、请求数量较高，而且redis中没有数据，会导致redis启动时快速宕机，所以需要进行redis缓存预热 日常需要对数据的访问进行记录，统计热点数据 利用LRU数据删除策略，构建数据留存队列 redis启动时加载热点数据 使用脚本固定触发数据预热 缓存穿透 缓存穿透是指客户端请求的数据在缓存和数据库中的不存在，这些请求每次都会打到数据库 解决方案 使用缓存空对象，设置过期时间，可能存在短期不一致性 使用布隆过滤器解决，在客户和缓存之间添加，缓存预热时，预热布隆过滤器 增强id的复杂度 加强用户权限校验 做好热点参数的限流 缓存雪崩 同一时段大量的缓存key同时失效或者redis宕机，导致大量的请求直接到达数据库，带来巨大压力 解决方案： 给不同的缓存key的过期时间（TTL）添加随机值 不同业务过期时间不同 对超级热点数据使用永久key 使用Redis集群，主从+哨兵 给缓存业务添加降级限流策略 给业务添加多级缓存 优化数据库中严重耗时的业务 redis监控服务器性能指标 把缓存key到期删除策略改成按命中次数删除策略 redis开启持久化，宕机后快速恢复 缓存击穿 一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求会打到数据库 解决方案 如果缓存的数据基本不更新，可以设置为不过期 互斥锁 适合缓存更新较快的场景 没有额外内存消耗，保证一致性，实现简单，但是性能受影响，可能出现死锁 利用Redis的 SETNX 实现，只有第一个执行SETNX的成功 或者使用redisson实现 逻辑过期 即热点数据缓存不设置过期时间，而是在其对象中设置一个时间属性，在这上面设置过期时间 性能较好，但不保证一致性，有额外内存消耗，实现复杂 消息队列 List Pubsub Stream 持久化 √ × √ 阻塞读取 √ √ √ 消息堆积处理 可利用多消费者处理 受限于消费者缓冲区 受限于队列长度，可使用消费者组加快消费速度 消息确认 × × √ 消息回溯 × × √ 内存淘汰策略 noeviction：不清除缓存，内存满了不允许写入新的数据（默认） allkeys-lru：对所有key使用LRU算法进行删除 （推荐） volat-lru：对所有设置了过期时间的key使用LRU删除 allkeys-random：对所有key随机删除 volatile-random：对所有设置了过期时间的key随即删除 volatile-ttl：删除马上就要 过期的key allkeys-lfu：对所有key使用LFU算法进行删除（根据数据访问频率） volatile-lfu：对所有设置了过期时间的key使用LFU删除 数据过期策略 惰性删除 过期后不删除，使用到key时会检查他是否过期，过期删除 定期删除 每隔一段时间，对一定量的key进行检查，过期就删除 分为slow模式和fast模式 slow：定时任务 fast：间隔2ms，耗时不超过1ms 应用场景 短信验证 手机号作为key，验证码为value 登录成功获取token，token为key，user对象为值 设置有效期 数据缓存 分布式事务保证原子性 全局ID incrby方法，是原子性操作 符号位(1) + 时间戳(31) + 序列号(32) 雪花算法 符号位 + 时间戳 + 机器码 + 序列号 分布式锁 setnx方法，超时释放，分布式id冲突 释放锁时需要判断value值是否一致，保证原子性 Redission实现 消息队列 XGroup，消息分流、表示、确认、阻塞读取、可回溯 使用Lua脚本添加信息，保证原子性 消息发送后进入pending-list，XACK后移除 点赞 SortedSet 关注 Set，查看共同关注 推送 有推，拉，推拉结合 为用户建立收件箱，实现分页查询，SortedSet实现 附近商铺 GeoLocation，底层是SortedSet 签到 BitMap，String实现 事务 将多个命令打包，然后一次性、有序的执行 多个命令会被列入到事务队列中，然后按先进先出FIFO的顺序执行 事务不会被中断 使用场景 缓存一致性 做法 读的时候先读缓存，缓存没有就读数据库，然后存入缓存 先更新数据库再删除缓存 或者 先删除缓存再更新数据库 删除缓存时因为如果每次更新数据库都更新缓存，无效的写操作太多 可能出现的问题 删除缓存时失败了，导致缓存中是旧数据 延时双删，即在一定时间后再删除一次 可以使用消息队列完成删除的动作 更新数据库时有读请求请求到旧数据 当读取缓存时没取到数据，就将请求存入MQ中，然后等待数据库更新完成存入MQ去删除缓存 可以使用Canal中间件实现无侵入性的异步删除缓存 加读写锁（强一致） 更新数据库时有读请求请求到旧数据并加入缓存 加读写锁（强一致） 压缩列表 设置字符压缩阈值 阈值最好不要大于2048 因为压缩列表涉及解码编码 压缩指针 三个指针的存储 大列表拆分 lua脚本实现 存数据索引 持久化RDB Redis数据备份文件，也被叫做Redis数据快照 RDB把内存中的所有数据记录到磁盘中，当Redis故障重启后，从磁盘读取RDB，RDB读取较快 Redis停机时会保存一次RDB，也可以设置单位时间修改量阈值，超过阈值就保存 redis.conf文件中可以对RDB进行配置 RDB执行间隔长，俩次RDB之间写入数据有丢失的风险 可以使用主进程执行或者子进程执行 save：主进程，会阻塞 操作虚拟内存，通过页表映射到物理内存 bgsave：获得子进程，往磁盘写RDB都比较耗时，异步非阻塞 存储的流程 由于Linux系统中所有的进程都无法直接操作物理内存，都是通过操作进程自身的虚拟内存，然后通过页表建立虚拟内存和物理内存之间的映射关系实现 克隆一个与主进程一直的子进程，共享内存空间，子线程克隆主进程中的页表，速度快 读取物理内存数据写入新的RDB文件并存入磁盘 用新RDB文件替换旧的 如果子进程在写RDB时主进程有写入的操作，此时会将物理内存拷贝一份，新的读写请求都会操作这个拷贝的物理内存，这样可以避免数据不一致 AOF Redis追加文件，redis的每一个写命令都会记录在aof中 aof写入性能高，使用的是追加写入，没有磁盘寻址开销，文件不易破损 默认是关闭的，需要在配置文件中开启，也可以配置相关配置 Always：同步刷盘，可靠性高，不丢数据，性能影响大 everysec：每秒刷盘，性能适中，最多丢失1s数据 no：操作系统控制，性能最好，可靠性较差，可能丢失大量数据 AOF文件比RDB文件大的多 aof会记录对一个key的多次写操作，但其实只有最后一次写有意义，可以通过bgrewriteaof命令，让aof执行重写，用最少的命令达到同样的效果 可用于紧急故障回滚 也可以设置阈值触发重写aof AOF和RDB混合持久化 同时使用两种持久化功能需要耗费大量系统资源，系统的硬件必须能够支撑运行这两种功能所需的资源消耗，否则会给系统性能带来影响 Redis服务器在启动时，会优先使用AOF文件进行数据恢复，只有在没有检测到AOF文件时，才会考虑寻找并使用RDB文件进行数据恢复 当Redis服务器正在后台生成新的RDB文件时，如果有用户向服务器发送BGREWRITEAOF命令，或者配置选项中设置的AOF重写条件被满足了，那么服务器 将把 AOF重写操作 推延到 RDB文件创建完毕之后再执行，以此来避免两种持久化操作同时执行并争抢系统资源 同样，当服务器正在执行BGREWRITEAOF命令时，用户发送或者被触发的BGSAVE命令也会推延到BGREWRITEAOF命令执行完毕之后再执行 开启混合持久化，4.0之后才可以使用 aof-use-rdb-preamble yes 开启混合持久化之后，生成的aof文件由两部分组成 RDB+AOF 集群分片集群简介 解决海量数据存储和高并发读写的问题 集群中有多个master节点，每个master保存不一样的数据 每个节点都会开启两个端口，一个用于数据交互，另一个用于节点间通信 通信用的gossip二进制协议，占用更少的网络带宽和处理时间。 每个master可以有多个slave节点 master之间心跳检测 客户端可以访问集群中的任意节点，最终都会被正确转发到正确的节点 哈希槽 redis分片集群引入了哈希槽的概念，一共有16384（2^14^ 大小的数组）个哈希槽，redis节点不会超过1000个 每个key通过CRC16校验后对16384取模来决定分配到哪一个哈希槽中，集群中的每一个节点负责一部分哈希槽 相当于在请求和redis之间添加了一个反向代理（槽），由它来选择存储的redis节点 哨兵集群简介哨兵（sentinel）是 Redis 集群架构中非常重要的一个组件，主要有以下功能： 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。 基于心跳检测，每一秒ping一次，超过规定的时间没有响应，则视为主观下线 超过一半（可设置）的哨兵认为该节点主观下线，则该节点变为客观下线 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 哨兵用于实现 Redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的 哨兵选主规则 判断主从断开时间长短，超过指定值则排除 判断节点的salve-priority值，越小优先级越高，如果一样则判断offset，越大优先级越高 最后判断节点运行id大小，越小优先级越高 哨兵间的自动发现机制 是通过redis的 pub&#x2F;sub 实现的，每个哨兵都会往 __sentinel__:hello 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在 每个哨兵还会跟其他哨兵交换对 master 的监控配置，互相进行监控配置的同步 主从同步 &#x2F; 主从集群简介 能够实现读写分离，但无法实现集群高可用 分为主节点master和从节点salve&#x2F;replica 主节点接收写操作 从节点接收读操作 每一个主节点都有一个replid，这个id是数据集的标记，从节点会继承主节点的replid，从节点同步时会带上这个replid，如果和主节点的不一致则说明是第一次同步 主节点有一个偏移量offset，这个偏移量会根据replicated_baklog中的数据增多而逐渐增大，从节点完成同步时也会记录当前同步的主节点的偏移量，如果。从节点偏移量小于主节点，则会进行数据同步更新 全量同步 从节点向主节点建立连接，通过执行replicaof命令 请求数据同步，会携带replid、offset 主节点判断是否是第一次同步，通过判断replid是否一致，不一致则是第一次 第一次 是第一次，将主节点完整的版本信息发送给从节点，即replid、offset 主节点执行持久化生成RDB，发送给从节点 从节点清空本地数据，加载RDB文件 主节点会记录生成RDB文件期间接收到的所有命令，封装为replicated_baklog日志文件发送给从节点 从节点执行接收到的日志文件 不是第一次 主节点计算从节点的偏移量和主节点偏移量的差值数据封装为replicated_baklog日志文件发送给从节点 从节点执行接收到的日志文件 增量同步 一般在从节点重启时或者主从数据发送变化时 就是全量同步中不是第一次同步的情况 脑裂 由于网络分区或者网络故障集群分割，两个分区都选举了master节点，故障恢复后其中一个master会变回salve节点，其间其接收到的写请求都会在同步后丢失 解决方法 设置min-replicas-to-write 1：表示主节点最少需要有一个从节点 设置min-replicas-max-lag 5：表示数据复制和同步的延迟不能超过5s 分布式锁setnx set lock value NX EX 1 必须设置失效时间兜底，否则会导致死锁的问题 预估业务执行时间 给锁续期，自己实现需要开一个线程去监控，比较麻烦 Redission加锁原理 使用lua脚本保证的原子性 可重入原理 使用hash结构来记录获取锁的线程id，value记录的是重入的次数 内部还是实现的lua脚本 可重试原理利用信号量和PubSub功能实现 使用带参的构造函数获取锁，参数是重试的等待时间和时间单位 底层会给一个默认的超时时间30秒（看门狗时间） 当获取锁失败时会返回一个锁的剩余有效期 (pttl) (剩余的超时时间) 用等待时间减去获取锁失败这个过程消耗的时间 小于等于0，返回false 大于0，进入等待通知状态（订阅状态），当有线程释放锁时会通知其他等待的线程 当等待通知的时间超过了等待时间时，取消订阅状态，返回false 当在等待的期间获得了通知 用等待时间减去等待通知这个过程消耗的时间 小于等于0，返回false 大于0，进入一个循环，尝试获取锁，成功返回 失败进入一个等待信号量的状态，ttl时间到或者等待时间到时尝试获取锁 判断等待时间，超时false，不超时进入下一轮循环 代码中经常涉及到对剩余时间的计算，比较严谨 不超时原理 使用带参的构造函数获取锁，参数是重试的等待时间、超时时间和时间单位 不设置超时时间才能实现锁不超时（看门狗机制） 当获取锁成功时会调用**scheduleExpirationRenewal()**方法 方法中会创建一个ExpirationEntry对象，用一个ConcurrentHashMAp存储，key是当前锁的名称，value是ExpirationEntry对象，一个锁对应一个entry，重入不覆盖 执行renewExpiration方法刷新超时时间 方法中会创建一个Timeout定时线程，只要当前线程持有锁，每隔看门狗时间 &#x2F;3 秒就会调用renewExpirationAsync异步刷新一次超时时间 会把线程id作为key，定时刷新的线程作为value存入一个map中 当锁释放时，执行cancelExpirationRenewal 根据锁id取出map中的定时刷新线程然后取消掉 然后把entry删除 避免阻塞导致锁超时释放 主从一致（连锁） Redission不分主从关系，加锁时会向所有redis集群中一半以上的节点加锁，这些节点可以有从节点，即红锁 实现复杂，性能影响大 通过**redissionClient.getMultiLock(锁对象1,锁对象2…)**创建连锁 内部会把这些锁放在一个集合中 所有操作都需要集合中每一个锁都成功才能成功 在获取每一个锁时如果超时会释放所有以获得的锁 如果设置了超时时间，在获取所有锁之后会一次性给所有锁刷新超时时间 没设置超时时间会使用看门狗机制 多级缓存JVM进程缓存CaffeineNginx本地缓存LuaOpenResty最佳实践批处理","tags":["中间件"],"categories":["数据库"]},{"title":"PostgreSQL","path":"/2024/01/18/Note/数据库/PG/","content":"常用命令- 常用函数 名 作用 备注 coalesce(e1, e2) e1不为空返回e1，否则返回e2 类似 if round() 保留小数点 unnest(string_to_array(pbbm, ‘,’)) 遍历数组","tags":["中间件"],"categories":["数据库"]},{"title":"MongoDB","path":"/2024/01/18/Note/数据库/MongoDB/","content":"简介 结构松散，使用bson结构 是一个分布式文件存储的数据库、C++编写 最像关系型数据库的非关系型数据库，介于非关系和关系型之间 高并发读写、海量数据高效率存储和访问、高扩展性和高可用性 应用场景（海量数据，写入频繁，价值低，事务要求不高） 社交：朋友圈信息，附近的人，地点等 游戏：装备、积分 物流：实时订单信息， 物联网：智能设备信息，日志信息 视频直播：点赞互动等 MySQL MongoDB database database table collection 集合 row document 文档 colunm field index index table joins primary key primary key 操作 查看所有的数据库 show dbs 使用指定数据库 use 数据库名 创建数据库 use 数据库名 数据库自动创建，进行插入数据即可自动创建 删除数据库 db.dropDatabase() 删除表（集合） db.表名.drop() 插入数据 db.表名.insert(&#123;id:1, username:&#39;张三&#39;&#125;) db.表名.save(&#123;id:1, username:&#39;张三&#39;&#125;) 更新 db.表名.update(查询条件，变更的内容，[upesrt不存在数据是否插入], [multi 是否更新多条数据]，[writeConcern抛出异常的级别]) db.表名.update(&#123;id:1&#125;, &#123;age:25&#125;) 这样写数据会被删除只剩age db.表名.update(&#123;id:1&#125;, &#123;$set:&#123;sex:1&#125;&#125;) 更新不存在的字段，会新增字段 更新不存在的数据默认不会新增数据 删除 db.表名.remve([查询条件], [justOne 默认为true，删除一个，false删除所有匹配的], [writeConcern抛出异常的级别]) 官方推荐使用db.表名.deleteOne() 和 db.表名.deleteMany() 查询 db.表名.find([查询条件]，[fields 指定返回的字段]) 后接pretty()美化返回结果 条件 等于（:）、小于（$lt:）、小于等于（$lte:）、大于（$gt:）、大于等于（$gte:）、不等于（$ne:） 分页 limit() skip() sort() 索引 查看索引 getIndexes() 创建索引 createIndex() 删除索引 dropIndex() dropIndexex() 删除除了_id之外的索引 创建联合索引 createIndex(多个fields) 查看索引大小 totalIndexSize() 执行计划 语句后接 explain() JavaAPI配置1234567891011121314public static void main(Stringp[] args)&#123; //建立连接 MongoClient mongoClient = MongoClients.create(&quot;mongodb://127.0.0.1:27017&quot;); //选择数据库 MongoDatabase database = mongoClient.getDatabase(&quot;数据库名&quot;); //选择表 MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;表名&quot;); //操作 collection.find().limit(10).forEach((Consumer&lt;? super Document&gt;) document -&gt;&#123; //输出 &#125;); //关闭连接，释放资源 mongoClient.close();&#125; 查询123456789101112131415161718public void Query()&#123; //查询age &lt;= 50 且 id &gt;= 100 的用户信息，id倒序输出，返回id，age this.collection.find( Filters.and( Filters.lte(&quot;age&quot;, 50), Filters.gte(&quot;id&quot;, 100) ) ).sort(//排序 Sorts.descending(&quot;id&quot;) ).projection(//查询的字段 projections.fields( projections.include(&quot;id&quot;,&quot;age&quot;), projections.excludeId() ) ).forEach((Consumer&lt;? super Document&gt;) document -&gt;&#123; //输出 &#125;);&#125; 插入1234567public void Insert()&#123; Document document = new Document(); document.append(&quot;id&quot;, 1001); document.append(&quot;name&quot;, &quot;张三&quot;); document.append(&quot;age&quot;, 100); this.colection.insertOne(document);&#125; 修改1234public void Update()&#123; //查询条件 //更新的字段\tthis.collection.updateOne(eq(&quot;id&quot;, 1001), Updates.set(&quot;age&quot;, 30));&#125; 删除1234public void Delete()&#123; //查询条件 this.collection.deleteMany(eq(&quot;id&quot;, 1001));&#125;","tags":["数据库"],"categories":["数据库"]},{"path":"/2024/01/18/Note/数据库/Oracle/","content":"简介函数 函数名 作用 参数"},{"title":"MySQL","path":"/2024/01/18/Note/数据库/MySQL/","content":"简介命令 命令名 参数 作用 mysql -h 主机名 -P 端口 -u 用户名 -p 密码 启动数据库 desc 表名 查看表结构 show variables 查看系统变量 select @@transaction_isolation 查看当前事务隔离级别 set [global] transaction isolation level read committed 设置数据库系统的隔离级别 source 路径 导入sql文件 函数count() count(1) ≈ count(*) &gt; count(主键ID) &gt; count(column) count(*)：不同存储引擎有不同的实现和优化 InnoDB： 一行一行的读并统计，因为InnoDB支持事务，同一时刻的多个查询会受到MVCC的控制，所以count()的结果不稳定 等同于count(0) ≈ count(1) MyISAM： 每张表都会记录其总行数，直接返回，效率很高，由表级锁保证一致性，但如果有条件查询，效率就和InnoDB差不多了，因为要扫描表 count(1)：统计所有记录，包括null 比count(字段)快，因为不涉及解析数据行和拷贝字段值的操作 count(字段)：统计字段不为null的记录数 当字段为主键，并且表里只有主键索引时，InnoDB会循环遍历主键索引的B+树的叶子节点，并返回主键值，然后判断是否为null，不为null则count+1 当字段为主键，并且表里有二级索引时，InnoDB会循环遍历二级索引的B+树的叶子节点，因为主键索引的B+树叶子节点存储的是实际数据，二级索引B+树叶子节点存放的是主键值，所以二级索引树比主键索引树小，遍历比较快，有多个二级索引的情况下，InnoDB会选择索引长度最小的二级索引进行扫描 当字段为普通字段时，会采用全表扫描来计数 数据类型 类型 字节 参数 备注 tinyint 1 加unsigned 无符号整形(0, 255)，不加(-128, 127) smallint mediumint int&#x2F;integer 4 bigint 8 float 4 M总长度,D小数点长度 double 8 M总长度,D小数点长度 超出M则插入临界值 dec M总长度,D小数点长度 超出D则四舍五入 decimal M总长度,D小数点长度 精度高 char 固定长度耗费空间，但效率高 varchar 可变长度节省空间，但效率低 text &#x2F; bigtext blob 较大的二级制 binary 较短的二级制 varbinary 较短的二级制 enum set date 日期 time 时间 datetime 日期+时间 timestamp 时间戳，受时区影响 变量系统变量 查看所有系统变量 show global | [session] variables 查看满足条件的系统变量 show global | [session] variables like &#39;&#39; 查看指定的系统变量的值 select @@global | [session] 系统变量名 为系统变量赋值 set global | [session] 系统变量名 = 值 set @@global | [session].系统变量名 = 值 全局变量 查看所有全局变量 show global variables 查看满足条件的全局变量 show global variables like &#39;&#39; 查看指定的全局变量的值 select @@global.全局变量名 为全局变量赋值 set @@global.全局变量名 = 值 必须拥有super权限才能为系统变量赋值，作用域为整个服务器 会话变量 查看所有会话变量 show session variables 查看满足条件的会话变量 show session variables like &#39;&#39; 查看指定的会话变量的值 select @@session .会话变量名 为会话变量赋值 set @@session .会话变量名 = 值 set session 会话变量名 = 值 作用域为当前的会话&#x2F;连接 自定义变量用户变量 声明并初始化 set @用户变量名=值: set @用户变量名:=值: select @用户变量名:=值: 赋值 set @用户变量名=值: set @用户变量名:=值: select @用户变量名:=值: select 字段 into 用户变量名 from 表 使用 select @用户变量名 局部变量 声明 declare 变量名 类型 declare 变量名 类型 default 值 赋值 set @局部变量名=值: set @局部变量名:=值: select @局部变量名:=值: select 字段 into 局部变量名 from 表 使用 select @局部变量名 定义只能放在begin-end中的第一句 游标 声名 declare 游标名称 cursor for 查询语句 打开 open 游标名称 获取游标记录 fetch 游标名称 into 变量[变量] 关闭游标 close 游标名称 条件处理DECLARE handler action HANDLER FOR condition_value [, condition_value]...statement handler action CONTINUE: 继续执行当前程序 EXIT: 终止执行当前程序 condition value SOLSTATE sglstate value: 状态码，如 02000 SQLWARNING: 所有以01开头的SOLSTATE代码的简写 NOT FOUND: 所有以02开头的SOLSTATE代码的简写 SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写 事务特性（ACID） 原子性(Atomicity) 事务是一个不可分割的工作单位，要么都发生，要么都不发生 一致性(Consistency) 事务必须使数据库从一个一致性状态变换到另外一个一致性状态 隔离性(Isolation) 一个事务的执行不能被其他事务干扰 持久性(Durability) 事务一旦被提交，对数据库的改变就是永久性的 创建事务 隐式事务 没有明显的开启和结束的标记 如insert，update，delete 显式事务 有明显的开启和结束的标记 需要先设置自动提交功能为禁用 set autocommit&#x3D;0; 当前会话有效 开启事务 start transaction 可选 编写sql语句 结束事务 commit 提交事务 rollback 回滚事务 可能出现的问题 脏读 T1读取了T2还没有提交的事务 不可重复读 T1俩次读取T2同一字段的值不同 幻读 T1多次读取T2同一字段返回的数据行数不同，因为T2做了插入操作 隔离级别 oracle支持两种隔离级别 read commited 默认 serializable Mysql支持四种隔离级别 repeatable read 可重复读 mysql默认 多次读一个字段值值相同，禁止其他事务对这个字段进行更新 可避免脏读和不可重复读，仍存在幻读 read uncommitted 读未提交数据 允许事务读取其他事务未提交的数据 脏读，不可重复读，幻读都不可避免 read commited 读已提交的数据 允许事务读取其他事务已提交的数据 可避免脏读，但不可重复读和幻读不可避免 serializable 串行化 最高级别 事务操作期间加锁，其他事务无法操作 脏读，不可重复读，幻读都可避免 性能十分低下 SavePoint 搭配rollback to 使用 delete和truncate在事务使用时的区别 delete支持回滚，truncate不支持回滚 视图视图的好处 重用sql语句 简化sql操作，屏蔽查询细节 保护数据，提高安全性 临时的表 视图的创建create view 视图名 as 查询语句 虚拟表，和普通表一样使用 相当于给查询起别名 视图的修改create or replace view 视图名 as 查询语句 alter view 视图名 as 查询语句 删除视图drop view 视图名，视图名,... 查看视图desc 视图名 show create view 视图名 视图的更新 视图插入数据原表也会插入 视图插入数据需要原表和视图都要有相同的字段 视图可以增删改，原始表会受到影响，一般很少会这样用 视图一般会添加权限，只可读不可写 具备以下特点的视图不允许更新 包含分组函数，distict，group by，having，union&#x2F;union all 常量视图 select 常量 select ‘john’ name； Select中包含子查询 连接（join） 可以更改数据 from后是一个不能更新的视图 where子句的子查询引用了from子句中的表 视图的检查 MySQl允许在一个视图上再创建一个视图，为了保证两个视图的一致性，提供了两个属性检查方式 创建包含视图的视图语句 + with cascaded check option 级联，对其依赖的视图或表也有约束，需要同时满足两条语句的规则 创建包含视图的视图语句 + with local check option 仅检查当前语句 存储过程作用 减少网络交互提升效率 用法1234create procedure 存储过程名(参数列表)begin\t合法的sql语句end 参数列表包含三部分：参数模式，参数名，参数类型 参数模式 in 作为输入，需要传值 out 作为输出，即返回值 inout 既是输入，也是输出 delimiter 结束标记 修改结束标记为指定的结束符号 调用 call 存储过程名(实参列表) 删除 drop procedure 存储过程名 查看存储过程的信息 show create procedure 存储过程名 注意 如果方法体只有一句话，可以省略begin end语句 方法体中每条sql结尾都需要加分号 存储函数1234create function 函数名(参数列表) returns 返回类型begin\t函数体end 调用 select 函数名(参数列表) 查看 show create function 函数名 删除 drop function 函数名 注意 有且仅有一个返回值 参数列表包含二部分：参数名，参数类型 参数列表只能是int类型 循环结构分类 while 123while 循环条件 do\t循环体;end while; loop 1234循环名:loop\t循环体;\titerate / leave 循环名end loop; iterate 相当于continue; leave 相当于break; repeat 1234repeat\t循环体;until 结束循环的条件end repeat; InnoDB引擎逻辑存储结构 表空间：存记录、索引 Segment段：数据段（叶），索引段（非叶）、回滚段 Exten区：1M，64页，会申请4-5个区 Page页：16kb，最小单元，操作都是以页为单位的 Row行：数据 内存架构 BufferPoll 缓冲池 默认是128m，使用hash表 缓存的是经常操作的真实数据，执行增删改时会先操作缓存中的数据（没数据的话会先从磁盘加载并缓存），之后按一定时间频率刷进磁盘 freePage：未使用的页，使用freelist管理 cleanPage：有数据但未修改的页 dirtyPage：数据被修改的页 ChangeBuffer 更改缓冲区 针对非唯一 二级索引 增删改时BufferPoll中没数据，先记录操作 8.0之后引入的change Buffer，以前是insert buffer 更新流程 更新操作，判断是否是非唯一二级索引 AdaptiveHashIndex 自适应哈希索引 用于优化BufferPoll数据的查询 Innodb会监控表上索引页的查询，发现走hash更快时会建立hash索引 LogBuffer 日志缓冲区 保存redo log、undo log 磁盘结构 事务原理 通过两个日志，保证原子性，一致性，持久性 通过MVCC+锁，保证隔离性 redo log 记录的是数据的修改，保证持久性 由 redo log buffer 和 redo log file 组成，前者在内存中，后者在磁盘中 执行数据变更操作时，数据会先加载到内存中，然后在内存中更新，同时写入 redo log buffer 再由 redo log buffer写入redo log file，内存中的数据也会更新到数据库中 事务未提交时，redo log中的记录处于prepare状态 事务提交后，会将记录修改为commit状态，然后把所有修改数据的记录刷新到磁盘中（redo log file 中） redo log 记录的是一定时间内的修改操作，不会存储历史变更，当数据刷新到磁盘时，redo log 中的数据就失效了 undo log 记录的是数据被修改前的信息，保证原子性 undo log 是逻辑日志 当delete一条记录时，undo log会记录一条对应的插入数据 当update一条记录时，undo log会记录一条相反的update数据 发生回滚时执行undo log即可 undo log 在事务执行时产生，事务提交时，undolog不会立即删除，因为还用于MVCC（快照读） 如果是insert，产生的undolog日志只在回滚时需要，在事务提交后可被立即删除 undo log 采用段的方式进行管理和记录，存放在rollback segment回滚段中，内部包含1024个undo log segment MVCC（多版本并发控制） 当前读 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对当前读取的记录加锁，意向锁都是一种当前读 快照读 简单的select（不加锁）是快照读，读取的记录的可见版本，有可能是历史数据，不加锁，是非阻塞读，不同的事务隔离级别，快照读有不同的实现 ReadCommitted：每次select都是快照读（每次数据都可能不同） Repeatable Read：只有第一次select是快照读（后续的数据和第一次相同） Serializable：快照读退化为当前读，每次都一样且加锁 特点 维护一个数据的多个版本，使得读写操作没有冲突 MVCC的具体实现需要依赖记录中的三个隐式字段，还有undo log版本链，readView DB_TRX_ID：最近修改事务的ID，记录增删改记录的事务ID DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本，用于配合undo log DB_ROW_ID：隐藏主键，如果表结构没有指定主键，将会生成隐藏主键 undo log版本链 不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录 readview快照读 是SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的未提交的事务id，包含了四个核心字段 m_ids：当前活跃的事务ID集合 min_trx_id：最小活跃事务ID max_trx_id：预分配事务ID，当前最大事务ID+1 creator_trx_id：readview创建者的事务ID 版本链数据访问规则（trx_id 表示当前事务ID） trx_id &#x3D;&#x3D; creator_trx_id：数据是当前事务更改的，可以访问 trx_id &lt; min_trx_id：数据已经提交了，可以访问 trx_id &gt; max_trx_id：该事务是在ReadView生成后才开启的，可以访问 min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id：数据已经提交，trx_id不在m_ids中可以访问 不同的隔离级别，生成ReadView的时机不同 READ COMMITTED：在事务中每一次执行快照读时生成ReadView REOEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView 锁机制全局锁 加锁 flush 数据据库名 with read lock 在备份时默认会加锁，我们可以加上 –single-transaction来完成不加锁备份 mysqldump --single-transaction -uroot -p 数据库名&gt;文件名.sql 表级锁读写锁表共享读锁 load tables 表名... read unlock tables 表独占写锁 load tables 表名... write unlock tables 元数据锁（MDL） 由系统自动控制，在访问一张表时会自动加上，MDL锁主要是维护元数据的数据一致性，在表上有活动事务时，不可以对表进行写入操作 对表进行增删改查时，加MDL读锁（共享） 对表结构进行修改时，加MDL写锁（排他） 查看元数据锁 select object_type, object_schema, object_name, lock_type, lock_duration from performance_schema.metadata_locks; 意向锁意向共享锁 select ... lock in share mode 意向排他锁 insert / update / delete / select ... for update 行级锁 是通过对索引数据页上的记录加锁实现的 对唯一索引进行检索时，进行等值匹配会自动优化为行锁 不对索引进行检索时，会升级为表锁 行锁 共享锁S： 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁 ...lock in share mode 排他锁X： 允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁 .. for update 间隙锁 锁的是索引记录的间隙，确保索引记录间的间隙不变 间隙锁可以共存，同事务中可加多个间隙锁 临键锁（next-key lock） 间隙锁 + 行锁 日志错误日志 进入log下输入 tail -f 查看实时日志 二进制日志（binlog） 记录了所有DDL、DML语句 用于数据恢复、主从复制 在事务提交的时候将记录刷新到磁盘 日志格式 STATEMENT：记录的是sql语句，修改也会记录 ROW：记录的是每一行的数据变更（默认） MIXED：混合了以上两种，默认是STATEMENT，某些特殊情况是ROW 日志删除 由于每天的binlog数据巨大，需要及时清除 reset master 删除全部日志，编号从01开始 purge master logs to &#39;binlog.编号&#39; 删除编号之前的所有日志 purge master logs before &#39;yyy-mm-dd hh24:mi:ss&#39; 删除这个 时间点之前产生的所有日志 查看binlog是否打开 show variables like &#39;%log_bin%&#39; 主要用作主从复制和数据恢复 查询日志 记录所有操作，默认关闭 慢查询日志 记录执行时间超过long_query_time的sql语句，默认关闭 注意 MySQL默认是关闭批处理的，需要在配置文件中的url加上?rewriteBatchedStatements=true 死锁解决 首先要解决死锁问题，在程序的设计上，当发现程序有高并发的访问某一个表时，尽量对该表的执行操作串行化，或者锁升级，一次性获取所有的锁资源。 然后也可以设置参数innodb_lock_wait_timeout，超时时间，并且将参数innodb_deadlock_detect 打开，当发现死锁的时候，自动回滚其中的某一个事务。","tags":["数据库"],"categories":["数据库"]},{"path":"/2024/01/18/Note/数据库/AIDB/","content":"简介架构客户端 请求 AI模型请求文本解析 服务端 请求解析 接收请求 线程调度 解析数据 生成数据访问流 请求处理 生成执行代码 执行代码 访问数据，写入日志 存储访问 索引扫描 数据扫描 数据操作 日志访问 日志操作 磁盘 数据读写 模块 网关 连接层 数据访问层 日志处理层 事务处理层 数据存储层"},{"title":"ElasticSearch","path":"/2024/01/18/Note/数据库/ElasticSearch/","content":"简介 也算是一个数据库，可以从海量数据中检索出想要的数据 所有的操作都封装了对应的RestAPI，方便使用 定义 属性 对应 Index 数据库 Type 表 Document 文档 Field 字段 概念 全文搜索 相关性 评价查询与结果的相关程度，并进行排序 分析 将文本转换为token，目的是为了创建倒排索引，查询倒排索引 倒排索引 根据属性值找记录，记录属性值在记录中出现的频率 先将记录进行分词，记录分词对应的记录 搜索时也会将搜索词进行分词，然后去找对应的记录 找到的记录进行相关性评分，评分高的返回 单次搜索 检查字段类型 分析查询字符串 查找匹配文档 为每个文档评分 多次搜索 &quot;minimum_should_match&quot; : &quot;40%&quot; 设置多词之间匹配度 &quot;operator&quot; : &quot;and / or&quot; 设置多次之间的关系 组合搜索 12345678910111213141516171819&quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;&quot;: &quot;&quot; &#125; &#125;, &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;&quot;: &quot;&quot; &#125; &#125;, &quot;should&quot;: &#123; &quot;match&quot;: &#123; &quot;&quot;: &quot;&quot; &#125; &#125; &#125;&#125; 计算每个文档的相关度评分_score，将所有匹配的must和should语句的分数求和，除于must和should语句的条数 should中的内容不是必须匹配的，但是语句中没有must的话，那么至少会匹配一个 权重 should中通过boost来设置权重 短语匹配 词和顺序都要匹配 slop：跳过n个词进行匹配 使用 路径 http://localhost:9200/ 基本信息 路径 请求格式 作用 &#x2F;_cat&#x2F;nodes Get 查看所有节点 &#x2F;_cat&#x2F;health Get 查看es健康状态 &#x2F;_cat&#x2F;master Get 查看主节点 &#x2F;_cat&#x2F;indices Get 查看所有索引 CRUD 注意 ES新版本去除了类型type 插入数据不携带id就新增，携带就是修改 123456789POST esIp:9200/索引名/类型/id&#123; &quot;settings&quot;: &#123; &quot;index&quot;: &#123; &quot;number_of_shards&quot;: &quot;2&quot;, #分片数 &quot;number_of_replicas&quot; : &quot;0&quot; #副本数 &#125; &#125;&#125; 修改数据 必须携带id 通过覆盖实现的更新 每次覆盖更新版本会加一，乐观锁机制 发起请求时携带 ?if_seq_np= &amp;if_primary_term= 1234PUT url:端口号/索引名/类型/id&#123; &quot;&quot;: &#125; 局部更新123456POST/PUT url:端口号/索引名/类型/id/_update&#123; &quot;doc&quot;:&#123; &quot;&quot;: &quot;&quot; &#125; &#125; 路径使用_update就必须携带&quot;doc&quot;:&#123;&#125; 体 会对比待更新的数据，一样则不更新，版本号不会自增 删除数据1234#删除对应的数据DELETE url:端口号/索引名/类型/id#删除suo&#x27;yinDELETE url:端口号/索引名 查询数据1GET url:端口号/索引名/类型/id 1GET url:端口号/索引名/类型/_search 搜索全部数据，默认返回10条 1GET url:端口号/索引名/类型/_search?q=age:20 添加关键字 DSL搜索查询数据时可以携带Json体，请求类型为POST 全文搜索 12345678POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;张三 里斯&quot; &#125; &#125;&#125; 高亮显示 12345&quot;highlight&quot;: &#123; &quot;fields&quot;: &#123; &quot;name&quot;: &#123;&#125; &#125;&#125; 聚合搜索 桶聚合,类似sql中的分组 可以指定size 12345678910POST url:端口号/索引名/类型/_search&#123; &quot;aggs&quot;: &#123; &quot;all_interests&quot;: &#123; &quot;terms&quot;: &#123; &quot;fields&quot;: &quot;age&quot; &#125; &#125; &#125;&#125; 度量聚合 min、avg、max 分页搜索 类似sql中的分页 size: 结果数 from: 跳过数 文档 美化 在查询语句后添加?pretty 可以美化返回的json 指定响应字段 GET请求，指定返回字段，会返回元数据 1GET url:端口号/索引名/类型/id/?_source=返回的字段 返回数据，不返回元数据 1GET url:端口号/索引名/类型/id/_source //返回全部数据 1GET url:端口号/索引名/类型/id/_source?_source=返回的字段 判断文档是否存在 1HEAD url:端口号/索引名/类型/id 批量操作批量查询1234POST url:端口号/索引名/类型/_mget&#123; &quot;ids&quot;: [&quot;&quot;,&quot;&quot;]&#125; 批量增删改 格式 &#123;&quot;操作&quot;:&#123;元数据&#125;&#125; 每条操作记录都是独立的，失败的不会影响到其他操作的执行 12345678POST url:端口号/_bulk&#123; //插入 &#123;&quot;create&quot;: &#123;&quot;_index&quot;:&quot;索引名&quot;, &quot;_type&quot;:&quot;类型&quot;,&quot;_id&quot;:id&#125;&#125; &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;name1&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;男&quot;&#125; //删除\t&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;索引名&quot;, &quot;_type&quot;:&quot;类型&quot;,&quot;_id&quot;:id&#125;&#125;&#125; 映射 String 新版不支持了，需要有全文搜索用text，不需要就用keyword 查看映射 1GET url:端口号/索引名/_mapping 结构化查询 term 12345678POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;age&quot;: 20 &#125; &#125;&#125; 用于精确匹配 terms 12345678POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;terms&quot;: &#123; &quot;tag&quot;: [&quot;&quot;,&quot;&quot;,&quot;&quot;] &#125; &#125;&#125; 类似sql中的in range 1234567891011POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gte&quot;: 20, &quot;lt&quot;: 30 &#125; &#125; &#125;&#125; gt、gte、lt、lte exists 12345678POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;exists&quot;: &#123; &quot;field&quot;: &quot;title&quot; &#125; &#125;&#125; match 12345678POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;tweet&quot;: &quot;About Search&quot; &#125; &#125;&#125; bool 12345678910POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123;&quot;term&quot;: &#123;&#125;&#125; //相当于and &quot;must_not&quot;: &#123;&quot;term&quot;: &#123;&#125;&#125; //相当于not &quot;should&quot;: &#123;&quot;term&quot;: &#123;&#125;&#125; //相当于or &#125; &#125;&#125; 过滤查询 123456789101112POST url:端口号/索引名/类型/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;age&quot;: 20 &#125; &#125; &#125; &#125;&#125; 查询和过滤的对比 过滤会询问每个文档的字段值是否包含特定值 查询户询问每个文档的字段值与特定值的匹配程度 过滤会缓存结果，高效 查询语句比过滤语句耗时 分词 内置分词 123456POST url:端口号/_analyze&#123; &quot;analyzer&quot;: &quot;分词器&quot;, &quot;field&quot;: &quot;字段&quot;, &quot;text&quot;: &quot;&quot;&#125; 内置分词器有 Standard，按单词划分，会转化为小写 Simple，按照非单词划分，转小写 Whitespace，按空格切分 Stop，去除语气词后划分 Keyword，不做分词处理 中文分词 IK分词器 分布式文档计算存储节点位置：shard = hash(routing) % number_of_primary_shards 文档搜索 查询 客户端发送搜索请求，节点收到后，创建一个from+size大小的空优先队列，然后将请求转发到其他分片 每个分片在本地执行这个请求，将结果存入优先队列 每个分片返回id和队列中的排序值给一开始接收请求的分片，这个分片合并这些值到自己的优先队列中后返回 取回 协调节点辨别出哪个Document需要取回，并且向相关分片发出GET请求 每个分片加载document并且根据需要丰富它们，然后再将document返回协调节点 一旦所有的document都被取回，协调节点会将结果返回给客户端 调优集群节点 master节点 配置文件中node.master设置为true，则有资格被选为master节点 创建&#x2F;删除索引，管理非master data节点 配置文件中node.data设置为true，就有资格 CRUD 客户端节点 node.master和node.data都为false 响应客户的请求，转化请求 部落节点 配置tribe.*，则是一个部落节点 可以连接多个集群，在所有集群上进行搜索等操作 分片和副本 一个分片是一个最小级别的工作单元，他只是保存了索引中所有数据的一部分 我们需要知道分片就是一个Lucene实例，并且它本身就是一个完整的搜索引擎，应用程序不会和它直接通信 分片可以是主分片或者是复制分片 索引中的每个文档属于一个单独的主分片，所以主分片的数量决定了所应最多能存储多少数据 复制分片只是主分片的一个副本，它可以防止硬件故障导致的数据丢失，同时可以提供读请求，比如搜索或者从别的分片取回文档 当索引创建完成的时候，主分片的数量就固定了，但是复制分片的数量可以随时调整 脑裂 master发生宕机，然后集群重新选举master，宕机的master恢复后，集群中出现了俩个master，会分成俩个集群 设置选举master数为：（N&#x2F;2）+ 1 可解决","tags":["数据库"],"categories":["数据库"]},{"path":"/2024/01/18/Note/工具库/其他/Git/","content":"合作流程使用GitHub的协作流程和分支保护策略来确保只有经过您验证的更改才能合并到主分支。以下是实现这个功能的步骤： 创建贡献指南：在项目的根目录下创建一个CONTRIBUTING.md文件，详细说明如何提交更改、分支命名约定、代码风格等。这可以确保贡献者了解并遵循您的要求和期望。 分支策略：要求贡献者在他们自己的分支上进行工作，而不是直接在主分支（通常是main或master）上进行更改。这样，您可以更好地控制哪些更改最终合并到主分支。 拉取请求（Pull Request）审查：要求贡献者通过拉取请求（Pull Request，简称PR）提交他们的更改。您可以设置PR模板，以便贡献者提供有关他们所做更改的详细信息。 保护主分支：在GitHub仓库设置中，您可以设置分支保护规则，以确保只有经过审查和批准的更改才能合并到主分支。 进入您的GitHub仓库。 点击“设置”（Settings）选项卡。 在左侧导航栏中，点击“分支”（Branches）。 点击“添加规则”（Add rule）按钮。 为主分支（例如main）设置保护规则。 在“需要拉取请求审查”（Require pull request reviews）部分，选择需要的审查人数（例如1人或更多）。 在“限制可以推送匹配的分支的用户”（Restrict who can push matching branches）部分，确保只有您或您信任的用户可以推送更改。 审查拉取请求：当贡献者提交PR时，您将收到通知。您可以在PR页面上查看他们的更改，运行任何自动化测试，并留下评论或建议。 合并拉取请求：一旦您对更改感到满意，并且任何测试都已通过，您可以批准PR并合并更改到主分支。 持续集成&#x2F;持续部署（CI&#x2F;CD）：如果您的项目使用CI&#x2F;CD流程，确保在合并到主分支之前运行自动化测试和构建。这可以帮助确保更改不会破坏现有的功能。 反馈和致谢：不要忘记向贡献者表示感谢和提供反馈！鼓励他们继续参与项目，并提供进一步的指导或建议。 通过遵循这些步骤，您可以确保只有经过您验证和批准的更改才会合并到您的博客网站项目中。 镜像仓库要让两个仓库关联起来，以便一个仓库更新时另一个仓库也自动更新，可以使用GitHub的镜像仓库功能或GitHub Actions来实现。下面是两种方法的简要说明： 方法一：使用GitHub的镜像仓库功能 在第一个仓库（源仓库）中，点击“Settings”（设置）选项卡。 在左侧导航栏中，点击“Repository”（仓库）选项。 滚动到“Mirroring”（镜像）部分，并点击“Add mirror”（添加镜像）按钮。 在弹出的对话框中，填写第二个仓库（目标仓库）的URL和认证信息。 选择同步设置，例如同步频率、是否仅同步特定分支等。 点击“Add mirror”（添加镜像）按钮。 设置完成后，第一个仓库的更新将自动同步到第二个仓库。请注意，此方法仅适用于公开仓库之间的镜像。 方法二：使用GitHub Actions 在第一个仓库中创建一个新的GitHub Actions工作流程文件，例如.github/workflows/sync.yml。 编辑该文件，添加以下内容： 1234567891011121314151617181920name: Sync Repositorieson: push: branches: [ main ] # 指定要同步的分支jobs: sync: runs-on: ubuntu-latest steps: - name: Checkout Source Repository uses: actions/checkout@v2 with: repository: &lt;源仓库的用户名&gt;/&lt;源仓库的名称&gt; ref: main # 指定要同步的分支 ssh-key: $&#123;&#123; secrets.SSH_PRIVATE_KEY &#125;&#125; # 使用SSH密钥进行认证 - name: Sync to Target Repository run: | git remote add target &lt;目标仓库的URL&gt; git push --mirror target 在第一个仓库的“Settings”（设置）选项卡中，点击“Secrets”（密钥）选项，并添加一个名为SSH_PRIVATE_KEY的密钥。将你的SSH私钥粘贴到该密钥的值字段中。请确保SSH私钥具有对第二个仓库的写入权限。 提交并推送该工作流程文件到第一个仓库。 当你在第一个仓库的指定分支上进行推送时，GitHub Actions将自动触发并执行该工作流程，将更新同步到第二个仓库。 请注意，此方法需要使用SSH密钥进行认证，并且你需要确保SSH密钥的安全性。"},{"path":"/2024/01/18/Note/工具库/web3/闪电网络/","content":"简介 小额交易、手续费便宜、交易速度快"},{"path":"/2024/01/18/Note/工具库/web3/审计/","content":"SlitherSecurify"},{"path":"/2024/01/18/Note/工具库/web3/钱包/","content":"简介 一般是通过助记词登录 Metamask"},{"path":"/2024/01/18/Note/工具库/web3/Hardhat/","content":"简介 1"},{"path":"/2024/01/18/Note/工具库/web3/Ganache/","content":"简介 临时部署区块链，不需要test网就能做测试 缺点是区块高度不会实时刷新 可以直连小狐狸钱包"},{"title":"电商","path":"/2024/01/18/Note/后端/Java/项目/电商/","content":"商品管理SKU和SPU SKU是 库存量单位 商品信息参数的聚合，如商品的规格参数 SPU是 标准化产品单元 商品信息的聚合，如一个概览信息，也成为销售属性 SPU像是类，SKU像是对象 分类-品牌-属性 各表之间独立存储，通过关联表关联 提供添加关联的功能 属性分组和规格参数关联 属性 属性分组 基本信息 主体信息 规格参数（基本参数） 详细的信息 销售属性 仓库管理库存维护采购单维护 合并采购单 将采购需求合并为一个采购单，并分配给对应的人员 需要为采购需求设置状态 新建、已分配、已领取、已完成、有异常 领取采购单 领取了采购单则标记为已领取 完成采购 需要判断全部采购完成还是部分采购完成 订单超时处理JDK自带的延时队列实现 把订单插入DelayQueue中，以超时时间作为排序条件，将订单按照超时时间从小到大排序。 起一个线程不停轮询队列的头部，如果订单的超时时间到了，就出队进行超时处理，并更新订单状态到数据库中。 为了防止机器重启导致内存中的DelayQueue数据丢失，每次机器启动的时候，需要从数据库中初始化未结束的订单，加入到DelayQueue中。 优点 简单，不需要借助其他第三方组件，成本低。 缺点 所有超时处理订单都要加入到DelayQueue中，占用内存大。 没法做到分布式处理，只能在集群中选一台leader专门处理，效率低。 不适合订单量比较大的场景。 RabbitMQ的延时消息实现一 使用官方提供的延时消息插件 RabbitMQ Delayed Message Plugin 优点 方便，易用 缺点 不是高可用的，节点挂起会导致消息丢失 实现二 消息的TTL+死信Exchange TTL： 即消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL，如果对队列设置，则队列中所有的消息都具有相同的过期时间。 超过了这个时间，我们认为这个消息就死了，称之为死信。 死信Exchange（DLX）：一个消息在满足以下条件会进入死信交换机 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。 TTL到期的消息。 队列满了被丢弃的消息。 优点 可以支持海量延时消息，支持分布式处理。 缺点 不灵活，只能支持固定延时等级。 使用复杂，要配置一堆延时队列。 RocketMQ的定时消息实现 只要在发送消息时设置延时时间即可 优点 精度高，支持任意时刻。 使用门槛低，和使用普通消息一样 缺点 使用限制：定时时长最大值24小时。 成本高：每个订单需要新增一个定时消息，且不会马上消费，给MQ带来很大的存储成本。 同一个时刻大量消息会导致消息延迟：定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。 Redis过期监听实现 redis配置文件开启”notify-keyspace-events Ex” 监听key的过期回调 每当我们对一个key设置了过期时间，Redis就会把该key带上过期时间，存到过期字典中，在redisDb中通过expires字段维护： 有定期删除和惰性删除两种 优点- 缺点 不可靠，不准确 定时任务分布式批处理实现 使用分布式任务调度系统SchedulerX，不但兼容主流开源任务调度系统和Spring @Scheduled注解，还自研了轻量级MapReduce模型[4]，针对任意异构数据源，简单几行代码就可以实现海量数据秒级别跑批 通过实现map函数，通过代码自行构造分片，SchedulerX会将分片平均分给超时中心的不同节点分布式执行 通过实现reduce函数，可以做聚合，可以判断这次跑批有哪些分片跑失败了，从而通知下游处理 优点 稳定性强，需要保证业务幂等 效率高，使用定时任务跑批方案，一次捞出一批订单，处理完了，可以批量更新订单状态，减少数据库的tps。在海量订单处理场景下，批量处理效率最高 可运维,基于数据库存储，可以很方便的对订单进行修改、暂停、取消等操作，所见即所得。如果业务跑失败了，还可以直接通过sql修改数据库来进行批量运维 免运维、成本低：不需要自建任务调度系统，由云上托管。 可观测：提供任务执行的历史记录、查看堆栈、日志服务、链路追踪等能力。 高可用：支持同城双活容灾，支持多种渠道的监控报警。 混部：可以托管阿里云的机器，也可以托管非阿里云的机器。 缺点 没法做到精度很高。定时任务的延迟时间，由定时任务的调度周期决定。如果把频率设置很小，就会导致数据库的qps比较高，容易造成数据库压力过大，从而影响线上的正常业务 所以一般需要抽离出超时中心和超时库来单独做订单的超时调度 抢红包问题分析 发红包 不需要加锁，发红包没有竞争 拆分红包 确保原子性并且不加锁 拆分红包使用二倍均值算法：抢到的金额 &#x3D; 随机（0，剩余红包金额 &#x2F; 剩余红包数 * 2） 存红包 红包存redis中的list，lpush存，lpop取，设置过期时间，返回一个红包的key 存redis后会有一个唯一key 抢红包 根据redis中存的红包key 用另一个hash表记录红包的消费信息 使用用户的token判断是否重复抢，没在hash中的才能抢 统计红包记录 根据hash表中记录的 红包回退 配置红包雨数量、金额、时间等 架构 redis集群（写 8万&#x2F;s） 秒杀总体思路 秒杀最主要的是查看商品详情页和下单两个模块 查看商品详情页 前端从CDN上取得页面数据，后端将页面静态化后存到cdn上 添加nginx做负载均衡，然后用redis缓存，nginx访问redis redis中没有数据再去查JVM缓存 JVM缓存中没有再去查数据库 下单 全局唯一ID 需要满足唯一性，安全性，高可用，高性能 使用Redis中的incrby实现 符号位（1）+ 时间戳（31）+ 序列号（32） 时间戳 &#x3D; 当前时间 - 自定义的一个过去的时间常量 序列号 &#x3D; “一些前缀” + 当前时间 + 1 返回 时间戳 &lt;&lt; 32 | 序列号 使用雪花算法 1bit + 时间戳（41）+ 机器id（10）+ 序列号（12） 同一毫秒生成的id不超过4095，超过4095则到下一毫秒生成 由于每一台机器的工作机器id不同，所以分布式环境下也不会冲突 防止库存超卖 CAS Synchronize 分布式锁 一人一单 需要在扣减库存前进行判断，并且把判断过程和扣减库存用synchronize锁住 以userId作为锁 在分布式系统下无法保证，需要使用分布式锁 异步秒杀 由于当前大多数业务都是在tomcat中串行执行的，效率低 把秒杀券信息也保存到redis中 所以我们可以把判断库存、扣减库存和一人一单校验放在redis中进行 使用lua脚本确保原子性 用户秒杀成功后将优惠券id和用户id存入阻塞队列中，将订单id返回给用户 开启线程任务不断读取阻塞队列中的订单异步下单 消息队列 使用Stream的Group（消费组）实现消息队列 消息分流 队列中的消息会分流给组内不同的消费者，从而加快消息处理速度 消息标示 会维护一个标识记录最后一个被处理的消息，即使宕机重启，还会从标识之后读取消息，确保每一个消息都被消费 消息确认 消费者获得消息后，消息会处于pending状态，并存入一个pending-list，当处理完消息后需要通过XACK来确认消息，标记消息已处理，才会从pending-list移除 可以阻塞读取 消息可回溯，即持久化存储 步骤 创建一个StreamGroup类型的消息队列，名为stream.orders XGROUP CREATE stream.orders g1 0 MKSTREAM 使用lua脚本向消息队列中添加消息 开启一个线程从消息队列中取出消息 判断信息是否为空 空继续下一轮循环 非空解析信息然后创建订单 确认消息队列中的消息 如果这个过程出现异常需要处理pending-list","tags":["模块"],"categories":["模块"]},{"title":"聊天模块","path":"/2024/01/18/Note/后端/Java/项目/即时通讯/","content":"WebSocket + MongoDB + RocketMQ步骤 处理消息（创建消息对象，实现消息的基本功能） 创建消息类并创建MongoDB中的集合（表） @Indexed设置索引 类中需要有User From和User to属性 实现消息的增删改查 查询点对点的聊天记录 123456789101112131415161718192021public List&lt;Message&gt; findListByFromAndTo(Long fromId, Long toId, Integer page, Integer rows)&#123; //设置查询条件 //用户A发送给用户B的条件 Criteria criteriaFrom = new Criteria().andOperator( Criteria.where(&quot;from.id&quot;).id(fromId),. Criteria.where(&quot;to.id&quot;).id(toId) ); //用户B发送给用户A的条件 Criteria criteriaTo = new Criteria().andOperator( Criteria.where(&quot;from.id&quot;).id(toId), Criteria.where(&quot;to.id&quot;).id(fromId) ); //创建查询条件对象 Criteria criteria = new Criteria().orOperator(criteriaFrom, criteriaTo); //设置分页，按发送时间降序 PageRequest pageRequest = PageRequest.of(page - 1, pageSize, Sort.by(Sort.Direction.ASC, &quot;send_data&quot;)); //设置查询条件，分页 Query query = Query.query(criteria).with(pageRequest); //需要查询语句和对象 return this.mongoTemplate.find(query, Message.class);&#125; 编写WebSocket 123456789101112131415161718@Componentpublic class MessageHandler extends TextWebSocketHandler implements RocketMQListener&lt;String&gt;&#123; @Override public void afterConnectionEstablished(WebSocketSession session) throws Exection&#123; //建立连接后要做的事情 &#125; //接收消息 @Override protected void handleTextMessage(WebSocketSession session, TextMessage textMessage) throws Exception&#123; //将消息保存到mongodb message = this.messageDAO.saveMessage(message); //发送消息 webSocketSession.sendMessage(new TextMessage(MAPPER.writeValueAsString(message))); //用户可能在其他节点中，先将消息发送到MQ中 //需要添加tag便于消费者筛选 this.rocketMQTemplate.convertAndSend(topic:tag, 序列化后的消息); &#125;&#125; 设置WebSocket拦截器 1234567891011121314@Componentpublic class MessageHandshakeInterceptor implements HandshakeInterceptor, WebSocketConfigurer&#123; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception&#123; //在客户端与服务端建立连接之前执行，握手之前进行一些处理 &#125; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry)&#123; registry.addHandler(this.messageHandler, &quot;/ws/&#123;uid&#125;&quot;) .setAllowedOrigins(&quot;*&quot;) //设置跨域请求 .addInterceptors(this); &#125;&#125; 分布式WebSocket 1234567891011121314@Component@RocketMQMessageListener( topic = &quot;&quot;, //topic selectorExpression = &quot;&quot;, //tag messageModel = , //消息模式：广播 / 集群 consumerGroup = &quot;&quot; //消费者组)public class MessageHandler implements RocketMQListener&lt;String&gt;&#123; //接收到MQ消息 @Override public void onMessage(String msg) throws Exception&#123; //找到该机器下的用户并给他发送消息 &#125;&#125; 处理消息 Message类 123456789101112131415161718192021@Data@AllArgsConstruceor@NoArgsConstructor@Document(collection = &quot;message&quot;) //指定@Builder //转变为建造者模式，链式构建对象public class Message&#123; @Id //主键 private ObjectId id; private String msg; @Indexed //需要建立索引 private Integer status; // 1-未读 2-已读 @Field(&quot;send_date&quot;) @Indexe //需要建立索引 private Date sendDate; @Field(&quot;read_date&quot;) private Date readDate; @Indexed //需要建立索引 private User from; @Indexed //需要建立索引 private User to; &#125; 创建User类 12345678@Data@AllArgsConstruceor@NoArgsConstructor@Builder //转变为建造者模式，链式调用public class User&#123; private Long id; private String username;&#125; 创建MessageDAO 接口，定义业务方法 123456789101112public interface MessageDAO&#123; //查询点对点的聊天记录 List&lt;Message&gt; findListByFromAndTo(Long fromId, Long toId, Integer page, Integer rows); //根据id查询数据 Message findMessageById(String id); //更新消息状态 UpdateResult updateMessageState(ObjectId id, Integer status); //新增消息，保存到mongodb Message saveMessage(Message message); //根据消息id删除数据 DeleteResult deleteMessage(String id);&#125; 创建MessageDaoImpl 实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Componentpublic class MessageDaoImpl implements MessageDAO &#123; @Autowired private MongoTemplate mongoTemplate; //查询点对点的聊天记录 public List&lt;Message&gt; findListByFromAndTo(Long fromId, Long toId, Integer page, Integer rows)&#123; //设置查询条件 //用户A发送给用户B的条件 Criteria criteriaFrom = new Criteria().andOperator( Criteria.where(&quot;from.id&quot;).id(fromId),. Criteria.where(&quot;to.id&quot;).id(toId) ); //用户B发送给用户A的条件 Criteria criteriaTo = new Criteria().andOperator( Criteria.where(&quot;from.id&quot;).id(toId), Criteria.where(&quot;to.id&quot;).id(fromId) ); //创建查询条件对象 Criteria criteria = new Criteria().orOperator(criteriaFrom, criteriaTo); //设置分页 PageRequest pageRequest = PageRequest.of(page - 1, pageSize, Sort.by(Sort.Direction.ASC, &quot;send_data&quot;)); //设置查询条件， 分页 Query query = Query.query(criteria).with(pageRequest); //需要查询语句和对象 return this.mongoTemplate.find(query, Message.class); &#125; //根据id查询数据 public Message findMessageById(String id)&#123; return this.mongoTemplate.findById(new ObjectId(id), Message.class); &#125; //更新消息状态 public UpdateResult updateMessageState(ObjectId id, Integer status)&#123; Query query = Query.query(Criteria.where(&quot;id&quot;).is(id)); Update update = Update.update(&quot;status&quot;, status); if(status.intValue() == 1) update.set(&quot;send_date&quot;, new Date()); if(status.intValue() == 2) update.set(&quot;read_date&quot;, new Date()); return this.mongoTemplate.updateFirst(query, update, Message.class); &#125; //新增消息，保存到mongodb public Message saveMessage(Message message)&#123; //需要写入发送时间，设置状态为1-未读 message.setSendDate(new Date()); message.setStatus(1); message.setId(ObjectId.get()); return this.mongoTemplate.save(message); &#125; //根据消息id删除数据 public DeleteResult deleteMessage(String id)&#123; Query query = Query.query(Criteria.where(&quot;id&quot;).is(id)); return this.mongoTemplate.remove(query, Message.class); &#125;&#125; 编写WebSocketMessageHandler 发送 &#x2F; 接收消息处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Component@RocketMQMessageListener( topic = &quot;&quot;, //topic selectorExpression = &quot;&quot;, //tag messageModel = , //消息模式：广播 / 集群 consumerGroup = &quot;&quot; //消费者组)public class MessageHandler extends TextWebSocketHandler implements RocketMQListener&lt;String&gt;&#123; //消息的增删改查 @Autowired private MessageDAO messageDAO; @Autowired private RocketMQTemplate rocketMQTemplate; //格式转换 private static final ObjectMapper MAPPER = new ObjectMapper(); //收集用户session对象，用于判断用户是否在线 private static final Map&lt;Long, WebSocketSession&gt; SESSION = new HashMap&lt;&gt;(); //建立连接后要做的事情 @Override public void afterConnectionEstablished(WebSocketSession session) throws Exection&#123; //用户建立连接后将用户Session收集 Long id = (Long) session.getAttributes().get(&quot;uid&quot;); //需要设置拦截器获取 SESSION.put(id, session); &#125; //发送消息 @Override protected void handleTextMessage(WebSocketSession session, TextMessage textMessage) throws Exception&#123; Long uid = (Long) session.getAttributes().get(&quot;uid&quot;); JsonNode jsonNode = MAPPER.readTree(textMessage.getPayload()); Long toId = jsonNode.get(&quot;toId&quot;).asLong(); String msg = jsonNode.get(&quot;msg&quot;).asText(); Message message = Message.builder() .from(UserData.USER_MAP.get(uid)) .to(UserData.USER_MAP.get(toId)) .msg(msg) .build(); //将消息保存到mongodb message = this.messageDAO.saveMessage(message); //判断目标用户是否在线 WebSocketSession toSession = SESSIONS.get(toId); if(toId != null &amp;&amp; toSession.isOpen())&#123; toSession.sendMessage(new TextMessage(MAPPER.writeValueAsString(message))); //将消息更新为已读 this.messageDAO.updateMessageState(message.getId(), 2); &#125; //分布式WebSocket else&#123; //用户可能在其他节点中，先将消息发送到MQ中 //需要添加tag便于消费者筛选 this.rocketMQTemplate.convertAndSend(topic:tag, 序列化后的消息); &#125; &#125; //消费消息 @Override public void onMessage(String msg) throws Exception&#123; JsonNode jsonNode = MAPPER.readTree(msg); long toId = jsonNode.get(&quot;to&quot;).get(&quot;id&quot;).longValue(); //判断to用户是否在线 WebSocketSession toSession = SESSION.get(toId); if(toId != null &amp;&amp; toSession.isOpen())&#123; toSession.sendMessage(new TextMessage(msg)); this.messageDAO.updateMessageState(new ObjectId(jsonNode.get(&quot;id&quot;).asText), 2); &#125; &#125;&#125; MessageHandshakeInterceptor 拦截器，用于获取用户id 12345678910111213@Componentpublic class MessageHandshakeInterceptor implements HandshakeInterceptor&#123; //在客户端与服务端建立连接之前执行，握手之前 @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception&#123; String path = request.getURI().getPath(); String[] ss = StringUtils.split(path, &#x27;/&#x27;); if(ss.length != 2) return false; if(!StringUtils.isNumeric(ss[1])) return false; attributes.put(&quot;uid&quot;, Long.valueOf(ss[1])); return true; &#125;&#125; WebSOcketConfig 添加拦截器 123456789101112131415@Configuration@EnableWebSocketpublic class WebSocketConfig implements WebSocketConfigurer&#123; @Autowired private MessageHandler messageHandler; @Autowired private MessageHandshakeInterceptor messageHandshakeInterceptor; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry)&#123; registry.addHandler(this.messageHandler, &quot;/ws/&#123;uid&#125;&quot;) .setAllowedOrigins(&quot;*&quot;) //设置跨域请求 .addInterceptors(this.messageHandshakeInterceptor); &#125;&#125; 查询历史信息，其实就是查询消息列表 创建MessageController 1234567891011121314@RequestMapping(&quot;message&quot;)@CrossOrigin //跨域public class MessageController &#123; @autowired private MessageService messageService; @GetMapping public List&lt;Message&gt; queryMessageList( @RequestParam(&quot;fromId&quot;) Long fromId, @RequestParam(&quot;toId&quot;) Long toId, @RequestParam(value = &quot;page&quot;, default = &quot;1&quot;) Integer page, @RequestParam(value = &quot;rows&quot;, default = &quot;10&quot; Integer rows)&#123;\treturn this.messageService.queryMessageList(fromId, toId, page, rows);&#125; 创建MessageService 12345678910111213141516@Servicepublic class MessageService&#123; @Autowired private MessageDAO messageDAO; public List&lt;Message&gt; queryMessageList(Long fromId, Long toId, Integer page, Integer rows)&#123; List&lt;Message&gt; list = this.messageDAO.findListByFromAndTo(fromId, toId, page, rows); //设置消息状态为已读 for(Message message : list)&#123; if(message.getStatus().intValue() == 1)&#123; this.messageDAO.updateMessageState(message.getId(), 2); &#125; &#125; return list; &#125;&#125; 创建UserController 123456789101112131415161718@RestController@CrossOrigin@RequestMapping(&quot;user&quot;)public class UserController&#123; @Autowired private MessageService messageService; @GetMapping public List&lt;Map&lt;String, Object&gt;&gt; queryUserList(@RequestParam(&quot;fromId&quot;) Long fromId)&#123; List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;&gt;(); for(Map.Entry&lt;Long, User&gt; userEntry : UserData.USER_MAP.entrySet())&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;() //获得对应的值 result.add(map); &#125; return result; &#125;&#125; Netty +","tags":["模块"],"categories":["模块"]},{"path":"/2024/01/18/Note/后端/Java/项目/头条/","content":"项目介绍 模块 公共模块 全局异常处理 全局返回值处理 远程调用模块 网关模块 测试模块 工具模块 类模块 公共类 用户（实体类） 服务模块 文章模块：文章管理 用户模块：用户管理 平台 用户移动端：内容查看、社交、登陆注册、个人中心、系统设置 自媒体端：内容管理、粉丝管理、评价管理、权限管理、个人看板、私信、素材、 设置 管理平台：内容管理、用户管理、数据统计、标签管理、公告管理、系统管理 支撑系统：爬虫、广告、推荐、计算、知识 技术栈 Nginx + Gateway + Nacos + MySQL + MongoDB + HBase + Kafka + Redis + ZK + XXL-Job + ES + Docker + Seata + Jenkins 表 用户相关 用户表、用户粉丝表、用户关注表、用户认证表 点赞模块Redis实现一人点一次 给Blog类中添加一个isLike字段，这个字段在数据库中不存在，标识当前用户是否点赞 需要添加@TableField(exist &#x3D; false) 利用redis的set集合实现 在首页的博客分页查询和根据id查询的时候判断当前用户是否点过赞，赋值给isLike字段 12345678910111213141516171819202122232425public void likeBlog(Long id)&#123; //获取登录用户 Long userId = UserHolder.getUser().getId(); String key = &quot;blog:liked:&quot; + id; //判断当前登录用户是否点赞 Double score = stringRedisTemplate.opsForZSet.score(key, userId.toString()); //如果未点赞，可以点赞 if(score == null)&#123; //数据库点赞数+1 boolean success = update().setSql(&quot;like = like + 1&quot;).eq(&quot;id&quot;, id).update(); //保存用户到redis集合中 if(success)&#123; stringRedisTemplate.opsForZSet.add(key, userId.toString(), System.currentTimeMillis()); &#125; &#125;else&#123; //如果已点赞，取消点赞 //数据库点赞数-1 boolean success = update().setSql(&quot;like = like - 1&quot;).eq(&quot;id&quot;, id).update(); //把用户从redis集合中删除 if(success)&#123; stringRedisTemplate.opsForZSet.add(key, userId.toString()); &#125; &#125; &#125; 点赞排行榜 先点赞的排在前面，需要修改之前校验一人一赞的数据类型，改为SortedSet 实现blogService.queryBlogLikes(Long id) 方法 12345678910111213141516171819public List&lt;UserDTO&gt; queryBlogLikes(Long id)&#123; String key = &quot;blog:liked:&quot; + id; //查询点赞前5名的用户 Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet.range(key, 0, 4); //如果为空返回空集合 if(top5 == null || top5.isEmpty()) return Collections.emptyList(); //解析出用户id List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collections.toList()); String idStr = StrUtil.join(&quot;,&quot;, ids); //根据id查询用户 List&lt;UserDTO&gt; userDTO5 = userService.query() //为了使查询的数据按照我们想要的顺序 .in(&quot;id&quot;, id).last(&quot;ORDER BY FIELD(id,&quot;+idStr+&quot;)&quot;).list() .stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.calss)) .collect(Collections.toList()); return userDTO5;&#125; 关注模块关注和取关123456789101112131415161718192021222324252627public void follow(Long followUserId, Boolean isFollow)&#123; //获取登录用户 Long userId = UserHolder.getUser().getId(); //判断是关注还是取关 if(isFollow)&#123; //设置关注信息，保存到数据库 Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followUserId); boolean isSuccess = save(follow); //为了后面的共同关注功能，需要将关注信息保存到redis中 if(isSuccess)&#123; //存入userId 和 followUserId String key = &quot;follows:&quot; + userId; stringRedisTemplate.opsForSet().add(key, followUserId.toString()); &#125; &#125;else&#123; //取关 boolean isSuccess = remove(new QueryWrapper&lt;&gt;() .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId)); //删除redis中的关注信息 if(isSuccess)&#123; stringRedisTemplate.opsForSet().remove(key, followUserId.toString()); &#125; &#125;&#125; 查看是否关注12345678public boolean isFollow(Long followUserId)&#123; //获取登录用户 Long userId = UserHolder.getUser().getId(); //c数据库是否存在关联数据 Integer count = query().eq(&quot;user_id&quot;, userId) .eq(&quot;follow_user_id&quot;, followUserId)).count(); return count &gt; 0;&#125; 共同关注 需要在用户关注的时候将用户的关注信息保存到redis中，用Set结构保存，可以查交集 12345678910111213141516171819202122public List&lt;UserDTO&gt; followCommons(LOng id)&#123; //获取登录用户id\tLong id = UserHolder.getUser().getId(); //当前登录用户在redis中的key值 String key1 = &quot;follows:&quot; + userId; //查看的用户在redis中的key值 String key2 = &quot;follows:&quot; + id; //求共同关注即交集 Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key1,key2); //判断是否有交集,无交集返回空list if(intersect == null || intersect.isEmpty()) return Collections.emptyList(); //解析id集合 List&lt;Long&gt; ids = intersect.stream() .map(Long::valueOf).collect(Collections.toList()); //根据id查询用户 List&lt;UserDTO&gt; users = userService.listByIds(ids) .stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.calss)) .collect(Collections.toList()); return users;&#125; 推送模块推模式 给用户创建一个收件箱，用户发送笔记时推送到所有粉丝的收件箱，收件箱要满足可以根据时间戳排序，使用redis实现 用户查询收件箱时实现分页查询 （SortedSet） 在用户发布笔记时将博客id存入redis 推送笔记到粉丝邮箱 12345678910//查询笔记作者的所有粉丝 List&lt;Follow&gt; follows = followService.query().eq(&quot;follow_user_id&quot;,user.getId()).list();//推送笔记id给所有粉丝 for(Follow follow : follows)&#123; //获取粉丝id Long userId = follow.getUserId(); //推送 String key = &quot;feed:&quot; + userId; stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis()); &#125; 粉丝邮箱读取笔记 需要先创建滚动分页的dto类 12345678@Datapublic class ScoreResult&#123; //查询的博客 private List&lt;?&gt; list; //上一次查询的时间，用于下一次查询作为最小值 private Long minTime; private Integer offset;&#125; 读取收件箱封装到ScoreResult中 12345678910111213141516171819202122232425262728293031323334353637383940414243public ScoreResult queryBlogOfFollow(Long max, Integer offset)&#123; //获取当前用户 Long userId = UserHolder.getUser().getId(); //查询收件箱 String key = &quot;feed:&quot; + userId; Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate //offset：跳过最大值的个数，0则包含 .opsForZset().reverseRangeByScoreWithScores(key, 0, max, offset, 2); if(typedTuples == null || typedTuples.isEmpty()) return; //解析数据 List&lt;long&gt; ids = new ArrayList&lt;&gt;(typedTuples.size()); long minTime = 0; int os = 1; for(ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples)&#123; //获取id ids.add(Long.valueOf(tuple.getValue())); //获取分数（时间戳） long time = tuple.getScore().longValue(); if(time == minTime)&#123; os++; &#125;else&#123; minTime = time; os = 1; &#125; &#125; //根据id查询blog String idStr = StrUtil.join(&quot;,&quot;, ids); List&lt;Blog&gt; blogs = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot;+idStr+&quot;)&quot;).list(); for(Blog blog : blogs)&#123; //查询blog有关的用户 queryBlogUser(blog); //查询Blog是否被点赞 isBlogLiked(blog); &#125; //返回 ScrollResult r = new ScrollResult(); r.setList(blogs); r.setOffset(os); r.setMinTime(minTime); return r;&#125; 拉模式推拉结合签到模块使用Reids的BitMap实现 签到 stringRedisTemplate.opsForValue.setBit(key, dayOfMonth - 1, true) 统计 12345List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(\tkey, BitFieldSubCommands.create() .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)) .valueAt(0));"},{"title":"MySQL源码","path":"/2024/01/18/Note/后端/Java/源码/MySQL/","content":"执行流程 首先客户端发起sql查询 sql到达服务器先经过连接器，进行身份、权限等校验 然后再经过分析器，进行词法分析和语法分析 mysql8.0之前会先去查询缓存中找 在经过优化器，以优化器认为最优的执行方案去执行 然后交给执行器，会先进行权限校验，权限通过就会去调用存储引擎的接口，进行具体的执行","tags":["code"],"categories":["源码"]},{"path":"/2024/01/18/Note/后端/Java/源码/Mybatis2/","content":"架构 组件及其调用关系 目录结构 解析配置文件读取xml文件流123456789public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException &#123; InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader); if (in == null) &#123; throw new IOException(&quot;Could not find resource &quot; + resource); &#125; else &#123; return in; &#125;&#125; 123public InputStream getResourceAsStream(String resource, ClassLoader classLoader) &#123; return this.getResourceAsStream(resource, this.getClassLoaders(classLoader));&#125; 12345678910111213141516171819202122ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123; return new ClassLoader[]&#123; classLoader, this.defaultClassLoader, Thread.currentThread().getContextClassLoader(), this.getClass().getClassLoader(), this.systemClassLoader&#125;;&#125;InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) &#123; ClassLoader[] var3 = classLoader; int var4 = classLoader.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; ClassLoader cl = var3[var5]; if (null != cl) &#123; InputStream returnValue = cl.getResourceAsStream(resource); //重试，尝试+&quot;/&quot;能不能获取到 if (null == returnValue) returnValue = cl.getResourceAsStream(&quot;/&quot; + resource); if (null != returnValue) return returnValue; &#125; &#125; return null;&#125; 构建SqlSessionFactory1SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 1234567891011121314151617181920public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123; SqlSessionFactory var5; try &#123; // XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); // // var5 = this.build(parser.parse()); &#125; catch (Exception var14) &#123; throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, var14); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; inputStream.close(); &#125; catch (IOException var13) &#123; &#125; &#125; return var5;&#125; 1234567891011121314public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123; // this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);&#125;private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; // super(new Configuration()); this.localReflectorFactory = new DefaultReflectorFactory(); ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser;&#125; 123456789101112131415161718192021222324252627282930313233343536373839public Configuration parse() &#123; //默认为false if (this.parsed) &#123; throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;); &#125; else &#123; //这个解析方法只能调用一次，即配置文件只能解析一次 this.parsed = true; this.parseConfiguration(this.parser.evalNode(&quot;/configuration&quot;)); return this.configuration; &#125;&#125;/* parser.evalNode 解析configuration节点及其子节点，封装到一个XNode对象中 parseConfiguration 解析XNode对象（properties、settings、environments、mapper等等） 1.将解析出的内容设置到configuration中 2.解析mapper*/private void parseConfiguration(XNode root) &#123; try &#123; this.propertiesElement(root.evalNode(&quot;properties&quot;)); Properties settings = this.settingsAsProperties(root.evalNode(&quot;settings&quot;)); this.loadCustomVfs(settings); this.loadCustomLogImpl(settings); this.typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); this.pluginElement(root.evalNode(&quot;plugins&quot;)); this.objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); this.objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); this.reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); this.settingsElement(settings); this.environmentsElement(root.evalNode(&quot;environments&quot;)); this.databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); this.typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); //解析mapper this.mapperElement(root.evalNode(&quot;mappers&quot;)); &#125; catch (Exception var3) &#123; throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + var3, var3); &#125;&#125; 12345private void mapperElement(XNode parent) throws Exception &#123; //获取&lt;mappers&gt;的子节点，解析属性 //获取子节点中的 url/resources ，转化为字节流，交给 XMLMapperBuilder 解析 //调用XMLMapperBuilder.parse 方法&#125; 12345678//根据传入的字节流，构建Document对象private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments) &#123; super(configuration); this.builderAssistant = new MapperBuilderAssistant(configuration, resource); this.parser = parser; this.sqlFragments = sqlFragments; this.resource = resource;&#125; 1234567891011public void parse() &#123; if (!this.configuration.isResourceLoaded(this.resource)) &#123; //获取mapper的命名空间，解析（cache、sql、resultmap、crud） this.configurationElement(this.parser.evalNode(&quot;/mapper&quot;)); this.configuration.addLoadedResource(this.resource); this.bindMapperForNamespace(); &#125; this.parsePendingResultMaps(); this.parsePendingCacheRefs(); this.parsePendingStatements();&#125; 123456789101112131415//解析crud标签private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123; Iterator var3 = list.iterator(); while(var3.hasNext()) &#123; XNode context = (XNode)var3.next(); XMLStatementBuilder statementParser = new XMLStatementBuilder(this.configuration, this.builderAssistant, context, requiredDatabaseId); try &#123; //解析，封装 statementParser.parseStatementNode(); &#125; catch (IncompleteElementException var7) &#123; this.configuration.addIncompleteStatement(statementParser); &#125; &#125;&#125; 123456789101112131415161718public void parseStatementNode() &#123; //获取标签中的id //判断标签是crud中的哪一个，设置标签类型 //解析属性 //解析sql，替换占位符，保存占位符中的值（重点） SqlSource sqlSource = langDriver.createSqlSource(this.configuration, this.context, parameterTypeClass); //解析属性 //通过构建者助手，创建MappedStatement对象，存入configuration中的MapperStatementMap中 this.builderAssistant.addMappedStatement( id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, (KeyGenerator)keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);&#125; 1234567891011public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) &#123; //初始化动态sql处理器，初始化节点处理器集合（when、where、if等等） XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType); /* 解析动态sql 将带有$&#123;&#125;的sql封装到TextSqlNode 将带有#&#123;&#125;的sql封装到StaticTextSqlNode 将动态SQL标签中的SQL信息分别封装到不同的SqlNode中，对应不同的节点处理器去解析 */ return builder.parseScriptNode();&#125; 创建SqlSession对象1SqlSession sqlSession = sqlSessionFactory.openSession(); 12345678910111213141516171819202122232425262728293031public SqlSession openSession() &#123; //参数：执行器类型、事务隔离级别、是否自动提交事务 return this.openSessionFromDataSource( //默认是简单执行器 this.configuration.getDefaultExecutorType(),(TransactionIsolationLevel)null, false );&#125;private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; DefaultSqlSession var8; try &#123; //获取Environment对象 Environment environment = this.configuration.getEnvironment(); //获得事务工厂对象 TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment); //创建事务对象 tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); //创建执行器对象，默认是SimpleExecutor，如果开启缓存的话会是CacheingExecutor（装饰器模式） Executor executor = this.configuration.newExecutor(tx, execType); //创建DefaultSqlSession对象 var8 = new DefaultSqlSession(this.configuration, executor, autoCommit); &#125; catch (Exception var12) &#123; this.closeTransaction(tx); throw ExceptionFactory.wrapException(&quot;Error opening session. Cause: &quot; + var12, var12); &#125; finally &#123; ErrorContext.instance().reset(); &#125; return var8;&#125; SqlSession执行流程 调用SqlSession对应的Api，传入statementId（namespace.id）和参数 获取BoundSql，里面的sql已经经过处理和解析了 如果有开启缓存则在查询时生成缓存key（默认是开启的） 对应的执行器去创建缓存key 根据缓存key去二级缓存中查数据，没有再去一级缓存中找，一级缓存没有再去查数据库，存到一个缓存中 查询数据库前会现在一级缓存中进行一个占位操作 然后查询数据库 获取configuration对象 调用configuration去构建StatementHandler相关处理器 使用的是RoutingStatementHandler去选择，是一个装饰器，并且执行插件 由StatementType决定（可配置），默认是PreparedStatementHandler 准备处理器，包括创建statement和动态参数的设置 获取一个连接，通过事务对象获取 创建Statement对象 通过parameterHandler参数处理器去设置参数 从boundSql获取每个占位符（#{}）中的值的集合 遍历，判断是入参还是出差，出差不处理 判断是否存在能处理该参数的类型处理器（TypeHandler）（入参类型） 使用TypeHandler为对应占位符赋值 返回statement对象 查询数据库 将statement对象转换为PreparedStatement对象 执行sql 使用ResultSetHandler处理结果集 获取ResultSet对象 通过Statement获取ResultSetWrapper 获取映射关系 通过Statement获取ResultMap 遍历ResultMap获取ResultSet 根据映射关系封装实体 构建默认的结果集处理器（DefaultResultHandler） 对结果集进行映射封装，将封装后的对象存入DefaultResultHandler 判断是否有内置嵌套结果映射，并进行相应的处理 将数据填充到占位的缓存中 SqlSession原理 门面模式 执行器原理 SimpleExecutor 简单执行器，每次执行sql都会进行预编译sql ReuseExecutor 重用执行器 分页原理 分页参数放到ThreadLocal中，拦截执行的sql，根据数据库类型重写sql，计算分页的各种数据 总结 源码中大量使用了工厂模式 SqlSessionFactory、DatasourceFactory、TransactionFactory 但是源码中很多地方都是使用的硬编码来和xml中的节点做匹配"},{"title":"Spring","path":"/2024/01/18/Note/后端/Java/源码/Spring/","content":"SpringIOCAOPJDK代理 被代理对象需要实现接口 JDK代理和被代理对象同级，兄弟关系 JDK代理前16次通过反射调用方法，后续都是 123456789101112ClassLoader loder = 被代理类.class.getClassLoader();//被代理对象Target target = new Target();接口 proxy = (接口) Proxy.newProxyInstance(loader, new Class[]&#123;接口.class&#125;, new InvacationHandler()&#123;@Override public Object invoke(Object proxy, Method method, Object[] args) throw Throable&#123; //执行增强 //调用被代理对象方法 Object result = method.invoke(target, args); return result; &#125;&#125;); CGLIB代理 CGLIB代理和被代理对象是父子关系，所以被代理对象不能是final修饰的 CGLIB可以通过方法代理直接调用被代理方法，不走反射 被代理对象的方法是final修饰的话不会有增强效果 1234567891011121314151617//被代理对象Target target = new Target();Target proxy = (Target) Enhancer.create(Target.class, new MethInteceptor()&#123; @Override public Object intercept(Object p, Method method, Object[] args, MethodProxy methodProxy) throw Throwable&#123; //执行增强 //调用被代理对象方法（反射） Object result = method.invoke(target, args); //调用被代理对象方法（直接调用）(需要被代理对象)（Spring使用） Object result = methodProxy.invoke(target, args); //调用被代理对象方法（直接调用）(不需要被代理对象) Object result = methodProxy.invokeSuper(p, args); return result; &#125;&#125;); 容器创建（Refresh方法） prepareRefresh 创建Environment对象 为@Value注入信息 obtainFreshBeanFactory 获取或创建BeanFactory 通过BeanDefinition把对象信息存放在map中 创建需要的对象 prepareBeanFactory 初始化BeanFactory中的成员变量 解析Spel表达式 注册类型转换器，解析#{} 进行依赖注入 准备后处理器集合beanPostProcessors postProcessBeanFactory web环境下的ApplicationContext要利用它注册新的scope，完善Web下的BeanFactory invokeBeanFactoryPostProcessors 对BeanFactory做扩展 解析@Configuration、@Bean、@Impor、@PropertySource registerBeanPostProcessors 创建并加入更多的后处理器，主要看BeanDefinitionMap中对象是否实现了PostProcessor接口，加入beanPostProcessors集合中 initMessageSource 创建MessageSource 实现国际化功能 initApplicationEventMulticaster 创建事件广播器 onRefresh 空实现，留给子类实现 SpringBoot中的子类可以在这里准备内嵌的web容器 registerListeners 创建事件监听器 finishBeanFactoryInitialization 初始化BeanFactory中的成员变量 解析${} 创建beanDefinitionMap中保存的对象 finishRefresh 创建生命周期处理器 BeanFactory实现类 DefaultListableBeanFactory 提供控制反转、基本的依赖注入、Bean生命周期的各个功能 默认无其他后处理器，解析不了注解，需要添加 1234567//添加后处理器AnnotationConfigUtils.registerAnnotationConfigProcessors(容器对象);//启动后处理器容器对象.getBeanOfType(BeanFactoryPostProcessor.class) ,values().stream().forEach(beanFactoryPostProcessor -&gt; &#123; beanFactoryPostProcessor.postProcessBeanFactory(容器对象);&#125;) 容器中的Bean对象在使用时才会创建（延迟创建），也可以提前创建 12//提前创建容器对象.preInstantiateSingletos() 默认不会解析 ${}、#{} ApplicationContext实现类 ClassPathXmlApplicationContext、FIleSystemXmlApplicationContext 创建DefaultListableBeanFactory 通过XmlBeanDefinitionReader中的loadBeanDefinitions() 读取Xml中的Bean AnnotationConfigApplicationContext 通过配置类创建容器 会自动添加常用的后处理器 AnnotationConfigServletWebServerApplicationContext 借助了内嵌的Tomcat 需要提供一些Bean ServletWebServerFactory DispatcherServlet DispatchServletRegistrationBean 非必须Bean Controller（web.servlet.mvc） 处理Request、Response 可以指定访问的url 生命周期 处理名称，检查缓存 解析别名，解析特殊符号，查询三级缓存看是否有创建好的Bean 处理父子容器 如果有父容器，回去父容器是否有创建好的Bean 父子容器的bean名称可以重复 优先找子容器Bean，子容器没有再找父容器 dependsOn 判断是否用使用dependsOn指定Bean的创建顺序 按不同的Scope创建Bean 实例化 通过构造函数创建 反射生成对象，堆中申请空间，给成员变量赋默认值 依赖注入 初始化 Bean属性注入 包括自定义属性和容器属性 Bean功能扩展 BeanPostProcessor AOP在此处实现 使用，通过容器对象调用getBean()方法获取Bean对象 销毁 三级缓存 &#x2F; 循环依赖 用于解决循环依赖的问题 循环依赖指的是对象创建时需要另一个对象，正好那个对象也在创建并等待该对象创建导致卡住 主要在设值注入、构造注入时出现 设值注入单例情况下使用三级缓存解决 原型对象不使用三级缓存，因为会大量存储于缓存中无法被gc 构造注入出现循环依赖是无解的，所以只能通过检测来避免 用一个容器存储，当对象创建时放入该容器，每当在需要依赖的时候就检测这个容器中是否有对应的对象，有的话就是发生了循环依赖 一级缓存：singletonObjects 存成品对象 createBeanInstances之后放置 Bean生命周期中后置处理器处理时存入 二级缓存：earlySingletonObjects 存半成品对象 第一次从三级缓存中确定对象是代理对象还是普通对象的时候放置，同时删除三级缓存 Bean生命周期中填充属性时存入 三级缓存：singletonFactories 存的是工厂对象，也是lambda表达式，value值是ObjectFactory，key是beanname 生成完整对象之后放到一级缓存，删除二三级缓存 Bean生命周期中调用构造方法时存入 事务原理​ 事务是由AOP来实现的，首先生成代理对象，通过TransactionInterceptor，调用invoke实现具体逻辑 解析方法上事务的相关属性，判断是否开启新事务 获取数据库连接，关闭自动提交，开启事务 执行具体的sql逻辑 成功：通过commitTransactionAfterReturning提交，通过doCommit实现 失败：通过commitTransactionAfterThrowing执行回滚，通过doRollBack实现 之后清除相关的事务信息，cleanupTransactionInfo 后处理器BeanPostProcessor AutowiredAnnotationBeanPostProcessor 解析@Autowired、@Value 内部调用的postProcessprProperties方法解析注解 通过findAutowiringMetadata找到加了@Autowired的成员信息metadata 调用metadata.inject方法进行依赖注入 获取成员信息的类型 封装为DependencyDescriptor对象 然后通过BeanFactory.doResolveDependency到容器里找对应的Bean ContextAnnotationAutowiredCandidateResolver 解析${} CommonAnnotationBeanPostProcessor 解析@Resource、@postConstruct、@PreDestroy ConfigurationPropertiesBindingPostProcessor 解析@ConfigurationProperties BeanProcessor ConfigurationClassPostProcessor 解析@Bean、@ComponentScan、@Import、@ImportResource MapperScannerConfigurer 讲mapper加入容器，解析@MapperScan 注解@Autowired@ComponentScan 获取包路径 转化为classpath的格式 通过容器的getResources方法获得路径下所有的类 判断类是否直接或间接加了@Component 通过CachingMetadataReaderFactory对象的getMetadataReader方法获得MetadataReader MetadataReader通过getAnnotationMetadata方法获得AnnotationMetadata对象 AnnotationMetadata对象调用hasAnnotation和hasMetaAnnotation判断是否直接或间接标注了@Component注解 加了注解就把这个bean封装到BeanDefinition 使用BeanDefinitionBuilder通过Bean名称获取BeanDefinition 通过AnnotationBeanNameGenerator生成Bean的名称 加入容器 @Bean 获取包路径 转化为classpath的格式 通过容器的getResources方法获得路径下所有的类 判断类是否直接或间接加了@Component 通过CachingMetadataReaderFactory对象的getMetadataReader方法获得MetadataReader SpringMVC自动配置 主要是通过@EnableAutoConfiguration及其内部注解实现 @AutoConfigurationPackage @Import(AutoConfigurationPackage.Registrar.class) 利用Registrar批量注册组件 @Import(AutoConfigurationImportSelector.class) 利用getAutoConfigurationEntry(annotationMetadata a) 给容器批量导入一些组件 调用getCandidateConfigurations(annotationMetadata, attributes) 获取所有需要导入的容器中的配置类&#x2F;组件 利用了SpringFactoriesLoader（Spring工厂加载器）的loadFactoryNames() 这个方法返回loadSpringFactories的Map得到所有的组件 loadSpringFactories方法会扫描当前系统里面所有的META-INF&#x2F;spring.factories 执行流程 用户发起HttpRequest请求，请求进入到 DispatcherServlet 默认路径是 “ &#x2F; ”，会匹配到所有的url SpringBoot会自动创建并加载DispatcherServlet的Bean 会创建Spring容器并执行refresh方法 第一次请求来时会初始化DispatcherServlet，然后到容器中找它依赖的组件，没有就用默认的 HandlerMapping、HandlerAdapter、HandlerExceptionResolver、ViewResolver DispatcherServlet 将请求转发给所有的 HandlerMapping，HandlerMapping 会找到能处理这些请求的Handler方法 这些Handler方法会被封装成HandlerMethod对象，并结合匹配到的拦截器，合并成HandlerExecutionChain（调用链）对象，然后一起返回给DispatcherServlet HandlerMapping 会在初始化时就会建立好请求路径和处理器的映射关系 DispatcherServlet 收到这条调用链后 调用所有拦截器的preHandle方法，返回true才继续后续的调用 调用HandlerAdapter解析HandlerMethod并调用对应的Handler方法，准备数据绑定工厂、模型工厂，将HandlerMethod完善为ServletInvocableHandlerMethod 使用HandlerMethodArgumentResolver参数解析 调用ServletInvocableHandlerMethod 调用HandlerMethodReturnValueHandler处理返回值 有@ResponseBody注解的话直接返回Json 否则返回的是 ModelAndView ，然后进行视图解析和渲染 调用拦截器的postHandle方法 视图渲染或处理异常 如果1 - 3出现异常，ExceptionHandlerExceptionResolver处理 @ControllerAdvice增强5：@ExceptionHandler异常处理 视图解析即渲染 将 ModelAndView 转发给 ViewResolver 处理并返回 View 对象给 DispatcherServlet DispatcherServlet 再将渲染后的页面返回给客户端 调用拦截器的afterCompletion方法 SpringBoot执行流程 调用构造方法创建SpringApplication对象 根据各种来源添加BeanDefinition 推断应用程序类型(servlet, none, reacter) 准备初始化器，监听器 进行主类推断 执行run方法 得到SpringApplicationRunListeners事件发布器 发布7个事件 starting：开始启动 environmentPrepared：准备环境 contextPrepared：容器创建并调用初始化器 contextLoaded：Bean定义加载 started：refresh方法执行 running：springboot启动完成 封装args为ApplicationArgument对象 用DefaultApplicationArguments(args)封装 创建Environment对象 有系统属性和系统环境变量，优先找系统属性 对Environment中命名规范统一处理 对Environment做扩展增强 使用EnvironmentPostProcessor后处理器做增强 对Environment中以”spring.main”为前缀的key与SpringApplication容器对象做绑定 打印Banner 创建spring容器 应用初始化器的增强 得到所有的BeanDefinition 调用Application的refresh方法 调用所有实现ApplicationRunner和CommandLineRunner接口的Bean 自动装配 通过@EnableAutoConfiguration注解 SpringCloudNacos动态配置刷新 主要依赖推送和拉取 推送机制是指Nacos服务器在检测到配置变化时，主动通知客户端更新配置。Nacos服务器使用了长轮询的方式来实现推送 拉取机制是客户端每30秒会执行一次心跳检测，此时客户端也会执行一次配置拉取操作，如果发现配置有变化，则会触发配置更新的回调函数，可以保证nacos推送失败或者网络问题异常的情况下依然能获取最新的配置 回调函数是ContextRefresher类的refresh方法，该方法会触发一个RefreshEvent事件，该事件会被springcloud的组件监听并执行相应的刷新逻辑 原理是基于Environment、@RefreshScope、@Value 通过Environment获取的配置会自动刷新 通过@RefreshScope标注的Bean会重新创建并注入容器 通过@Value的字段会重新赋值 服务注册 调用register接口，传入ip、namespace、groupName、serviceName等等 解析request请求取得参数 如果没传namespace会使用默认的namespace 服务名称：groupName@@serviceName 解析request请求获得参数，封装为Instance对象 内部有两个集合，一个放临时实例，一个放永久实例 将参数封装为Instance对象，然后调用registerInstance注册该实例 创建空的服务service，只有第一次会创建，为了确保有服务对象 尝试从注册表中获取service 为空则创建，会记录服务最后一次更新时间 存进注册表，双重检查 添加实例到服务service中 为服务生成唯一标识 从注册表中拿到服务service 加锁，多实例间只能串行添加 拷贝注册表中旧的实例列表然后加上新注册的实例组成完整的实例列表","tags":["源码"],"categories":["源码"]},{"title":"JUC源码","path":"/2024/01/18/Note/后端/Java/源码/JUC/","content":"AtomicInteger12//自增自减都是通过这个方法实现，unsafe.getAndAddInt(this, valueOffset, 1 / -1); 123456789//复杂运算public final int updateAndGet(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return next;&#125; IntUnaryOperator是一个函数式接口，使用lambda传值 ConcurrentHashMap成员变量 sizeCtl 下一次扩容的阈值 默认为0，初始化时为-1 扩容时为 - (1 + 扩容线程数) Node 节点 ForwardingNode 继承Node 扩容时作为旧数组的头节点 ReservationNode 继承Node 在compute以及computeIfAbsent时，用来占位 计算完成后替换为普通Node TreeBin 继承Node 作为树的头节点 存储root和first 加了读写锁 TreeNode 继承Node 作为TreeBin的节点 存储parent，left，right Node[] table 哈希表 Node[] nextTable 扩容时的新哈希表 成员方法 tabAt 获取Node[]中第 i 个Node 参数：table，下标 casTabAt cas修改Node[] 中Node的值 参数：数组table、下标、旧值、新值 setTabAt 直接修改Node[] 中 Node的值 参数：数组table、下标、新值 构造方法 &#x2F; 初始化 1.7 初始化时就会创建segment数组和HashEntry数组的0号元素 segment数组默认大小16 初始化后segment数组的长度就不能改变 并发度是ConcurrentHashmap的长度（segment数组的大小） 这个数组的0号元素为其他HashEntry数组的创建提供原型 每个片段下的数组大小 &#x3D; 容量 &#x2F; 并发度 最小值为2，数组的元素数量超过阈值（0.75）就会扩容 指定容量时大于等于接近等级的容量x0.75时，容量会升一级创建 1.8 懒惰初始化，第一次put数据时才会创建数组结构，默认初始容量是16 无参构造创建时，数组初始容量是16 初始化时传了容量大小时，判断是否超过容量×负载因子 大于则创建下一个阶段的大小 索引计算 1.7 segment数组索引 并发度为16（2^4^）时，看二次hash值的高四位 并发度为32（2^5^）时，看二次hash值的高五位 数组索引 数组的大小为2（2^1^）时，看二次hash的低一位 数组的大小为4（2^2^）时，看二次hash的低二位 put方法 1.7 头插法 hash找segement，内部数组执行put操作 使用cas初始化槽 通过tryLock()获取锁，获取不到就重试，再获取不到就lock住，直到获取锁 1.8 尾插法，锁链表头或红黑树根节点 get方法 1.7 计算hash找segement，再hash找数组，再遍历链表 没加锁，需要考虑并发问题 get时有put操作 源码中使用了CAS保证初始化segement时也能get 源码中使用了UNSAFE.putOrderedObject保证put后的数据也能被get到 源码中使用了volatile 保证扩容时数据也能被get到 get时有remove操作 源码中使用了UNSAFE.putOrderedObject保证remove后的数据不会被get到 源码中使用了volatile 保证remove时数据不会被get到 1.8 计算hash，找数组对应位置 如果hash值为0，说明正在扩容或者是红黑树 初始化table方法 1.8 size计算实际发生在put，remove改变集合元素的操作之中 没有竞争发生，向baseCount累加计数 有竞争发生，新建counterCells，向其中的一个cell累加计数 counterCells初始有两个cell 如果计数竞争比较激烈，会创建新的cell来累加计数 链表转红黑树 1.8 扩容 1.7 segement不能扩容，扩容的是HashEntry数组 元素个数 &gt; 容量 × 负载因子 时扩容，大小变为2倍，先扩容，再插值 1.8 元素个数 &gt;&#x3D; 四分之三时扩容，与负载因子无关 以链表为单位，从后往前迁移数据，处理完当前位置会在这个位置打上标记（forwardingNode） 可以多个线程帮忙扩容，一个线程扩容16个位置，从后往前做数据迁移 ReentrantLock 锁的竞争是用的CAS机制来实现的 没有竞争到锁时是使用AQS来存储竞争锁的线程 锁的重入是内部变量记录了当前持锁线程的id，重入时判断id是否相同 ThreadLcoalLongAdder成员变量 Cell[] cells 累加单元数组，懒惰初始化，24字节 base 基础值，如果没有竞争，则用cas累加这个域 cellsBusy 在cells创建或扩容时，置位1，表示加锁 Cell 内部维护一个value值 用cas进行累加 一个缓存行(64字节)可以存下2个Cell，但是会有问题 当有两个线程同时修改同一个缓存行中的cell时，一方的修改会导致另一方失败 @sun.misc.Contended可以解决这个问题，它通过在对象的前后各加上128字节的padding，从而让cpu将对象预读至不同的缓存行，所以不会造成失效 线程池任务执行流程 判断任务是否为null，不为空正常往下走，为空抛异常 检查是否能创建工作线程，通过比对stl低29位和线程池参数 还能创建核心线程，创建并执行任务 不能创建核心线程 有可能创建失败，同时又多个任务进来，然后同时创建新的线程，核心线程数够了的话就会有可能创建失败，也有可能核心线程数已经满了 如果不能创建核心线程，判断线程池状态，判断是否能放进阻塞队列中 线程池正常并成功放进队列中 判断线程池状态，判断是否能去除等待队列中的任务 线程池正常并能取出队列中的任务，查看工作线程是否有空闲，空闲直接执行任务，否则创建救急线程 线程池异常或不能取出队列中的任务，走拒绝策略 线程池异常或不能放进队列中，尝试添加救急线程处理，不能添加就走拒绝策略 添加线程流程 核心方法是addWorker方法，方法主要做了两步 检验线程池状态以及工作线程个数 取ctl高三位判断线程池状态，不是running状态则失败 通过传入的参数判断是添加核心线程还是救急线程 取ctl的低29位， 判断线程数是否超出最大线程数 判断创建核心线程还是救急线程 使用cas方式对ctl低29位进行+1操作 构建线程并且启动 new一个工作线程，获取他的线程对象 工作线程是放在一个hashset中的，添加的时候使用了lock锁保证线程安全 通过线程对象启动任务","tags":["源码"],"categories":["源码"]},{"title":"MyBatis源码","path":"/2024/01/18/Note/后端/Java/源码/MyBatis/","content":"架构 接口层 提供操作数据的Api接口，完成交互 提供两种调用方式 基于statementId，需要传递xml中查询的id和参数 基于mapper接口，生成代理对象调用方法，只需要传参数即可，本质上还是基于statementId的 数据处理层 核心层，主要完成对数据的处理工作 参数映射（ParameterHandler）、sql解析（sqlSource）、sql执行（Executor）、结果处理和映射封装（ResultSetHandler） 框架支撑层 为基础服务提供支持，负责通用服务支持 sql配置方式：xml，注解 事务管理、连接池管理、缓存管理 引导层 提供两种配置方式，获取mybatis启动需要的配置信息 基于xml 基于JavaAPI 组件及其调用关系 Mybatis执行流程 读取配置文件信息，加载sql映射文件 通过类加载器对配置文件进行加载，加载成了字节输入流，存到内存中，这一步中配置文件还没有被解析 内部使用了ClassLoaderWrapper，它是 ClassLoader 的装饰器，封装了多个 ClassLoader，方便统一使用 构建SqlSessionFactory 解析xml配置文件 将inputStream转换成Document对象，创建Configuration 使用构建者模式构建复杂的Configuration对象中的成员变量（配置信息和Mapper信息） 创建SqlSessionFactory对象 XPathParser是一个基于Java XPath的解析器，将传入的inputStream 转换成一个Document对象 创建Configuration对象，完成类型别名注册 创建对应的SqlSession 通过Executor执行器操作数据库，维护缓存 读取MapperStatement对象 二级缓存 提升数据的检索效率 一级缓存为本地缓存（SqlSession） SqlSession中有一个Excutor，Excutor中有一个localcache 当用户发起查询时，mybatis会去localcache中查 分布式环境下可能会出现一个脏读的问题 二级缓存为跨SqlSession的缓存 即多个用户查询时，只要有一个SqlSession查询到数据后，就会加入二级缓存，其他SqlSession就可以直接从二级缓存中取数据 在Excutor上做了一个装饰器（CachingExcutor），查询一级缓存前会先查这个 二级缓存实现了多个SqlSession之间的共享，是一个全局的缓存，缓存粒度在namespace级别，可以通过Cache接口实现不同缓存实现类组合 原理就是在每次查询时生成一个CacheKey对象，然后去二级缓存中找这个CacheKey对象是否有对应的数据 没有就查数据库，然后加入二级缓存 有的话直接返回 创建CacheKey对象的方法中已经重写了equals和hashcode方法，所以其比较的是hash值而不是地址值 CacheKey由6部分构成的，为statementId、分页参数（偏移、条数）、sql、参数的值、环境变量，它们各自生成的hash组成的一个集合 MybatisPlus","tags":["源码"],"categories":["源码"]},{"title":"JDK源码","path":"/2024/01/18/Note/后端/Java/源码/JDK/","content":"Unsafe简介 因为使Java拥有了类似c语言一样的指针，所以不安全Unsafe Unsafe不能直接调用 通过反射获得 123Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);theUnsafe.setAccessible(true);Unsafe unsafe = theUnsafe.get(null); Unsafe提供了一个静态方法getUnsafe可以获取Unsafe实例，但是必须使用引导类加载器加载Unsafe类才能使用，因为有@CallerSensitive注解标注，为危险方法 命令行中输入：java -Xbootclasspath/a: $&#123;path&#125; // 其中path为调用Unsafe相关方法的类所在jar包路径 操作内存 主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法 为什么要使用堆外内存 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。 提升程序I&#x2F;O操作的性能。通常在I&#x2F;O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。 应用： DirectByteBuffer，在NIO框架中通常作为缓冲池使用，内部的内存分配逻辑都由Unsafe提供 unsafe.allocateMemory(内存大小) 分配内存，返回基地址 unsafe.setMemory(base, size, (byte) 0) 设置内存，内存初始化 cleaner = Cleaner.create(this, new Deallocator(base, size, cap)) 跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放 Cleaner继承自虚引用，当DirectByteBuffer对象仅被Cleaner对象引用时， gc时会将DirectByteBuffer对象回收，Cleaner对象会调用clean() 方法来进行堆外内存的释放。 CAS（CompareAndSwap） 是一个本地方法 AtomicInteger 使用 unsafe提供的CAS Unsafe只提供了 compareAndSwapObject、compareAndSwapInt、compareAndSwapLong 方法 赋值阶段源码中都是通过do-while判断 原理： 通过循环判断预期值来决定是否更新值 如果是多处理器，需要添加lock前缀（Lock#信号），内存屏障 这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能) 总线锁：将cpu和内存之间的通信锁住，其他cpu不能操作内存中的数据，开销比较大，相当于加了悲观锁 缓存锁：使用缓存锁定，将原子操作放在cpu缓存中进行 缓存锁定： 发生共享内存的锁定时，不会锁内存，而是修改内存地址，通过MESI缓存一致性保证原子性 缓存一致性： 如果这块内存被两个以上的处理器缓存，会阻止这块内存区域的同时修改 当处理器对缓存中的数据修改后，会通知其他处理器删除其内部这块内存的缓存，或者从主内存中重新读取 如果操作的数据跨多个缓存行时，处理器会使用总线锁 线程调度 线程挂起、恢复、锁机制 park、unpark、monitorEnter、monitorExit、tryMonitorEnter Class相关 提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等 获取属性在内存中的位置 获取数组第一个元素在内存中的偏移地址，还可以获取下标的增量地址 系统相关 addressSize：返回系统指针的大小。返回值为4（32位系统）或 8（64位系统） pageSize：内存页的大小，此值为2的幂次方 内存屏障 loadFence：禁止load操作重排序 storeFence：禁止store操作重排序 fullFence：禁止load、store操作重排序 对象操作 主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法 Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响 getUnsafe()123456789@CallerSensitivepublic static Unsafe getUnsafe() &#123; Class var0 = Reflection.getCallerClass(); //getCallerClass方法需要启动类加载的类才可以调用 if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(&quot;Unsafe&quot;); &#125; else &#123; return theUnsafe; &#125;&#125; getAndAddInt()12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); //检验 &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 核心方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//重新分配内存public native long reallocateMemory(long address, long bytes); //分配内存 public native long allocateMemory(long bytes); //释放内存 public native void freeMemory(long address); //在给定的内存块中设置值 public native void setMemory(Object o, long offset, long bytes, byte value); //从一个内存块拷贝到另一个内存块 public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes); //获取值，不管java的访问限制，其他有类似的getInt，getDouble，getLong，getChar等等 public native Object getObject(Object o, long offset); //设置值，不管java的访问限制，其他有类似的putInt,putDouble，putLong，putChar等等 public native void putObject(Object o, long offset); //从一个给定的内存地址获取本地指针，如果不是allocateMemory方法的，结果将不确定 public native long getAddress(long address); //存储一个本地指针到一个给定的内存地址,如果地址不是allocateMemory方法的，结果将不确定 public native void putAddress(long address, long x); //该方法返回给定field的内存地址偏移量，这个值对于给定的filed是唯一的且是固定不变的 public native long staticFieldOffset(Field f); //报告一个给定的字段的位置，不管这个字段是private，public还是保护类型，和staticFieldBase结合使用 public native long objectFieldOffset(Field f); //获取一个给定字段的位置 public native Object staticFieldBase(Field f); //确保给定class被初始化，这往往需要结合基类的静态域（field） public native void ensureClassInitialized(Class c); //可以获取数组第一个元素的偏移地址 public native int arrayBaseOffset(Class arrayClass); //可以获取数组的转换因子，也就是数组中元素的增量地址。将arrayBaseOffset与arrayIndexScale配合使用， 可以定位数组中每个元素在内存中的位置 public native int arrayIndexScale(Class arrayClass); //获取本机内存的页数，这个值永远都是2的幂次方 public native int pageSize(); //告诉虚拟机定义了一个没有安全检查的类，默认情况下这个类加载器和保护域来着调用者类 public native Class defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain); //定义一个类，但是不让它知道类加载器和系统字典 public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches); //锁定对象，必须是没有被锁的public native void monitorEnter(Object o); //解锁对象 public native void monitorExit(Object o); //试图锁定对象，返回true或false是否锁定成功，如果锁定，必须用monitorExit解锁 public native boolean tryMonitorEnter(Object o); //引发异常，没有通知 public native void throwException(Throwable ee); //CAS，如果对象偏移量上的值=期待值，更新为x,返回true.否则false.类似的有compareAndSwapInt,compareAndSwapLong,compareAndSwapBoolean,compareAndSwapChar等等。 public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x); // 该方法获取对象中offset偏移地址对应的整型field的值,支持volatile load语义。类似的方法有getIntVolatile，getBooleanVolatile等等 public native Object getObjectVolatile(Object o, long offset); //线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。 public native void park(boolean isAbsolute, long time); //终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，也正是使用这两个方法public native void unpark(Object thread); //获取系统在不同时间系统的负载情况 public native int getLoadAverage(double[] loadavg, int nelems); //创建一个类的实例，不需要调用它的构造函数、初使化代码、各种JVM安全检查以及其它的一些底层的东西。即使构造函数是私有，我们也可以通过这个方法创建它的实例,对于单例模式，简直是噩梦。 public native Object allocateInstance(Class cls) throws InstantiationException; 集合ArrayList 扩容 使用无参构造方法创建时默认初始容量是0，使用add方法添加元素就触发扩容 第一次扩容容量变为10，当存满了会再触发扩容，默认是1.5倍 扩容是创建一个新数组，再将原数组内容拷贝到新数组 扩容后容量 &#x3D; 扩容前容量 &gt; 1 +扩容前容量 (即1.5倍) 因为每次扩容都比较小，所以要尽量避免频繁的扩容，当预知要保存多少元素时，就在创建时指定ArrayList的初始大小，或者使用ensureCapacity手动扩容 123456789101112131415161718192021222324252627282930//数组最大值 = 整型最大值 - 8private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? 0 : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;//得到最大的数组容量private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // 太大超过int最大值就变成负数了 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; add(E e)、addAll(Collection&lt;? extends E&gt; c) 检查剩余空间是否需要扩容，modCount++ 添加到数组末尾 更新size add(int index, E element)、addAll(int index, Collection&lt;? extends E&gt; c) 检查下标是否越界 检查剩余空间是否需要扩容，modCount++ 原数组的值复制到新数组，插入区间前后的元素复制到新数组不包含插入区间的位置 然后在插入区间插入新增的元素 更新size set(int index, E element) 检查下标是否越界 保存老值，新值插入index位置 返回老值 get(int index) 检查下标是否越界 返回指定下标的值，需要注意类型转换 remove(int index) 检查下标是否越界，modCount++ 保存老值 数组从index下标之后的元素都往前移（通过复制） 为了让GC起作用，最后一个位置会显式赋null值 返回老值 remove(Object o) 删除第一个满足o.equals(elementData[index])的元素 trimToSize() 将底层数组的容量调整为当前列表保存的实际元素的大小 modCount++ 判断 size 是否 小于数组大小 如果size &#x3D;&#x3D; 0 则为空数组 size !&#x3D; 0 则 将数组复制到一个size &#x3D; 数组长度的新数组 indexOf(Object o)、lastIndexOf(Object o) 判断 o 是否为 null 遍历数组找下标 o 为 null 则用 &#x3D;&#x3D; 判断 o 不为 null 则用 equals 判断 找到返回下标，找不到返回-1 Fail-Fast机制 通过记录modCount参数，迭代器遍历的时候遇到并发的修改时会报错 LinkedList getFirst() 、getLast() 定义个一个常量来接收 first 或者 last 如果指向 null，抛NoSuchElementException异常 有值就返回 get(int index) 检查下标是否合法，是否越界 返回 node(index).item set(int index, E element) 判断下标是否合法，是否越界 Node x &#x3D; node(index) E oldVal &#x3D; x.item x.item &#x3D; element return oldVal remove(Object o) 判断 o 是否为 null 遍历链表找值符合的节点 o 为 null 则用 &#x3D;&#x3D; 判断 o 不为 null 则用 equals 判断 找到则用 unlink() 删除节点，成功返回true remove(int index) 检查下标是否越界 用 unlink( node(index) ) 删除节点 removeFirst()、removeLast() 定义一个常来接收 first &#x2F; last first &#x2F; last 为null 抛NoSuchElementException异常 不为空则调用 unlinkFirst() &#x2F; unlinkLast() unlink(Node&lt;E&gt; x) 定义三个常量保存节点的值 element、前驱节点 prev、后继节点 next 先处理前驱，在处理后继，注意防止空指针异常 判断 prev 是否为null 为 null 说明是第一个节点要删除，直接 first &#x3D; next 不为 null，则 prev.next &#x3D; next，x.prev &#x3D; null 判断 next 是否为null 为 null 则说明是最后一个节点要删除，直接 last &#x3D; prev 不为 null，则 next.prev &#x3D; prev，x.next &#x3D; null 将x的值置为 null。更新 size，modCount++ 返回被删除的值 element unlinkFirst(Node&lt;E&gt; f) 定义两个常量保存节点的值 element，后继节点 next 将 f 的值和后继节点置为 null 然后 first &#x3D; next 判断 next 是否等于 null 为 null，则 last &#x3D; null 不为 null，则 next.prev &#x3D; null size– modCount++ 返回被删除的值 element unlinkLast(Node&lt;E&gt; l) 定义两个常量保存节点的值 element，前驱节点 prev 将 l 的值和前驱节点置为 null 然后 last &#x3D; prev 判断 prev 是否等于 null 为 null，则 first &#x3D; null 不为 null，则 prev.next &#x3D; null size– modCount++ 返回被删除的值 element add(E e) 调用 linkLast(e) 返回 true add(int index, E element) 判断下标是否合法，是否越界 如果 下标 &#x3D; size，说明是在链表最后插入，调用 linkLast(element) 下标 !&#x3D; size，则调用 linkBefore(element, node(index)) linkLast(E e) 定义两个常量保存 尾节点 l，新节点 newNode（根据 e 创建） last &#x3D; newNode 判断 l 是否为 null 为 null，说明链表中无节点，所以 first &#x3D; newNode 不为 null，说明链表中有节点，所以 l.next &#x3D; newNode size++ modCount++ node(int index) 判断 index 在链表前半段还是后半段，通过比较 size &gt;&gt; 1 前半段：从前往后遍历找 x &#x3D; first for x &#x3D; x.next 后半段：从后往前遍历找 x &#x3D; last for x &#x3D; x.prev addAll(Collection&lt;? extends E&gt; c) 调用addAll(size, c) 实现 addAll(int index, Collection&lt;? extends E&gt; c) 判断下标是否合法 将集合c转化为Object数组 a 得到 a的长度 numNew，判断是否等于0，等于0返回false 创建两个节点指针 pred、succ 判断 index 是否等于 size 等于，相当于在链表最后添加，则 succ &#x3D; null，pred &#x3D; last 不等于，则 succ &#x3D; node(index)，pred &#x3D; succ.prev 遍历 for (Object o : a) E e &#x3D; (E) o 强制类型转换 根据值和前驱 pred 创建节点 newNode 判断 pred 是否为 null 为 null，则 first &#x3D; newNode 不为 null，pred.next &#x3D; newNode pred &#x3D; newNode 判断 succ 是否为 null 为 null，则 last &#x3D; pred 不为 null，则 pred.next &#x3D; succ，succ.prev &#x3D; pred size +&#x3D; numNew modCount++ return true clear() 遍历 先取得当前节点的next节点 然后当前节点的所有属性置为 null x &#x3D; next first &#x3D; last &#x3D; null size &#x3D; 0 modCount++ indexOf(Object o) 定义一个index &#x3D; 0 判断 o 是否为 null 为 null，遍历时走 &#x3D;&#x3D; 判断 不为 null，遍历时走 equals判断 找到返回index，找不到返回 -1 lastIndexOf(Object o) 定义一个index &#x3D; size 从后往前遍历，也是先判断 o 是否为 null 走不同的判断逻辑 找到返回index，找不到返回 -1 peek()、peekFirst()、peekLast() 定义一个常量 f 接收 first 如果 f 为 null 返回 null，不为 null 返回 f.item poll()、pollFirst()、pollLast() 定义一个常量 f 接收 first 如果 f 为 null 返回 null，不为 null 返回 unlinkFirst(f) removeLastOccurrence(Object o) 判断 o 是否为 null 为 null，遍历时走 &#x3D;&#x3D; 判断 不为 null，遍历时走 equals判断 找到用 unlink(x) 并返回true，找不到返回 false element() 调用 getFirst() remove() 调用 removeFirst() offer(E e) add(e) offerLast(E e) 调用 addLast(e) 返回 true push(E e) 调用 addFirst(e) pop() 调用 removeFirst() removeFirstOccurrence(Object o) 调用 remove(o) ArrayDeque addFirst(E e) 判断 e 是否为null，为 null 就抛异常 就是在 head 之前插入，插入后head-1 elements [ head &#x3D; (head - 1) &amp; (elements.length - 1) ] &#x3D; e 判断是否需要扩容， 如果 head &#x3D;&#x3D; tail 就需要扩容 addLast(E e) 判断 e 是否为null，为 null 就抛异常 就是在 tail 的位置插入，插入后 tail+1 elements[tail] &#x3D; e 判断下标是否越界，越界就要扩容 ( tail &#x3D; ( tail + 1 ) &amp; ( elements.length - 1) ) &#x3D;&#x3D; head，为 true 就要扩容 doubleCapacity() 只有在 head &#x3D;&#x3D; tail 的时候才需要扩容，源码中用 assert 判断，不满足条件则抛AssertionError异常 保存 head 的值（下标） p，数组的长度 n 计算 head 右边元素的个数 r &#x3D; n - p 计算扩容后的数组大小 newCapacity &#x3D; n &lt;&lt; 1，如果 newCapacity &lt; 0 则抛IllegalStateException异常 （就是太大了，超出in最大值就会变负数） 根据 newCapacity 创建一个新数组 将旧数组的值复制到新数组 a，分两步复制 先复制 head 右边的数据到新数组 再复制 head 左边的数据到新数组 将 elements 替换为新数组 a head &#x3D; 0，tail &#x3D; n pollFirst() 取得 head 位置的值 result 判断是否为 null，为 null 则说明数组为 null ，直接返回 null 将 head 位置的值置为 null 更新 head head &#x3D; (head + 1) &amp; (elements.length - 1) 返回 result pollLast() 获得 tial 前一位的值 t t &#x3D; (tail - 1) &amp; (elements.length - 1) 取得 t 位置上的值 result 判断 result 是否为 null，为 null 则说明数组为 null ，直接返回 null 将 t 位置上的值置为 null 更新 tail tail &#x3D; t 返回 result peekFirst() 返回 elements[head] 的值 peekLast() 返回 elements[(tail - 1) &amp; (elements.length - 1)] 的值 PriorityQueue add(E e)、offer(E e) 1234567891011121314public boolean offer(E e) &#123; if (e == null)//不允许放入null元素 throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1);//自动扩容 size = i + 1; if (i == 0)//队列原来为空，这是插入的第一个元素 queue[0] = e; else siftUp(i, e);//调整 return true;&#125; siftUp(int k, E x) 1234567891011private void siftUp(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2 Object e = queue[parent];//取得父节点的值e if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法 break;// x 大于 e 则不用交换了，直接退出 queue[k] = e; k = parent; &#125; queue[k] = x;&#125; element()、peek() 如果 size &#x3D; 0，返回 null 返回 (E) queue[ 0 ] remove()、poll() 123456789101112public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0];//0下标处的那个元素就是最小的那个 E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x);//调整 return result;&#125; siftDown(int k, E x) 得到 size 的一半 half 循环 k &lt; half 得到左孩子的下标 child &#x3D; (k &lt;&lt; 1) + 1 得到左孩子下标对应的值 c 得到右孩子的下标 right &#x3D; child + 1 如果 right &lt; size 并且 c &gt; queue[right]，则 c &#x3D; queue[child &#x3D; right]，就是找左右孩子小的那一个 如果 x &lt; c 退出循环 queue[k] &#x3D; c，因为 x &gt; c 交换后从 k &#x3D; child queue[ k ] &#x3D; x 1234567891011121314151617private void siftDown(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标 int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1 Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c;//然后用c取代原来的值 k = child; &#125; queue[k] = x;&#125; remove(Object o) 遍历数组找到符合值的下标 i &#x3D; indexOf(o) 如果 i &#x3D; -1 ，返回 false 得到数组最后一个元素的下标 s &#x3D; –size 如果 s &#x3D;&#x3D; i，说明要删除的是最后一个元素，则 queue[i] &#x3D; null s !&#x3D; i 取出数组最后一个元素的值 moved queue[ s ] &#x3D; null siftDown(i, moved) 返回 true 12345678910111213141516public boolean remove(Object o) &#123;\t//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标 int i = indexOf(o); if (i == -1) return false; int s = --size; if (s == i) //情况1 queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved);//情况2 ...... &#125; return true;&#125; VectorHashSetLinkedHashMap源码 get() 与hashmap的get方法几乎一致 addEntry(int hash, K key, V value, int bucketIndex) 1234567891011121314void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);// 自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);// hash%table.length &#125; // 1.在冲突链表头部插入新的entry HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 2.在双向链表的尾部插入新的entry e.addBefore(header); size++;&#125; 123456private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; removeEntryForKey(Object key) 123456789101112131415161718192021222324final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;\t......\tint hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);// hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;// 遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;// 找到要删除的entry modCount++; size--; // 1. 将e从对应bucket的冲突链表中删除 if (prev == e) table[i] = next; else prev.next = next; // 2. 将e从双向链表中删除 e.before.after = e.after; e.after.before = e.before; return e; &#125; prev = e; e = next; &#125; return e;&#125; HashMap源码 1.8 put( K key, V value ) 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal( int hash, K key, V value, boolean onlyIfAbsent, boolean evict ) 判断 p 是否和要插入的 key 相等，这个 p 是这个位置上的第一个元素 相等则用 e 接收这个节点（保留） 不相等判断 p 是不是树节点 是树节点，调用红黑树的插入 ( ( TreeNode&lt;K,V&gt; ) p ).putTreeVal( this, tab, hash, key, value )，并用 e 接收返回值 是链表节点 遍历链表节点 用 e 接收 p.next，判断 e 是否为null 为 null 直接插入p.next 如果链表长度大于等于8，则需要转化为红黑树，调用 treeifyBin(tab, hash)，跳出循环 如果在该链表中找到了相等的 key (&#x3D;&#x3D; 或 equals)，跳出循环 p &#x3D; e 如果 e !&#x3D; null，说明存在旧值的key与要插入的key相等 取得 e.value 为 oldValue 覆盖旧值 e.value &#x3D; value 返回旧值 oldValue ++modCount 如果因为插值 size &gt; 扩容阈值，就执行扩容 resize() 返回 null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; //定义一个 tab 接收数组，p 接收下标的第一个元素，n 接收数组长度，i 接收下标 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次 put 值的时候，会触发扩容，0 -&gt; 16 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // pqu如果p为 null，说明该位置还没有值，直接插入即可 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 数组该位置有数据 else &#123; //局部变量e储存插入的位置，k储存p的 Node&lt;K,V&gt; e; K k; // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 到这里，说明数组该位置上是一个链表 for (int binCount = 0; ; ++binCount) &#123; // 插入到链表的最后面(Java7 是插入到链表的最前面) if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个 // 会触发下面的 treeifyBin，也就是将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals) if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node break; p = e; &#125; &#125; // e!=null 说明存在旧值的key与要插入的key&quot;相等&quot; // 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; resize() 定义一个节点数组保存原始数据 oldTab 定义一个 oldCap 保存旧数组容量，oldThr 保存旧阈值，定义 newCap, newThr 为 0 1234567891011121314151617181920212223if (oldCap &gt; 0) &#123; // 对应数组扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 将数组大小扩大一倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 将阈值扩大一倍 newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) // 使用指定容量的构造函数创建时，因为没put所以 oldCap&lt;=0 newCap = oldThr;else &#123;// 使用无参构造函数创建并第一次put的时候 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&#125;//如果走了上面第一个if 中的 if 和 第一个 if 的else if 时//newThr是没有值的，所以需要赋值，需要判断是哪一种情况if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);&#125;threshold = newThr; 创建新数组并转移数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//用新的数组大小初始化新的数组Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可// 开始遍历原数组，进行数据迁移。if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果是红黑树，具体我们就不展开了 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 这块是处理链表的情况， // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序 // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; // 第一条链表 newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; // 第二条链表的新的位置是 j + oldCap，这个很好理解 newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125;&#125;return newTab; get(Object key) 1return getNode(hash(key), key) == null ? null : e.value getNode(int hash, Object key) 123456789101112131415161718192021final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //表不为空，长度大于0，下标处有值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断第一个节点是不是就是需要的 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //大于一个节点 if ((e = first.next) != null) &#123; // 判断是否是红黑树 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 链表遍历 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125;while ((e = e.next) != null); &#125; &#125; return null;&#125; TreeMap源码 左旋 12345678910111213141516171819202122232425/* p pr(r) / \\ / \\ pl pr(r) ==&gt; p rr / \\ / \\ rl rr pl rl\t*/private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋 123456789101112131415161718192021222324/* p pl(l) / \\ / \\ (l)pl pr ==&gt; ll p\t/ \\ / \\ ll lr lr pr\t*/private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 寻找节点后继 12345678910111213141516171819202122static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null)&#123; return null; &#125; // 1. t的右子树不空，则t的后继是其右子树中最小的那个元素，即最左的元素 else if (t.right != null) &#123; Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; // 2. t的右孩子为空，则t的后继是其第一个向左走的祖先，即parent.right = t的 else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; get 1234567891011121314151617final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... if (key == null)//不允许key值为null throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0)//向左找 p = p.left; else if (cmp &gt; 0)//向右找 p = p.right; else return p; &#125; return null;&#125; put() 123456789101112131415161718192021222324public V put(K key, V value) &#123;\t...... Entry&lt;K,V&gt; t = this.root; //如果根节点为null，当前节点直接作为根节点 if(t == null) this.root = new Entry&lt;&gt;(key, value, parent); int cmp; Entry&lt;K,V&gt; parent; //定义一个父亲节点 if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 do &#123; parent = t; cmp = k.compareTo(t.key); //与当前值比较大小 if (cmp &lt; 0) t = t.left;//向左找 插入的值小于当前值 else if (cmp &gt; 0) t = t.right;//向右找 插入的值大于当前值 else return t.setValue(value); //当前值等于插入值 &#125; while (t != null); //非叶子节点 //到达叶子节点 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e);//调整（旋转和变色） size++; return null;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//调整插入的情况/* 左三 右三 3树左 3树右 a（黑） a（黑） a（黑） a（黑） / \\ / \\ / \\ b（红） b（红） b（红） c（红） b（红） c（红） / \\ / \\ x（红） x（红） x（红） x（红）*/private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED;//新插入的节点都是红色的 //父节点为红色时需要调整 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; //x的父节点是爷爷节点的左节点（处理左三和3树左的情况） if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; //取出父亲节点的父亲节点的右节点（叔叔节点） Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); //判断是否是3树左，如果叔叔节点为空是false，不为空则是3树左的情况 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); //x的父亲设置为黑色 setColor(y, BLACK); //叔叔节点设置为黑色 setColor(parentOf(parentOf(x)), RED); //爷爷节点设置为红色 x = parentOf(parentOf(x)); //x指向爷爷节点，如果爷爷节点的父节点也是红接着处理 &#125; //左3 else &#123; //x是父节点的右节点（非完全左3），需要先左旋为左3，再右旋 if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); //在旋转时会改回父子间的指向 &#125; //x是父节点的左节点 setColor(parentOf(x), BLACK); //x的父亲设置为黑色 setColor(parentOf(parentOf(x)), RED); //爷爷节点设置为红色 rotateRight(parentOf(parentOf(x))); //右旋 &#125; &#125; //x的父节点是爷爷节点的右节点（处理右三和3树右的情况） else &#123; //取出父亲节点的父亲节点的左节点（叔叔节点） Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); //判断是否是3树右，如果叔叔节点为空是false，不为空则是3树右的情况 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); //x的父亲设置为黑色 setColor(y, BLACK); //叔叔节点设置为黑色 setColor(parentOf(parentOf(x)), RED); //爷爷节点设置为红色 x = parentOf(parentOf(x)); //x指向爷爷节点，如果爷爷节点的父节点也是红接着处理 &#125; //右3 else &#123; //x是父节点的左节点（非完全右3），需要先右旋为右3，再左旋 if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); //在旋转时会改回父子间的指向 &#125; setColor(parentOf(x), BLACK); //x的父亲设置为黑色 setColor(parentOf(parentOf(x)), RED); //爷爷节点设置为红色 rotateLeft(parentOf(parentOf(x))); //左旋 &#125; &#125; &#125; root.color = BLACK; //根节点必须为黑色&#125; remove() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*\t删除的情况： 1.删除节点是叶子节点，直接删除 2.删除节点有左孩子或者右孩子，删除节点后让其左孩子或右孩子指向向删除节点的父节点 3.删除节点有左右孩子节点，需要找到当前节点的后继节点，替代当前节点 */private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; //情况3，将其转换成情况2来处理 if (p.left != null &amp;&amp; p.right != null) Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; //p指向它的后继节点 &#125;\t//情况2\t//有左孩子取左孩子，没有就取右（因为我们找的是后继节点，是不会有左孩子的，但源码为了代码健壮性） Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);\t//有右孩子 if (replacement != null) &#123; //左孩子或右孩子指向向删除节点的父节点 replacement.parent = p.parent; if (p.parent == null) //父节点为空说明是根节点，直接替换 root = replacement; else if (p == p.parent.left) //是父节点的左孩子，重新修改指向 p.parent.left = replacement; else //是父节点的右孩子，重新修改指向 p.parent.right = replacement; p.left = p.right = p.parent = null; //被删除的节点的引用全部置为null，gc处理 if (p.color == BLACK) //如果删除节点的颜色为黑色需要进行调整 fixAfterDeletion(replacement);// 调整 &#125; //无左右孩子且父节点为null，即删除的节点是根节点\telse if (p.parent == null) &#123; root = null; &#125; //情况1\telse &#123; if (p.color == BLACK) fixAfterDeletion(p);// 调整 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*\t情况1：被删除的节点有左右孩子的节点，需要通过改变节点指向和变色就可以解决的\t情况2：被删除的节点无左右孩子的节点，用父亲节点替代，再用一个兄弟节点的子节点替代父亲节点 情况2.1：兄弟节点有一个孩子，旋转成有右孩子的情况，在进行左旋 情况2.2：兄弟节点有两个孩子，直接进行左旋\t情况3：被删除的节点无左右孩子的节点，用父亲节点替代，但是兄弟节点没有子节点可以替代父亲节点\t*/private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; //情况2，3 while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; //x是左孩子的情况 if (x == leftOf(parentOf(x))) &#123; //找到x的兄弟节点 Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); //判断sib是否是x的兄弟节点，只有sib是黑色时才是兄弟节点，红色需要调整 if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 兄弟变黑 setColor(parentOf(x), RED); // 兄弟父亲变红 rotateLeft(parentOf(x)); // 左旋，将左孩子变成右孩子 sib = rightOf(parentOf(x)); // 修改找到真正的兄弟节点 &#125; //情况3，兄弟节点无左右孩子节点 if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 设置兄弟节点为红色 x = parentOf(x); // 删除的节点指向x的父亲，递归条件 &#125; //情况2，兄弟节点有一个或俩个子节点 else &#123; //没有右孩子，需要右旋为有左孩子的情况 if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); // 将兄弟节点的左节点变黑 setColor(sib, RED); // 将兄弟节点变红 rotateRight(sib); // 右旋 sib = rightOf(parentOf(x)); // 兄弟节点重新指向为父亲节点的右节点 &#125; setColor(sib, colorOf(parentOf(x))); // 兄弟节点要变成父亲节点的颜色 setColor(parentOf(x), BLACK); // 父亲节点变黑 setColor(rightOf(sib), BLACK); // 兄弟节点的右孩子变黑 rotateLeft(parentOf(x)); // 左旋 x = root; // 结束循环 &#125; &#125; //x是右孩子的情况，不会出现这种可能 else &#123; Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // setColor(parentOf(x), RED); // rotateRight(parentOf(x)); // sib = leftOf(parentOf(x)); // &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); // x = parentOf(x); // &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); // setColor(sib, RED); // rotateLeft(sib); // sib = leftOf(parentOf(x)); // &#125; setColor(sib, colorOf(parentOf(x))); // setColor(parentOf(x), BLACK); // setColor(leftOf(sib), BLACK); // rotateRight(parentOf(x)); // x = root; // &#125; &#125; &#125; //情况1，变黑，指向在前面已经修改完毕了 setColor(x, BLACK);&#125; HashTableWeakHashMap注解@CallerSensitive 该注解标注的方法为危险方法，调用该注解标注的方法的对象必须也需要有该注解，且改对象必须有启动类加载 开发者自己写的@CallerSensitive不可被识别即无法调用该危险方法 可以通过jvm参数 -Xbootclasspath/a: path 伪装为启动类 @FunctionInterface 接口中只有一个抽象方法，即可搭配lamda表达式使用 @Contended 防止缓存行，伪共享 对齐填充，因为一个缓存行是64字节，当读取的目标数据小于64字节时，可以填充一些无意义的数据使其字节接近或达到64字节，这样就可以使一个缓存行只被一个线程所持有","tags":["源码"],"categories":["源码"]},{"title":"搜索","path":"/2024/01/18/Note/后端/Java/模块/搜索/","content":"ES搜索 创建一个查询对象vo类，属性包括需要显示的信息，指定其属于ES中哪个索引，哪个type（表） 1234@Document(indexName = &quot;haoke&quot;, type = &quot;house&quot;, createIndex = false)public class Data&#123; //需要返回的数据&#125; 创建一个搜索结果类，存放查询结果集合 1234public class SearchResult&#123; private Integer totalPage; private List&lt;Data&gt; list;&#125; 创建SearchController 123456789101112public class SearchController&#123; @Autowired private SearchService searchService; @GetMapping public SearchResult search(@RequestParam(&quot;keyWord&quot;) String kewWord, @RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer page)&#123; //防止爬虫，保障ES性能，减少压力 if(page &gt; 100) page = 1; return this.searchService.search(keyWord, page); &#125;&#125; 创建SearchService 12345678910111213141516171819public class SearchService&#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; //由后端指定页面数据条数 public static final Integer ROWS = 10; public SearchResult serach(String kewWord, Integer page)&#123; //设置分页参数 PageRequest pageRequest = PageRequest.of(page - 1, ROWS); SearchQuery searchQuery = new NativSearchQueryBuilder() .withQuery(Querybuilder.matchQuery(&quot;title&quot;, keyWord).operator(Operator.AND)) .withPageable(pageRequest) .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;))//不起作用 .builder(); AggregatedPage&lt;HouseData&gt; housePage = this.elasticsearchTemplate.queryForPage(searchQuery, HouseData.class); return new SearchResult(housePage.getTotalPages(), housePage.getContent()); &#125;&#125; 高亮显示 处理高亮和非高亮 12345678910111213141516171819202122232425262728293031return new SearchResult(housePage.getTotalPages(), housePage.getContent(), new SearchResultMapper()&#123;@Overridepublic &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response, Class&lt;T&gt; clazz, Pageable pageable) throws Exception&#123; //如果查询到的条数为0时返回空对象 if(response.getHits().totalHits == 0) return new AggregatedPageImpl&lt;&gt;(Collection.emptyList(), pageable, 0L); //接收 List&lt;T&gt; list = new ArrayList&lt;&gt;(); //遍历命中的数据 for(SearchHits searchHit : response.getHits().getHits())&#123; T obj = (T) ReflectUtils.newInstance(clazz); FieldUtils.writeField(obj, &quot;id&quot;, searchHit.getId(), true); //非高亮字段的数据处理 for(Map.Entry&lt;String, Object&gt; entry : searchHit.getSourceAsMap().entrySet())&#123; if(null == FieldUtils.getFiled(clazz, entry.getKey(), true)) continue; FieldUtils.writeField(obj, entry.getKey(), entry.getValue(), true); &#125; //处理高亮字段 for(Map.Entry&lt;String, HighlighField&gt; entry : searchHit.getHighlighFields().entrySet())&#123; StringBulider sb = new StringBuilder(); Text[] fragments = entry.getValue().getFragments(); for(Text fragment : fragments)&#123; sb.append(fragment.toString()); &#125; FieldUtils.writeField(obj, entry.getKey(), sb.toString(), true); &#125; list.add(obj); &#125; return new AggregatedPageImpl&lt;&gt;(list, pagable, response.getHits().totalHits);&#125;); 热词搜索 redis使用sortedSet SearchController 添加方法，并添加热词搜索次数 12345678910111213141516171819202122232425public class SearchController&#123; @Autowired private SearchService searchService; @Autowired private RedisTemplate redisTemplate; @GetMapping public SearchResult search()&#123; if(page &gt; 100) page = 1; SearchResult search = this.searchService.search(keyWord, page); //热词加入redis String redisKey = &quot;SEARCH_HOT_WORDS&quot;; //数据条数 = 数据页数 * 每页条数 + 当前页数据条数 int count = ((Math.max(search.getTotalPage(), 1) - 1) * searchService.ROWS) + search.getList().size(); this.redisTemplate.opsForZSet().add(redisKey, keyWord, count); //判断是否返回热词搜索 if(search.totalPage() &lt;=1)[ Set set = this.redisTemplate.opsForZSet().reverseRange(redsikey, 0, 4); search.setHotWord(set); ] return search; &#125;&#125; 修改SearchResult 123456789@Data@AllArgsConstructor@NoArgsConstructorpublic class SearchResult&#123; private Integer totalPage; private List&lt;HouseData&gt; list; //新增一个热词字段 private Set&lt;String&gt; hotWord;&#125; 拼音分词 创建索引时使用拼音分词插件，配置拼音插件 创建索引时为字段建立一个拼音的子字段，该子字段使用拼音分词器 1234567891011&quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;fields&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;pinyin_analyzer&quot; &#125; &#125;, .............&#125; 高亮会失效，使用混合搜索可解决 123456789101112131415&quot;query&quot;:&#123;\t&quot;mult_match&quot;: &#123; &quot;query&quot;: &quot;地铁kou&quot;, &quot;fields&quot;: [ &quot;title&quot;, &quot;title.pinyin&quot; ] &#125;,\t&quot;highlight&quot;: &#123; &quot;fields&quot;: &#123; &quot;title.pinyin&quot;:&#123;&#125;, &#x27;title&#x27;:&#123;&#125; &#125; &#125;&#125; 修改 SearchService 中的实现 12345678910111213141516171819public class SearchService&#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; //由后端指定页面数据条数 public static final Integer ROWS = 10; public SearchResult serach()&#123; //设置分页参数 PageRequest pageRequest = PageRequest.of(page - 1, ROWS); SearchQuery searchQuery = new NativSearchQueryBuilder() //这里修改为混合搜索 .withQuery(Querybuilder.multMatchQuery(keyWord, &quot;title&quot;, &quot;title.pinyin&quot;).operator(Operator.AND)) .withPageable(pageRequest) .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;)) .builder(); AggregatedPage&lt;HouseData&gt; housePage = this.elasticsearchTemplate.queryForPage(searchQuery, HouseData.class); return new SearchResult(housePage.getTotalPages(), housePage.getContent());&#125;","tags":["模块"],"categories":["模块"]},{"title":"登录","path":"/2024/01/18/Note/后端/Java/模块/登录/","content":"用户名密码登录 通过用户名查询用户表，得到密码和盐值 将客户端传递过来的密码加上盐值再通过md5加密后与用户表中的密码进行比对 成功则生成jwt和用户信息返回给客户端 短信登录 获取验证码 12345678//发送验证码public Result sendCode(String phone, HttpSession session) &#123; // 1.校验手机号 // 2.如果不符合，返回错误信息 // 3.符合，生成验证码 // 4.保存验证码到 redis // 5.发送验证码&#125; 校验验证码 123456789101112131415//校验验证码public Result login(LoginFormDTO loginForm, HttpSession session) &#123; // 1.校验手机号 // 2.从redis获取验证码并校验 // 2.1 不一致，报错或者记录信息后友好提示 // 3.一致，根据手机号查询数据库用户 select * from tb_user where phone = ? // 4.判断用户是否存在 // 4.1.不存在，注册新用户并保存 // 5.存在，保存用户信息到 redis中 // 6.使用JWT生成token，作为登录令牌 // 7.将User对象转为HashMap存储 // 8.存储到redis中 // 9.设置token有效期 // 10.返回token给客户端&#125; 发送验证码时检验一次，登录时再检验一，防止两次的手机号不同 redis存储时 key为手机号，value为验证码 设置拦截器拦截用户访问需要用户信息的页面1234567891011public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 1.获取请求头中的token // 2.基于TOKEN获取redis中的用户 // 3.判断用户是否存在 // 4.将查询到的hash数据转为UserDTO // 4.1.不存在，拦截，跳转到登录页面 // 5.存在，保存用户信息到 ThreadLocal // 6.刷新token有效期 // 7.放行 return true;&#125; 设置拦截器防止用户过期重新登录123456789101112public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 1.获取请求头中的token // 2.基于TOKEN获取redis中的用户 // 3.判断用户是否存在 // 4.将查询到的hash数据转为UserDTO // 5.判断UserDTO是否存在 // 5.1.不存在，重新登录 // 6.存在，保存用户信息到 ThreadLocal // 7.刷新token有效期 // 8.放行 return true;&#125; 拦截一切路径 常见问题集群Session共享问题 使用session保存收集好user对象，每一个session都有一个唯一的sessionId，在访问tomcat时sessionId会自动写入cookie中，session的原理是cookie 集群下不同的服务器并不共享session，导致请求切换到不同服务器时需要重新登录 二维码登录第三方登录游客登录注册 输入用户名密码，生成随机盐值，保存到对应的用户表 保存密码时，通过 密码 + 盐值 再通过md5存储到用户表中","tags":["模块"],"categories":["模块"]},{"title":"地图","path":"/2024/01/18/Note/后端/Java/模块/地图/","content":"Mongo实现地图显示附近房源位置 需要返回给前端 房源集合（需要有经纬度信息），可以给房源添加经纬度信息，或者创建一个新的类保存（位置集合（X，Y），id，房源id，房源标题） 在MongoDB中为经纬度信息创建地理位置索引 db.house.createIndex(&#123;loc:&quot;id&quot;&#125;) 需要存储地图缩放比对应的公里数 查询MongoDB 12345678910111213141516171819202122@Servicepublic class MongoHouseService&#123; //需要定义缩放比对应的公里数 public static final Map&lt;Integer, Double&gt; BAIDU_ZOOM = new HashMap&lt;&gt;(); @Autowired private MongoTemplate mongoTemplate; public MapHouseDataResult queryHouseData(Float lng, Float lat, Integer zoom)&#123; //1.5倍距离范围 double distance = BAIDU_ZOOM.get(zoom) * 1.5 / 111.12; Query query = Query.query(Criteria.where(&quot;loc&quot;) .near(new Point(lng, lat)) .maxDistance(distance)); List&lt;MongoHouse&gt; mongoHouses = this.mongoTemplate.find(query, MongoHouse.class); List&lt;MapHouseXY&gt; list = new ArrayList&lt;&gt;(); for(MongoHouse mongoHouse : mongoHouses)&#123; list.add(new MapHouseXY(mongoHouses.getLoc()[0], mongoHouse.getLoc()[1])); &#125; return new MapHouseDataResult(list); &#125;&#125; Redis实现附近商铺Redis中的GEO实现百度地图API简介 实现地图找房 创建地图、覆盖物、控件、事件 坐标转换、路线规划、IP定位 地图找房- 运动类 运动轨迹、保存路线、分享路线、附近的人、附近路线 基于百度地图的鹰眼轨迹服务实现 物流 运行轨迹、电子wei’l","tags":["模块"],"categories":["模块"]},{"path":"/2024/01/18/Note/后端/Java/模块/导入导出/","content":"导出wordfreemarker 导出ExcelEasyExcel"},{"path":"/2024/01/18/Note/后端/Java/模块/OSS/","content":"Minio文件上传1234567891011121314151617181920212223242526272829private final MinioClient minioClient;public UploadFileResultDTO uploadFile(byte[] bytes, Long userId, UploadFileParam param, String folderName)&#123; //上传到minio PutObjectArgs putObjectArgs = PutObjectArgs.builder() .bucket(&quot;桶名&quot;) .object(&quot;文件名&quot;) .stream(&quot;文件输入流, 文件大小, 分片大小（-1最小5m, 最大10000）&quot;) .contentType(&quot;content-type&quot;) //资源d .build(); minioClient.putObject(putObjectArgs); //保存到数据库 //可以将文件流转换为md5存入数据库 //先查再插入&#125;//上传文件的基本信息class UploadFileParam&#123; //文件名 private String fileName; //content-type private String contentType; //文件类型 private String fileType; //标签 private String tags; //上传人 private String username; //备注 private String remark;&#125; 视频上传12345678910111213141516171819//检查该文件在minio上是否存在public R checkFile(String fileMd5, int index)&#123; //查数据库，数据存在再查minio //查minio GetObjectArgs object = GetObjectArgs.builder().... minioClient.getObject(object);&#125;//判断分块是否存在public R checkFile(String fileMd5)&#123; //截取fileMd5前两位，拼接成文件路径 //查minio GetObjectArgs object = GetObjectArgs.builder().... minioClient.getObject(object); &#125;//开始上传public R uploadchunk(String fileMd5, int index, String localFilePath)&#123; &#125;//合并 阿里云"},{"title":"GraphQL","path":"/2024/01/18/Note/后端/Java/模块/GraphQL/","content":"简介 Restful存在的弊端 想要部分数据，但是返回的有多余的数据，资源浪费 一次请求不能满足需求 按需索取资源、一次查询多个数据、无需划分版本 数据类型 Int：有符号32位 Float String Boolean ID：唯一标识符 自定义类型 枚举 12345enum Episode &#123;\tA\tB\tC&#125; 接口 1234567891011interface Character\t&#123; #定义接口\tid: ID! #!表示非空\tname: String\tage: Int&#125;type Human implements Character&#123;\tid: ID! #!表示非空\tname: String\tage: Int\t#其他的属性&#125;","tags":["模块"],"categories":["模块"]},{"title":"集成","path":"/2024/01/18/Note/后端/Java/开发/集成/","content":"集成Validator 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在Controller上添加@Validated 入参字段前加上Validator相关注解，如果是对象则加@Valid，在对象内部再使用Validator相关注解即可 还可以实现分组校验，即按场景校验 需要创建一个对象，定义需要分组校验的场景 1234567891011@Getter@Setterpublic class ValidParam implements Serializable &#123; private static final long serialVersionUID = 1L; //参数校验分组：增加 public @interface add &#123;&#125; //参数校验分组：编辑 public @interface edit &#123;&#125; //参数校验分组：删除 public @interface delete &#123;&#125;&#125; 使用时在Validator相关注解中指定即可 所有的字段都需要添加场景，否则不起作用 支持自定义注解，即自定义规则校验 123456789101112131415161718192021222324// 自定义注解@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)//指定校验器@Constraint(validatedBy = MyValidator.class)public @interface MyAnnotation &#123; String message() default &quot;Invalid value&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;// 自定义校验器public class MyValidator implements ConstraintValidator&lt;MyAnnotation, String&gt; &#123; @Override public void initialize(MyAnnotation constraintAnnotation) &#123; // 初始化逻辑 &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; // 校验逻辑 return value != null &amp;&amp; value.startsWith(&quot;My&quot;); &#125;&#125; 集成mybatisplus 引入依赖 1234567891011121314151617181920212223&lt;!-- mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis-plus代码生成器 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatisPlus Freemarker 模版引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- freemarker 作为 MyBatis-Plus 自动生成代码时作为模板使用，还可选用 velocity 作为模板 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 配置信息 123456789101112131415161718192021222324# mybatis配置mybatis-plus: # xml文件路径 mapper-locations: classpath:mapper/*.xml # 实体类路径 type-aliases-package: com.xjh.entity configuration: # 驼峰转换 map-underscore-to-camel-case: true # 是否开启缓存 cache-enabled: false # 打印sql log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 全局配置 global-config: # 数据库字段驼峰下划线转换 db-column-underline: true # id自增类型(数据库id自增) id-type: 0 # 0 为数据库自增id # 1 为不设置自增id # 2 为用户输入id # 3 为当插入对象为空时自动填充id # 4 为分配字符串型的UUID MyBatis-Plus 默认的id生成算法是 雪花算法 ，缺点是比较长 配置启动类 12345@MapperScan(&quot;&quot;)@ComponentScan(basepackages = &#123;&quot;&quot;&#125;)public void 启动类()&#123; &#125; 代码生成器1234567891011121314151617181920212223242526272829303132333435363738394041424344public void genCode() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); gc.setAuthor(&quot;jianhong.xu&quot;); gc.setOpen(false); //生成后是否打开资源管理器 gc.setServiceName(&quot;%sService&quot;);\t//去掉Service接口的首字母I gc.setIdType(IdType.AUTO); //主键策略 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/loan?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setParent(&quot;xu.srb.core&quot;); pc.setEntity(&quot;pojo.entity&quot;); //此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok strategy.setLogicDeleteFieldName(&quot;is_deleted&quot;);//逻辑删除字段名 strategy.setEntityBooleanColumnRemoveIsPrefix(true);//去掉布尔值的is_前缀（确保tinyint(1)） strategy.setRestControllerStyle(true); //restful api风格控制器 返回json mpg.setStrategy(strategy); // 6、执行 mpg.execute();&#125; 分页插件12345678910111213@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; // 3.4 之后 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 指定数据源 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); // 设置分页最大数限时 -1 不限制 paginationInnerInterceptor.setMaxLimit(500L); interceptor.addInnerInterceptor(paginationInnerInterceptor); // 添加防止全表更新与删除插件 （防止恶意语句执行 如 update set 没有where） interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); return interceptor;&#125; 填充器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Beanpublic MetaObjectHandler getMybatisObjectHandler(ApplicationContext context) &#123; return new MetaObjectHandler() &#123; private static final String CREATE_BY = &quot;createBy&quot;; private static final String UPDATE_BY = &quot;updateBy&quot;; private static final String CREATE_TIME = &quot;createTime&quot;; private static final String UPDATE_TIME = &quot;updateTime&quot;; @Override public void insertFill(MetaObject metaObject) &#123; fill(metaObject, CREATE_BY, CREATE_TIME); fill(metaObject, UPDATE_BY, UPDATE_TIME); &#125; @Override public void updateFill(MetaObject metaObject) &#123; fill(metaObject, UPDATE_BY, UPDATE_TIME); &#125; private void fill(MetaObject metaObject, final String userFiled, final String time) &#123; try &#123; Object user = metaObject.getValue(userFiled); if(ObjectUtil.isNull(user)) &#123; setFieldValByName(userFiled, this.getUserId(), metaObject); &#125; &#125; catch (Exception ignored)&#123;&#125; setFieldValByName(time, new Date(), metaObject); &#125; /** 获取当前操作的用户 account */ private Serializable getUserId() &#123; try &#123; AccountUser user = context.getBean(AccountUser.class); return user.getAccount(); &#125; catch (Exception ignored) &#123; try &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.bda.huijun.common.security.util.SecurityUtils&quot;); Method method = ReflectUtil.getMethod(cls, &quot;getAccount&quot;); return (Serializable) method.invoke(null); &#125; catch (Exception e) &#123;&#125; log.warn(&quot;accountUser not exist!&quot;); &#125; return &quot;&quot;; &#125; &#125;;&#125; Nacos集成注册中心 添加依赖 12345678910111213141516171819&lt;!-- nacos 服务发现 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 需要移除ribbon依赖 添加服务注册发现注解 @EnableDiscoveryClient, 高版本可以不用加 配置 1234567891011121314151617spring: application: name: @artifactId@ #服务名 cloud: nacos: discovery: #服务发现 server-addr: 127.0.0.1:8848 #nacos地址 config: server-addr: $&#123;spring.cloud.nacos.discovery.server-addr&#125; file-extension: yml import-check: enabled: true # SpringCloud 2021版本之后，需要用以下方式导入nacos的配置文件 profiles: active: dev config: import: nacos:$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.yml 修改nacos配置文件 application.properties 123db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user.0=rootdb.password.0=123456 创建nacos数据库，导入需要的表和数据 打开网站 http://127.0.0.1:8848/nacos/index.html 账号密码：nacos &#x2F; nacos 配置中心 添加依赖 12345678910&lt;!-- nacos 服务配置中心 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--配置中心不生效的话添加boot--&gt; &lt;!--高版本需要--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;&lt;/dependency&gt; 创建bootstrap.properties文件，配置服务名和配置中心地址 12345678910111213spring: application: name: market-member cloud: config: server-addr: 127.0.0.1:8848 #配置中心地址 namespace: e63b0d76-dc0d-4521-a81c-2168c578e773 #命名空间 group: dev #配置分组 file-extension: yml ext-config: #加载多配置，配置上云管理 - data-id: datasource.yml group: dev refresh: true 到nacos配置中心添加 Data ID：模块名.yml 配置格式：yml 设置动态获取配置 @RefreshScope：在需要获取nacos配置的接口上添加，不需要重启服务就可以获取到 @Value：取值 OpenFeign集成 添加依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 创建远程调用接口，添加@FeignClient注解 12345678@FeignClient(contextId = &quot;远程调用的接口&quot;, value = &quot;接口路径&quot;, fallback = HjImServiceFallBack.class, configuration = SentinelFeignConfig.class)public interface FeignService&#123; &#125; 在需要远程调用的模块的启动类上添加@EnableFeignClients 1234567@EnableFeignClients(basePackages = &quot;com.xz.market.common.openfeign.feign&quot;)@SpringBootApplicationpublic class XXXApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(XXXApplication.class, args); &#125;&#125; 注意 如果使用了高版本的cloud的话需要修改依赖 12345678910111213141516&lt;!--feign模块的pom中添加--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos模块的pom中修改--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 老版本cloud使用的是ribbon，新版本使用的是loadbalancer Gateway集成 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 需要排除web依赖 需要引入nacos依赖 配置 123456789101112131415161718192021spring: cloud: gateway: #路由转发断言、过滤、路径转换等等 routes: - id: admin_route uri: lb://renren-fast predicates: - Path=/admin/** filters: - RewritePath=/admin/(?&lt;segment&gt;.*), /renren-fast/$\\(segment) #全局跨域配置 globalcors: add-to-simple-url-handler-mapping: true cors-configurations: &#x27;[/**]&#x27;: allowedOriginPatterns: &quot;*&quot; allowedMethods: &quot;*&quot; allowedHeaders: &quot;*&quot; allowCredentials: true maxAge: 360000 Camunda集成 依赖 12345678910111213141516171819202122232425262728293031323334&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--还需要springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.camunda.bpm&lt;/groupId&gt; &lt;artifactId&gt;camunda-bom&lt;/artifactId&gt; &lt;version&gt;7.18.0&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!--Camunda控制台--&gt;&lt;dependency&gt; &lt;groupId&gt;org.camunda.bpm.springboot&lt;/groupId&gt; &lt;artifactId&gt;camunda-bpm-spring-boot-starter-webapp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Camunda Api--&gt;&lt;dependency&gt; &lt;groupId&gt;org.camunda.bpm.springboot&lt;/groupId&gt; &lt;artifactId&gt;camunda-bpm-spring-boot-starter-rest&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Camunda 数据结构--&gt;&lt;dependency&gt; &lt;groupId&gt;org.camunda.bpm&lt;/groupId&gt; &lt;artifactId&gt;camunda-engine-plugin-spin&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.camunda.spin&lt;/groupId&gt; &lt;artifactId&gt;camunda-spin-dataformat-all&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--web--&gt;&lt;!--mysql--&gt;&lt;!--myba--&gt; 下载设计器（github下载），绘制对应的流程 创建camunda数据库，表会自动创建 EasyExcel集成 依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;com.pig4cloud.excel&lt;/groupId&gt; &lt;artifactId&gt;excel-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.7&lt;/version&gt; &lt;!-- 移除自带的log日志 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Netty集成 依赖 12345&lt;dependency&gt;\t&lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifacId&gt;netty-all&lt;/artifacId&gt; &lt;version&gt;4.1.39.Fin&lt;/version&gt;&lt;/dependency&gt; GraphQl集成 依赖 12345&lt;dependency&gt;\t&lt;groupId&gt;com.graphql-java&lt;/groupId&gt; &lt;artifactId&gt;graphql-java&lt;/artifactId&gt; &lt;version&gt;11.0&lt;/version&gt;&lt;/dependency&gt; 需要添加第三方库才能下载，Maven配置 12345678&lt;repository&gt;\t&lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;bintray-andimarek-graphql-java&lt;/id&gt; &lt;name&gt;bintray&lt;/name&gt; &lt;url&gt;http://dl.bintray.com/andimarek/graphql-java&lt;/url&gt;&lt;/repository&gt; 在resources下创建.graphqls 123456789schema &#123; #定义查询\tquery: 查询的类型&#125;type 查询的类型 &#123; #定义查询的类型\t对象(id:Long): 对象 #制定对象以及参数类型&#125;type 对象 &#123; #定义对象\t属性名: 属性类型! #!表示非空&#125; 创建GraphQLProvider，用于初始化GraphQL 初始化GraphQL对象 读取.graphql文件，使用GraphQLSchema解析 指定查询的数据，创建一个MyDataFetcher接口，动态的传入查询的名称和数据 1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class GraphQLProvide&#123; private GraphQL graphQL; //MyDataFetcher实现类的集合 @Autowired private List&lt;MyDataFetcher&gt; myDataFetchers; //初始化GraphQL对象 @PostConstruct//在Spring初始化时执行 public void init() throws FileNotFoundException&#123; //读取外部GraphQL文件并解析 File file = ResourceUtils.getFile(&quot;classpath:haoke.graphqls&quot;); this.graphQL = GraphQL.newGraphQL(buildGraphQLSchema(file)).build(); &#125; //构建GraphQLSchema private GraphQLSchema buildGraphQLSchema(File file)&#123; TypeDefinitionRegistry typeRegistry = new SchemaParser().parse(file); return new SchemaGenerator().makeExecutableSchema(typeRegistry, buildWiring()); &#125; //构建RuntimeWiring 优化 private RuntimeWiring buildWiring()&#123; return RuntimeWiring.newRuntimeWiring().type(&quot;HaokeQuery&quot;, builder -&gt; &#123; for(MyDataFetcher myDataFetcher : myDataFetchers)&#123; builder.dataFetcher(myDataFetcher.fieldName(), enviroment -&gt; myDataFetcher.dataFetcher(enviroment)); &#125; return builder; &#125;).build(); &#125; @Bean public GraphQL graphQL()&#123; return this.graphQL; &#125;&#125; 创建MyDataFetcher接口，其实现类实现获取查询名和数据的功能 123456public interface MyDataFetcher&#123; //GraphQL查询的名称 String fieldName(); //查询数据，enviroment中有参数 Object dataFetcher(DataFetchingEnviroment enviroment);&#125; 在GraphQLController中添加方法 1234567891011@RequestMapping(&quot;graphql&quot;)@Controllerpublic class GraphQLController&#123; @Autowired private GraphQL graphQL; @GetMapping @ResponseBody public Map&lt;String, Object&gt; query(@RequestParam(&quot;query&quot;) String query)&#123; return this.graphQL.execute(query).toSpecification();//标准输出，返回的时Map类型 &#125;&#125; 创建实现类 123456789101112131415161718@Componentpublic class XXXDataFetcher implements MyDataFetcher&#123; @Autowired private XXXService xxxService; //GrapgQl查询名 @Override public String fieldName()&#123; return &quot;xxx&quot;; &#125; //通过参数查询数据 @Override public Object dataFetcher(DataFetchingEnviroment enviroment)&#123; Long xxx = enviroment.getArgument(&quot;xxx&quot;); return this.xxxService.query(xxx); &#125;&#125; OSS集成阿里云 依赖 123456&lt;!-- https://mvnrepository.com/artifact/com.aliyun.oss/aliyun-sdk-oss --&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;3.10.2&lt;/version&gt;&lt;/dependency&gt; 如果使用spring-cloud-alicloud-oss 的话会和nacos注册中心依赖有冲突，所以使用aliyun-sdk-oss好一些 配置文件 12345aliyun: endpoingt: &quot;&quot; accessKeyId: &quot;&quot; accessKeySecret: &quot;&quot; bucketName: &quot;&quot; 将 OSSClient 加入容器 12345678910111213141516@Getter@Setter@Configuration@ConfigurationProperties(prefix = &quot;aliyun&quot;)public class AliyunConfig &#123; private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; @Bean public OSSClient ossClient()&#123; return new OSSClient(endpoint, accessKeyId, accessKeySecret); &#125;&#125; MinIo 依赖 123456789101112131415161718&lt;!--方式一--&gt;&lt;!--这种方式无需配置minio client，可直接使用OssProperties、OssTemplate--&gt;&lt;dependency&gt; &lt;groupId&gt;com.pig4cloud.plugin&lt;/groupId&gt; &lt;artifactId&gt;oss-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--方式二--&gt;&lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;8.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.8.1&lt;/version&gt;&lt;/dependency&gt; 配置文件 1234567minio:\tendpoint: accessKey:\tsecretKey:\tbucket: files: 文件桶 videofiles: 视频桶 配置MinioClient 123456789101112131415161718@Configurationpublic class MinioConfig&#123; @Value(&quot;$&#123;minio.endpoint&#125;&quot;) private String endpoint; @Value(&quot;$&#123;minio.accessKey&#125;&quot;) private String accessKey; @Value(&quot;$&#123;minio.secretKey&#125;&quot;) private String secretKey; @Bean public MinioClient minioClient()&#123; MinioClient minioClient = MinioClient.builder() .endpoint(endpoint) .creadentials(accessKey, secretKey) .build(); return minioClient; &#125;&#125;","tags":["开发","集成"],"categories":["开发"]},{"title":"集群","path":"/2024/01/18/Note/后端/Java/开发/集群/","content":"MySQL主从复制 Master主库在事务提交时，会把数据变更记录在Binlog中 从库读取主库的Binlog，写入到从库的中继日志Relay Log 从库重做RelayLog中的事件，将改变反映它自己的数据 步骤 主库配置 修改/etc/my.cnf 12345678#mysql服务ID，保证整个集群环境中为唯一，取值范围：1 - 2^32 - 1,默认唯一server-id=1#是否只读，1代表只读，0代表读写read-only=0#忽略的数据，指不需要同步的数据库#binglog-ignore-db=mysql#指定同步的数据库#binlog-do-db=db01 重启mysql systemctl restart mysqld 登录mysql，创建远程连接的账号，并授予主从复制权限 1234#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQLCREATE USER &#x27;itcast&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Root@123456&#x27;;#为&#x27;itcast@%&#x27;用户分配主从复制权限&#x27;GRANT REPLICATION SLAVE ON *.* TO &#x27;itcast&#x27;@&#x27;%&#x27;; 从库配置 修改配置文件&#x2F;etc&#x2F;my.cnf 1234#服务ID，保证整个集群环境中唯一server-id=2#是否只读，1代表只读read-only=1 重启mysql systemctl restart mysqld 登录mysql，设置主库配置 开启同步 查看主从状态 Es集群 创建es-cluster文件夹，在下面创建节点目录 需要将es下的elasticsearch.yml和jvm.options拷贝到节点目录下 编辑elasticsearch.yml，添加节点名字 cluster.name: 集群名字 node.name: 节点名字 http.port: 端口号 discovery.zen.ping.unicast.hosts: [&quot;广播地址&quot;] discovery.zen.minimum_master_nodes: 最小master节点数 node.master: 是否为master节点 node.data: 是否为data节点 编辑jvm.options ，修改jvm最大和最小堆内存 docker创建容器进行配置文件挂载 Redis集群 使用Docker搭建redis集群，使用host网络类型，配置 拉取镜像-创建容器-启动容器指定host网络类型 创建ClusterConfigurationProperties 123456789@Component@ConfigurationProperties(prefix=&quot;spring.redis.cluster&quot;)@Datapublic class ClusterConfigurationProperties&#123; //存放所有节点的ip地址 private List&lt;String&gt; nodes; //最大重定向次数 private Integer maxRedirects;&#125; 建立连接 123456789101112131415161718192021@Configurationpublic class RedisClusterConfig&#123; @Autowired private ClusterConfigurationProperties clusterProperties; @Bean public RedisConnectionFactory connectionFactory()&#123; RedisClusterConfiguration configuration = new RedisClusterConfiguration(clusterProperties.getMaxRedirects()); configuration.setMaxRedirects(clusterProperties.getMaxRedirects()); return new JedisConnectionFactory(configuration); &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory redisConnectionfactory)&#123; RedisTemplate&lt;String, String&gt; redisTemplate = new redisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionfactory); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new StringRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125;&#125; 采用统一控制缓存逻辑，使用拦截器实现 123456789101112131415161718192021222324252627282930313233343536public class Interceptor()&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)&#123; if(StringUtils.equalsIgnoreCase(request.getMethod(), &quot;OPTIONS&quot;))&#123; return true; &#125; //判断请求方式 if(!StringUtils.equalsIgnoreCase(request.getMethod(), &quot;GET&quot;))&#123; //非Get，如果不是graphql，则放行 if(!StringUtils.equalsIgnoreCase(request.getRequestURI(), &quot;/graphql&quot;))&#123; return true; &#125; &#125; //通过缓存做命中，查询redis，redisKey ? 组成md5 String redisKey = createRedisKey(request); String data = this.redisTemplate.opsForValue().get(redisKey); if(StringUtils.isEmpty(data)) return true; //支持跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET,POST,PUT,DELETE,OPTIONS&quot;); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Token&quot;); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); response.getWriter().write(data); return false; &#125; public static String createRedisKey(HttpServletRequest request) throws Exception&#123; String paramStr = request.getRequestURI(); Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if(parameterMap.isEmpty())&#123; paramStr += IOUtils.toString(request.getInputStream(), &quot;UTF-8&quot;); &#125;else&#123; paramStr += mapper.writeValueAsString(request.getParameterMap()); &#125; &#125;&#125; 将拦截器注入Spring容器 将数据库查询结果写入Redis缓存中 使用ResponseBodyAdvice 在响应结果被处理前拦截，拦截的逻辑自己实现，这样就可以将响应结果写入缓存中了 @ControllerAdvice进行拦截 supprot方法返回true才会执行beforeBodyWrite方法","tags":["开发","集群"],"categories":["开发"]},{"title":"框架设计","path":"/2024/01/18/Note/后端/Java/开发/框架设计/","content":"实体类设计 继承Model实现CRUD 前提是需要有对应的Mapper类并基础BaseMapper&lt;T&gt; 123456789@Data@EqualsAndHashCode(callSuper = true)@Accessors(chain = true)public class User extends Model&lt;User&gt; &#123; private Long id; private String name; private Integer age; private String email;&#125; 123456789101112131415public Boolean test(UserParam userParam)&#123; User user = new User(); Beanutil.copyProperty(userParam, user); //增 user.insert(); //删 user.deleteById(); //改 user.updateById(); user.update(UpdateWrappers&lt;User&gt;对象); //查 user.selectById(); user.selectOne(QueryWrappers&lt;User&gt;对象); user.selectPage(IPage对象, QueryWrappers&lt;User&gt;对象);&#125; 重要数据的dto都需要继承该类，然后通过mybatis填充器自动填充操作信息 12345678910111213141516171819@Getter@Setterpublic class DbEntity&lt;T&gt; &#123; //创建时间 @TableField(fill = FieldFill.INSERT) private Date createTime; //修改时间 @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; //创建者ID @TableField(fill = FieldFill.INSERT) private T createBy; //修改着ID @TableField(fill = FieldFill.INSERT_UPDATE) private T updateBy;&#125; 数据字典简介 构成 字典组 -&gt; key-value 字典可以做缓存，使用redis和lfu缓存淘汰策略 表结构字典组 字段名 类型 描述 id int id type varchar 字典组名 show char 表现形式 0 列表 1 树形 category varchar 字典类型 系统内置、业务类 des varchar 描述 remark varchar 备注 字典项 字段名 类型 描述 id pid 字典组id type 字典组名 key 字典项key value 字典项value sort 排序值 des 描述 remark 备注 实现 Controller 新增字典组 分页查询字典组信息 修改字典组 通过id删除字典组 新增字典项 分页查询字典项信息 修改字典项 树形查询字典项信息 通过id删除字典项 获取字典值 value 获取key-value 获取树形的key-value 获取key-value 无权限 获取字典值 value 无权限（无权限组） service Impl 注入DictServiceImpl（可以通过ApplicationContext） Mapper SysDictGroupMapper SysDictMapper 全局异常处理异常响应类123456789101112131415161718192021@Getterpublic class DefRunException extends RuntimeException&#123; private String message; private ExceptionEnum ex; public DefRunException(final ExceptionEnum ex, final String message) &#123; super(message); init(ex, message); &#125; public DefRunException(final ExceptionEnum ex, final String message, final Throwable cause) &#123; super(message, cause); init(ex, message); &#125; private void init(ExceptionEnum ex, String message) &#123; this.message = message; this.ex = ex; &#125;&#125; 异常断言接口1234567891011121314151617181920212223242526272829303132333435363738public interface ExceptionAssert &#123; //创建异常 DefRunException newException(Object... args); DefRunException newException(Throwable t, Object... args); //断言该对象不能为空对象 default void assertNotNull(Object obj, Object... args) &#123; if (obj == null) &#123; throw newException(args); &#125; if (obj instanceof String) &#123; if (((String) obj).length() == 0) &#123; throw newException(args); &#125; &#125; &#125; //断言是否True，是True则测试用例通过。 default void assertTrue(boolean isTrue, Object... args) &#123; if (!isTrue) &#123; throw newException(args); &#125; &#125; //断言是否False，是False则测试用例通过。 default void assertFalse(boolean isTrue, Object... args) &#123; if (isTrue) &#123; throw newException(args); &#125; &#125; //有一个为 null default void hasEmpty(String msg, Object... object) &#123; if (ObjectUtil.hasEmpty(object)) &#123; throw newException(ObjectUtil.isNull(msg) ? &quot;参数不能为null!&quot; : msg); &#125; &#125;&#125; 异常枚举类1234567891011121314151617181920212223242526272829303132333435363738@AllArgsmentpublic enum ExceptionEnum implements ExceptionAssert &#123; //内部异常（打印日志） INNER_MSG(&quot;&#123;0&#125;&quot;), //异常信息（返回给客户端异常信息） CLIENT_MSG(&quot;&#123;0&#125;&quot;), //异常编码，配置异常信息，返回给客户端 CLIENT_CODE(&quot;&#123;0&#125;&quot;), ; @Getter private String message; @Override public DefRunException newException(Object... args) &#123; String msg = MessageFormat.format(this.getMessage(), args); return new DefRunException(this, msg); &#125; @Override public DefRunException newException(Throwable t, Object... args) &#123; String msg = MessageFormat.format(this.getMessage(), args); return new DefRunException(this, msg, t); &#125; //直接抛配置好的异常信息给客户端 public void th(Object... args) &#123; throw newException(args); &#125; //直接抛内部异常，打印日志 public static void thro(Object... args) &#123; throw INNER_MSG.newException(args); &#125; //格式化输出 (&quot;aa &#123;&#125;&quot;, &quot;aa&quot;) public static String format(String msg, Object... objects) &#123; FormattingTuple ft = MessageFormatter.arrayFormat(msg, objects); return ft.getMessage(); &#125;&#125; 异常拦截器123456789@ResponseBodypublic class ExceptionCatch&#123; @ExceptionHandler(想要拦截的异常) public R exception()&#123; e.printStackTrace(); Log...; return R; &#125;&#125; 全局返回值123456789101112131415161718192021222324252627282930313233@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class R&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 1L; private int code; private String msg; private T data; public static R ok() &#123; return new R(CommonConstants.SUCCESS, null, null); &#125; public static &lt;T&gt; R&lt;T&gt; ok(T data) &#123; return new R(CommonConstants.SUCCESS, null, data); &#125; public static R failed() &#123; return new R(CommonConstants.FAIL, null, null); &#125; public static R failed(String msg) &#123; return new R(CommonConstants.FAIL, msg, null); &#125; public static R bol(boolean result) &#123; return bol(result, null); &#125; public static R bol(boolean result, String msg) &#123; return result ? R.ok() : R.failed(msg); &#125; public static &lt;T&gt; R&lt;T&gt; bol(T t, String msg) &#123; return Objects.nonNull(t) ? R.ok(t) : R.failed(msg); &#125;&#125; 全局常量信息 异常信息枚举类 各种异常信息状态码和友好响应信息 全局状态信息枚举类 全局配置信息处理 创建一个抽象类，提供一个抽象方法并在创建时初始化 123456789101112public abstract class SettingEntity implements Serializable &#123; private static final long serialVersionUID = 1L; &#123; defaultValue(); &#125; /** * 必须初始化值 */ abstract void defaultValue();&#125; 创建需要全局统一管理的配置信息对象 123456789101112131415161718@Getter@Setter@ToStringpublic class Gs extends GsSettingEntity &#123; private static final long serialVersionUID = -1629258515233154346L; //对象内部要对值进行初始化，也需要继承 GsSettingEntity @Valid private Gs1 gs1; @Valid private String str; @Override void defaultValue() &#123; gs1 = new Gs1(); this.str = &quot;默认值&quot;; &#125;&#125; 全局分页处理分页入参1234567891011121314151617181920212223242526public class PageFactory &#123; public static &lt;T&gt; Page&lt;T&gt; getPage() &#123; HttpServletRequest request = HttpServletUtil.getRequest(); switch (HttpMethod.valueOf(request.getMethod())) &#123; case GET: return getPageOfGetReq(request); case POST: // TODO default:break; &#125; return new Page&lt;T&gt;(); &#125; private static &lt;T&gt; Page&lt;T&gt; getPageOfGetReq(HttpServletRequest request) &#123; String ps = null; String p = null; if (ContentType.JSON.equals(request.getContentType())) &#123; // TODO &#125; else &#123; ps = request.getParameter(CommonConstants.PAGE_SIZE); p = request.getParameter(CommonConstants.PAGE_CURRENT); &#125; return new Page&lt;T&gt;(Convert.toInt(p, CommonConstants.PAGE_CURRENT_DEFAULT), Convert.toInt(ps, CommonConstants.PAGE_SIZE_DEFAULT)); &#125;&#125; 分页返回处理1234567891011121314151617public class PageUtils &#123; public static &lt;S, T&gt; IPage&lt;T&gt; covert(IPage&lt;S&gt; s, Class&lt;T&gt; t, Function&lt;S, T&gt; convert) &#123; Objects.requireNonNull(s); Page&lt;T&gt; page = new Page&lt;&gt;(s.getCurrent(), s.getSize(), s.getTotal()); page.setPages(s.getPages()); List&lt;S&gt; data = s.getRecords(); page.setRecords(data.stream().map(convert).collect(Collectors.toList())); return page; &#125; public static &lt;S, T&gt; IPage&lt;T&gt; covert(IPage&lt;S&gt; s, List&lt;S&gt; data, Class&lt;T&gt; t, Function&lt;S, T&gt; convert) &#123; Objects.requireNonNull(s); Objects.requireNonNull(data); Page&lt;T&gt; page = new Page&lt;&gt;(s.getCurrent(), s.getSize(), data.size()); page.setRecords(data.stream().map(convert).collect(Collectors.toList())); return page; &#125;&#125; 全局导入导出使用EasyExcel 动态列宽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//动态列宽public class ExcelCellWidthStyleStrategy extends AbstractColumnWidthStyleStrategy &#123; private static final int MAX_COLUMN_WIDTH = 50; private Map&lt;String, Map&lt;Integer, Integer&gt;&gt; CACHE = new ConcurrentHashMap&lt;&gt;(8); @Override protected void setColumnWidth(WriteSheetHolder writeSheetHolder, List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) &#123; boolean needSetWidth = isHead || !CollectionUtils.isEmpty(cellDataList); String key = Objects.isNull(writeSheetHolder.getSheetNo()) ? writeSheetHolder.getSheetName(): writeSheetHolder.getSheetNo() + &quot;&quot;; if (needSetWidth) &#123; // 获取 key -&gt; sheet 页各列的 宽度信息 Map&lt;Integer, Integer&gt; maxColumnWidthMap = CACHE.get(key); if (maxColumnWidthMap == null) &#123; maxColumnWidthMap = new ConcurrentHashMap&lt;&gt;(16); CACHE.put(key, maxColumnWidthMap); &#125; // 计算当前 单元格 内容的大小 Integer columnWidth = this.dataLength(cellDataList, cell, isHead); if (columnWidth &gt;= 0) &#123; if (columnWidth &gt; MAX_COLUMN_WIDTH) &#123; columnWidth = MAX_COLUMN_WIDTH; &#125; Integer maxColumnWidth = maxColumnWidthMap.get(cell.getColumnIndex()); // 若当前单元格的大小大约该列最大值 更新该列宽度 并记录 if (maxColumnWidth == null || columnWidth &gt; maxColumnWidth) &#123; maxColumnWidthMap.put(cell.getColumnIndex(), columnWidth); writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * 256); &#125; &#125; &#125; &#125; private Integer dataLength(List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Boolean isHead) &#123; if (isHead) &#123; return Math.min(cell.getStringCellValue().getBytes().length, &quot;默认宽度&quot;.getBytes().length); // 以内容长度作为主要宽度 head 长度不作为主要宽度 // return cell.getStringCellValue().getBytes().length; &#125; else &#123; CellData&lt;?&gt; cellData = cellDataList.get(0); CellDataTypeEnum type = cellData.getType(); if (type == null) &#123; return -1; &#125; else &#123; switch(type) &#123; case STRING: return cellData.getStringValue().getBytes().length; case BOOLEAN: return cellData.getBooleanValue().toString().getBytes().length; case NUMBER: return cellData.getNumberValue().toString().getBytes().length; default: return -1; &#125; &#125; &#125; &#125;&#125; 动态单元格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//动态单元格public abstract class BaseExcelCellStyleStrategy implements CellWriteHandler &#123; private Map&lt;String, Map&lt;Integer, String&gt;&gt; CACHE = new ConcurrentHashMap&lt;&gt;(8); @Override public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row, Head head, Integer columnIndex, Integer relativeRowIndex, Boolean isHead) &#123; setCellStyle(writeSheetHolder, row.getSheet().getWorkbook(), row.getCell(columnIndex &gt; 0 ? columnIndex - 1 : columnIndex), isHead); &#125; protected void setCellStyle(WriteSheetHolder writeSheetHolder, Workbook workbook, Cell cell, Boolean isHead) &#123; String key = Objects.isNull(writeSheetHolder.getSheetNo()) ? writeSheetHolder.getSheetName(): writeSheetHolder.getSheetNo() + &quot;&quot;; // 获取 key -&gt; sheet 页 列标 和 列信息 Map&lt;Integer, String&gt; columnMap = CACHE.get(key); if (columnMap == null) &#123; columnMap = new ConcurrentHashMap&lt;&gt;(16); CACHE.put(key, columnMap); &#125; // 计算当前 单元格 内容的大小 if (Objects.nonNull(cell)) &#123; int index = cell.getColumnIndex(); String headInfo = this.getCellHeadInfo(cell, isHead); if (StrUtil.isNotEmpty(headInfo)) &#123; columnMap.put(index, headInfo); &#125; else &#123; headInfo = columnMap.get(index); &#125; if (StrUtil.isNotEmpty(headInfo)) &#123; // 有效的头部信息 fillCellStyle(key, headInfo, cell, workbook); &#125; &#125; &#125; /** * 设置这个单元格的样式 * @param sheetName sheetName * @param headInfo 列头信息 * @param cell 单元格信息 * @param workbook */ protected abstract void fillCellStyle(String sheetName, String headInfo, Cell cell, Workbook workbook); private String getCellHeadInfo(Cell cell, Boolean isHead) &#123; if (isHead) &#123; return cell.getStringCellValue(); &#125; return null; &#125;&#125; 日志处理接口操作日志12345678910@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface OperationLog &#123; /** 业务的名称,例如:&quot;修改菜单&quot; */ String title() default &quot;&quot;; /** 业务操作类型枚举 */ LogOpTypeEnum opType() default LogOpTypeEnum.OTHER;&#125; 123456789@Getterpublic enum LogOpTypeEnum &#123; //其它 增加 删除 编辑 更新 查询 OTHER, ADD, DELETE, EDIT, UPDATE, QUERY, //详情 树 导入 导出 授权 强退 清空 DETAIL,TREE,IMPORT,EXPORT,GRANT,FORCE,CLEAN, //修改状态 CHANGE_STATUS&#125; 12345678910111213141516171819202122232425262728293031323334353637@Aspectpublic class OperationLogAop &#123; //日志切入点 @Pointcut(&quot;@annotation(com.bda.huijun.common.web.aop.log.OperationLog)&quot;) private void getLogPointCut() &#123;&#125; //操作成功返回结果记录日志 @AfterReturning(pointcut = &quot;getLogPointCut()&quot;, returning = &quot;result&quot;) public void doAfterReturning(JoinPoint joinPoint, Object result) &#123; common(joinPoint, result, true); &#125;\t//操作发生异常记录日志 @AfterThrowing(pointcut = &quot;getLogPointCut()&quot;, throwing = &quot;exception&quot;) public void doAfterThrowing(JoinPoint joinPoint, Exception exception) &#123; common(joinPoint, exception, false); &#125; private void common(JoinPoint joinPoint, Object obj, boolean isSucess) &#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method = methodSignature.getMethod(); OperationLog operationLog = method.getAnnotation(OperationLog.class); String account = ApplicationContextHolder.getBean(LogConfigurationAdapter.class).getLoggingUserId(); String className = AopUtils.getClassName(joinPoint); String methodName = AopUtils.getMethodName(joinPoint); String methodParameter = AopUtils.getArgsJsonString(joinPoint); //异步记录日志 if (isSucess) &#123; String result = &quot;&quot;; if (LogOpTypeEnum.EXPORT == operationLog.opType() || LogOpTypeEnum.IMPORT == operationLog.opType()) &#123; result = JSON.toJSONString(R.ok(operationLog.opType().name() + &quot; sucessful!!!&quot;)); &#125; else if (Objects.nonNull(obj) &amp;&amp; (result = JSON.toJSONString(obj)).length() &gt; 256) &#123; result = result.substring(0, 256); &#125; LogManager.me().executeOperationLog(operationLog, account, className, methodName, methodParameter, result); &#125; else &#123; LogManager.me().executeExceptionLog(operationLog, account, className, methodName, methodParameter, (Exception) obj); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class LogManager &#123;\t//异步操作记录日志的线程池 private static final ScheduledThreadPoolExecutor EXECUTOR = new ScheduledThreadPoolExecutor(10, new ScheduledExecutorFactoryBean()); private LogManager() &#123; &#125; //单例模式 private static final LogManager LOG_MANAGER = new LogManager(); public static LogManager me() &#123; return LOG_MANAGER; &#125;\t//异步执行日志的方法 private void executeLog(TimerTask task) &#123; //如果演示模式开启，则不记录日志 if (LogProperties.DEMO.equals(LogProperties.me().getModel())) &#123; return; &#125; //日志记录操作延时 int operateDelayTime = 10; EXECUTOR.schedule(task, operateDelayTime, TimeUnit.MILLISECONDS); &#125;\t//登录日志 public void executeLoginLog(final String account, final String success, final String failMessage) &#123; SysVisLog sysVisLog = this.genBaseSysVisLog(); TimerTask timerTask = LogTaskFactory.loginLog(sysVisLog, account, success, failMessage); executeLog(timerTask); &#125;\t//登出日志 public void executeExitLog(final String account) &#123; SysVisLog sysVisLog = this.genBaseSysVisLog(); TimerTask timerTask = LogTaskFactory.exitLog(sysVisLog, account); executeLog(timerTask); &#125;\t//操作日志 public void executeOperationLog(OperationLog operationLog, final String account, String className, String methodName, String methodParameter, final String result) &#123; SysOpLog sysOpLog = this.genBaseSysOpLog(); TimerTask timerTask = LogTaskFactory.operationLog(sysOpLog, account, operationLog, className, methodName, methodParameter, result); executeLog(timerTask); &#125;\t//异常日志 public void executeExceptionLog(OperationLog operationLog, final String account, String className, String methodName, String methodParameter, Exception exception) &#123; SysOpLog sysOpLog = this.genBaseSysOpLog(); TimerTask timerTask = LogTaskFactory.exceptionLog(sysOpLog, account, operationLog, className, methodName, methodParameter, exception); executeLog(timerTask); &#125;\t//构建基础访问日志 private SysVisLog genBaseSysVisLog() &#123; HttpServletRequest request = HttpServletUtil.getRequest(); if (ObjectUtil.isNotNull(request)) &#123; String ip = IpUtils.getClientIP(request); String address = IpAddressUtils.getAddressResult(ip); String browser = UaUtil.getBrowser(request); String os = UaUtil.getOs(request); return LogFactory.genBaseSysVisLog(ip, address, browser, os); &#125; else &#123; throw new RuntimeException(&quot;request is null!&quot;); &#125; &#125;\t//构建基础操作日志 private SysOpLog genBaseSysOpLog() &#123; HttpServletRequest request = HttpServletUtil.getRequest(); if (ObjectUtil.isNotNull(request)) &#123; String ip = IpUtils.getClientIP(request); String address = IpAddressUtils.getAddressResult(ip); String browser = UaUtil.getBrowser(request); String os = UaUtil.getOs(request); String url = request.getRequestURI(); String method = request.getMethod(); SysOpLog log = LogFactory.genBaseSysOpLog(ip, address, browser, os, url, method); log.setApp(ApplicationContextHolder.getServerName()); return log; &#125; else &#123; throw new RuntimeException(&quot;request is null!&quot;); &#125; &#125;&#125; logback配置1 权限处理 使用 @PreAuthorize(“@pms.hasPermission(“权限字段”)”) 进行权限配置 主要分为四种使用场景来设计 外部访问内部有可能造成危险的接口 对用户进行登录校验 对用户进行登录校验和权限校验 外部访问内部安全的接口 通过配置文件配置添加忽略路径 通过 @Inner注解 通过配置类 内部访问内部接口 通过OpenFeign进行远程调用 访问第三方接口 通过OpenFeign进行远程调用 工具封装JWT工具类12345678910111213141516171819202122232425262728293031public class JwtUtils&#123; // TOKEN的有效期一天(S) private static final int TOKEN_TIME_OUT = 3 600; // 加密KEY private static final String TOKEN_ENCRY_KEY = &quot;MDk4ZjziY200NjIxZDM3M2NhZGUOZTgzMjYyN2I0zjy&quot;; // 最小刷新间隔(S) private static final int REFRESH_TIME = 300; // 生产ID public static String getToken(Long id)&#123; Map&lt;String，Object&gt; claimMaps = new HashMap&lt;&gt;(); claimMaps.put(&quot;id&quot;,id); long currentTime = System.currentTimeMillis(); return Jwts .builder() .setId(UUID.randomUUID().toString()) .setIssuedAt(new Date(currentTime))//签发时间 .setSubject(&quot;system&quot;) //说明 .setIssuer(&quot;heima&quot;) //签发者信息 .setAudience(&quot;app&quot;)//接收用户 .compresswith(CompressionCodecs.GZIP) //数据压缩方式 .signwith(SignatureAlgorithm.HS512，generalKey()) //加密方式 .setExpiration(new Date(currentTime + TOKEN_TIME_OUT * 1000)) //过期时间 .addClaims(claimMaps) //cla信息 .compact(); &#125; &#125; Mybatis工具类1234567891011121314151617181920212223242526public class PageFactory &#123; public static &lt;T&gt; Page&lt;T&gt; getPage() &#123; HttpServletRequest request = HttpServletUtil.getRequest(); switch (HttpMethod.valueOf(request.getMethod())) &#123; case GET: return getPageOfGetReq(request); case POST: // TODO default:break; &#125; return new Page&lt;T&gt;(); &#125; private static &lt;T&gt; Page&lt;T&gt; getPageOfGetReq(HttpServletRequest request) &#123; String ps = null; String p = null; if (ContentType.JSON.equals(request.getContentType())) &#123; // TODO &#125; else &#123; ps = request.getParameter(CommonConstants.PAGE_SIZE); p = request.getParameter(CommonConstants.PAGE_CURRENT); &#125; return new Page&lt;T&gt;(Convert.toInt(p, CommonConstants.PAGE_CURRENT_DEFAULT), Convert.toInt(ps, CommonConstants.PAGE_SIZE_DEFAULT)); &#125;&#125; Redis工具类Date工具类Security工具类Url工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class UrlUtils &#123; //判断一个字符串是否为url public static boolean isURL(String str)&#123; //转换为小写 str = str.toLowerCase(); String regex = &quot;^((https|http|ftp|rtsp|mms)?://)&quot; //https、http、ftp、rtsp、mms + &quot;?(([0-9a-z_!~*&#x27;().&amp;=+$%-]+: )?[0-9a-z_!~*&#x27;().&amp;=+$%-]+@)?&quot; //ftp的user@ + &quot;(([0-9]&#123;1,3&#125;\\\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; // IP形式的URL- 例如：199.194.52.184 + &quot;|&quot; // 允许IP和DOMAIN（域名） + &quot;([0-9a-z_!~*&#x27;()-]+\\\\.)*&quot; // 域名- www. + &quot;([0-9a-z][0-9a-z-]&#123;0,61&#125;)?[0-9a-z]\\\\.&quot; // 二级域名 + &quot;[a-z]&#123;2,6&#125;)&quot; // first level domain- .com or .museum + &quot;(:[0-9]&#123;1,5&#125;)?&quot; // 端口号最大为65535,5位数 + &quot;((/?)|&quot; // a slash isn&#x27;t required if there is no file name + &quot;(/[0-9a-z_!~*&#x27;().;?:@&amp;=+$,%#-]+)+/?)$&quot;; return str.matches(regex); &#125; //解析出url参数中的键值对 //如 &quot;index.jsp?Action=del&amp;id=123&quot;，解析出Action:del,id:123存入map中 public static Map&lt;String, String&gt; URLRequest(String URL) &#123; Map&lt;String, String&gt; mapRequest = new HashMap&lt;String, String&gt;(); String[] arrSplit = null; String strUrlParam = TruncateUrlPage(URL); if (strUrlParam == null) &#123; return mapRequest; &#125; //每一个键值为一组 www.2cto.com arrSplit = strUrlParam.split(&quot;[&amp;]&quot;); for (String strSplit : arrSplit) &#123; String[] arrSplitEqual = null; arrSplitEqual = strSplit.split(&quot;[=]&quot;); //解析出键值 if (arrSplitEqual.length &gt; 1) &#123; //正确解析 mapRequest.put(arrSplitEqual[0], arrSplitEqual[1]); &#125; else &#123; if (arrSplitEqual[0] != &quot;&quot;) &#123; //只有参数没有值，不加入 mapRequest.put(arrSplitEqual[0], &quot;&quot;); &#125; &#125; &#125; return mapRequest; &#125; //去掉url中的路径，留下请求参数部分 private static String TruncateUrlPage(String strURL) &#123; String strAllParam = null; String[] arrSplit = null; strURL = strURL.trim(); arrSplit = strURL.split(&quot;[?]&quot;); if (strURL.length() &gt; 1) &#123; if (arrSplit.length &gt; 1) &#123; if (arrSplit[1] != null) &#123; strAllParam = arrSplit[1]; &#125; &#125; &#125; return strAllParam; &#125; //获取 public static String getIPAddress(HttpServletRequest request) &#123; String ip = null; //X-Forwarded-For：Squid 服务代理 String ipAddresses = request.getHeader(&quot;X-Forwarded-For&quot;); if (ipAddresses == null || ipAddresses.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddresses)) &#123; //Proxy-Client-IP：apache 服务代理 ipAddresses = request.getHeader(&quot;Proxy-Client-IP&quot;); &#125; if (ipAddresses == null || ipAddresses.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddresses)) &#123; //WL-Proxy-Client-IP：weblogic 服务代理 ipAddresses = request.getHeader(&quot;WL-Proxy-Client-IP&quot;); &#125; if (ipAddresses == null || ipAddresses.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddresses)) &#123; //HTTP_CLIENT_IP：有些代理服务器 ipAddresses = request.getHeader(&quot;HTTP_CLIENT_IP&quot;); &#125; if (ipAddresses == null || ipAddresses.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddresses)) &#123; //X-Real-IP：nginx服务代理 ipAddresses = request.getHeader(&quot;X-Real-IP&quot;); &#125; //有些网络通过多层代理，那么获取到的ip就会有多个，一般都是通过逗号（,）分割开来，并且第一个ip为客户端的真实IP if (ipAddresses != null &amp;&amp; ipAddresses.length() != 0) &#123; ip = ipAddresses.split(&quot;,&quot;)[0]; &#125; //还是不能获取到，最后再通过request.getRemoteAddr();获取 if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddresses)) &#123; ip = request.getRemoteAddr(); &#125; return ip; &#125;&#125; OkHttp3工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class OkHttp3Utils &#123; private static OkHttpClient httpClient = null; private static OkHttpClient httpsClient = null; private static OkHttpClient httpsClientW = null; private static Type type = Type.HTTP; public enum Type &#123; //http, https, https 绕过 HTTP, HTTPS, HTTPSW; &#125; public static String get(final String url) throws IOException &#123; return commonRequest(url, Request.Builder::get); &#125; // application/x-www-form-urlencoded public static String post8from(final String url, final Map&lt;String, String&gt; parameters) throws IOException &#123; return post8from(url, formBody -&gt; &#123; if (parameters == null) &#123; throw new IllegalAccessError(&quot;parameters is null!&quot;); &#125; for(Map.Entry&lt;String, String&gt; entry : parameters.entrySet()) &#123; formBody.add(entry.getKey(), entry.getValue()); &#125; &#125;); &#125; // application/x-www-form-urlencoded public static String post8from(final String url, final String... values) throws IOException &#123; return post8from(url, formBody -&gt; &#123; if (values != null &amp;&amp; values.length &gt; 2 &amp;&amp; values.length%2 == 0) &#123; for(int index = 0; index &lt; values.length;) &#123; formBody.add(values[index++], values[index++]); &#125; &#125; &#125;); &#125; // application/x-www-form-urlencoded public static String post8from(final String url, final Consumer&lt;FormBody.Builder&gt; consumer) throws IOException &#123; FormBody.Builder formBody = new FormBody.Builder(); consumer.accept(formBody); RequestBody requestBody = formBody.build(); return commonRequest(url, builder -&gt; builder.post(requestBody)); &#125; // application/json public static String post8json(final String url, final Object jsonObject) throws IOException &#123; if (jsonObject == null) &#123; throw new IllegalAccessError(&quot;jsonObject is null!&quot;); &#125; return post8json(url, JSONObject.toJSONString(jsonObject)); &#125; // application/json public static String post8json(final String url, final String json) throws IOException &#123; if (json == null) &#123; throw new IllegalAccessError(&quot;json is null!&quot;); &#125; RequestBody body = RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), json); return commonRequest(url, builder -&gt; builder.post(body)); &#125; // application/json public static String post8json(final Consumer&lt;Request.Builder&gt; header, final String url, final String json) throws IOException &#123; if (json == null) &#123; throw new IllegalAccessError(&quot;json is null!&quot;); &#125; RequestBody body = RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), json); return commonRequest(url, builder -&gt; &#123; header.accept(builder); builder.post(body); &#125;); &#125; public static String checkHttpUrl(final String url) &#123; // TODO 汉子处理 /*if (url == null || !UrlUtils.isURL(url)) &#123; throw new IllegalArgumentException(&quot;Http 请求 Url 错误: &quot; + url); &#125;*/ return url; &#125; private static String commonRequest(final String url, final Consumer&lt;Request.Builder&gt; consumer) throws IOException &#123; Request.Builder builder = new Request.Builder().url(checkHttpUrl(url)); // 请求做成 consumer.accept(builder); Request request = builder.build(); final Call call = getHttpClient().newCall(request); Response response = call.execute(); return Objects.requireNonNull(response.body()).string(); &#125; public static synchronized String executeHttpRequest(Supplier&lt;String&gt; http, Type type) &#123; String result; OkHttp3Utils.type = type; result = http.get(); OkHttp3Utils.type = Type.HTTP; return result; &#125; private static synchronized OkHttpClient getHttpClient() &#123; OkHttpClient client = null; switch (type) &#123; case HTTP: if (httpClient == null) &#123; httpClient = new OkHttpClient.Builder() // 设置连接超时时间 .connectTimeout(60, TimeUnit.SECONDS) //设置读取超时时间 .readTimeout(60, TimeUnit.SECONDS) .build(); &#125; client = httpClient; break; case HTTPS: // 暂时不用 case HTTPSW: if (httpsClientW == null) &#123; X509TrustManager manager = SSLSocketClient.getX509TrustManager(); OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.sslSocketFactory(SSLSocketClient.getSocketFactory(manager), manager); builder.hostnameVerifier(SSLSocketClient.getHostnameVerifier()); httpsClientW = builder // 设置连接超时时间 .connectTimeout(60, TimeUnit.SECONDS) //设置读取超时时间 .readTimeout(60, TimeUnit.SECONDS) .build(); &#125; client = httpsClientW; break; default: // nothing do to. break; &#125; // 重置 type = Type.HTTP; return client; &#125; &#125; SSLSocketClinet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * ssl 绕过 */public class SSLSocketClient &#123; public static SSLSocketFactory getSocketFactory(TrustManager manager) &#123; SSLSocketFactory socketFactory = null; try &#123; SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;); sslContext.init(null, new TrustManager[]&#123;manager&#125;, new SecureRandom()); socketFactory = sslContext.getSocketFactory(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return socketFactory; &#125; public static X509TrustManager getX509TrustManager() &#123; return new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;; &#125; public static HostnameVerifier getHostnameVerifier() &#123; HostnameVerifier hostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String s, SSLSession sslSession) &#123; return true; &#125; &#125;; return hostnameVerifier; &#125;&#125; AOP工具类12345678910111213141516171819202122232425262728293031@UtilityClasspublic class AopUtils &#123; public static String getClassName(JoinPoint joinPoint) &#123; return joinPoint.getTarget().getClass().getName(); &#125; public static String getSimpleClassName(JoinPoint joinPoint) &#123; String className = getClassName(joinPoint); return className.substring(className.lastIndexOf(&quot;.&quot;) + 1); &#125; public static String getMethodName(JoinPoint joinPoint) &#123; return joinPoint.getSignature().getName(); &#125;\t//获取切面的参数json public static String getArgsJsonString(JoinPoint joinPoint) &#123; StringBuilder argsJson = new StringBuilder(); Object[] args = joinPoint.getArgs(); for (Object arg : args) &#123; if (!isFilterObject(arg)) &#123; if (ObjectUtil.isNotNull(arg)) &#123; String jsonStr = JSON.toJSONString(arg); argsJson.append(jsonStr).append(&quot; &quot;); &#125; &#125; &#125; return argsJson.toString().trim(); &#125;\t//判断是否需要拼接参数，过滤掉HttpServletRequest,MultipartFile,HttpServletResponse等类型参数 private static boolean isFilterObject(Object arg) &#123; return arg instanceof MultipartFile || arg instanceof HttpServletRequest || arg instanceof HttpServletResponse; &#125;&#125; 文档生成部署Docker-compose 需要将各个模块分别部署，所有模块需要在同一级目录下 mysql需要打包配置和数据 编写对应的 DockerFile 文件 1234567891011121314151617181920212223242526272829303132# 第一阶段FROM openjdk:8 as builder# 工作目录为/build 相对目录WORKDIR /build# 设置常量ARG JAR_FILE=./模块名.jar# 拷贝target/模块名.jar 到/build/app.jarCOPY $&#123;JAR_FILE&#125; app.jar# 执行shell命令 使用分层 这里就是解压jar包分层成各个目录 目的是为了更新的时候局部更新 加快镜像pull速度# /build/dependencies# /build/snapshot-dependencies# /build/spring-boot-loader# /build/applicationRUN java -Djarmode=layertools -jar app.jar extract &amp;&amp; rm app.jar# 第二阶段 引用第一阶段的镜像builderFROM openjdk:8MAINTAINER 569421432@qq.comENV JAVA_OPTS=&quot;-Xms1024m -Xmx1024m -Duser.timezone=GMT+8 -DNACOS_HOST=10.1.3.160 -Djava.security.egd=file:/dev/./urandom&quot;ENV JAVA_EX=&quot;-DMYSQL_HOST=192.168.8.91 -DMYSQL_PORT=3306 -DMYSQL_PWD=hj@123456 -DMYSQL_DB=bling -DREDIS_HOST=192.168.8.91 -DREDIS_PWD=hj@123456 -Dspring.profiles.active=test&quot;WORKDIR /opt# 将builder（第一阶段）的文件copy到/optCOPY --from=builder /build/dependencies/ ./COPY --from=builder /build/snapshot-dependencies/ ./COPY --from=builder /build/spring-boot-loader/ ./COPY --from=builder /build/application/ ./EXPOSE 8080# 容器启动时执行CMD java $JAVA_OPTS $JAVA_EX org.springframework.boot.loader.JarLauncher 编写一个方便重新启动的文件 restart.sh 12345678910#!/bin/bashif [ &quot;$1&quot; = &#x27;&#x27; ]; then echo &quot;You need to enter a project name!&quot;else docker-compose stop $1 docker-compose rm -f $1 docker-compose build $1 docker-compose up -d $1 echo &quot;ok !!!&quot;fi 启动：./restart.sh 模块名","tags":["框架","开发"],"categories":["开发"]},{"title":"系统设计","path":"/2024/01/18/Note/后端/Java/开发/系统设计/","content":"简介CRM（客户关系管理系统） 应用 OA系统、HR系统 SRM（供应商关系管理系统） 应用 进销存系统 SCM（供应链管理系统） 应用 数据中台 SaaS（软件即服务） 开箱即用 应用 第三方系统、OA系统、HR系统、网盘 PaaS（平台即服务） 应用 开源系统、第三方Api&#x2F;服务 IaaS（基础架构即服务） 应用 虚拟机、云存储、云服务器 项目开发流程 设计产品原型 需求分析 模块设计 接口文档 前后端分离开发 测试 部署上线 一致性 多级缓存一致性 事务一致性 稳定性 有异常但不影响使用，但是要刨根问底的解决 平滑性 项目部署 产品技术思维 即很多技术问题可以通过业务手段来规避 12315为例 存储的性能的挑战 通过分时段售票，候补票机制，验证码等等规避 反常规设计 12306抢票设计 通过分时段抢票、候补票等机制规避了超高并发的设计困难 设计模式类关系设计 关联关系 单 &#x2F; 双&#x2F; 自 关联 聚合关系 整体和部分的关联 部分可以脱离整体对象并独立存在 组合关系 整体和部分的关联，更强烈的聚合关系 部分不能脱离整体对象并独立存在 继承 &#x2F; 泛化关系 实现关系 依赖关系 是一种使用关系，耦合度最低 是一种临时性的关联 例如调用某个类的局部变量&#x2F;静态方法，作为方法的入参 设计原则 接口单一职责 一个接口只处理一种类型的任务 接口隔离原则 接口实现类不应该被迫依赖其不使用的方法 一个类对另一个类的依赖应该建立在实现最少的接口 依赖倒装原则 如controller不直接使用接口实现类，而是使用的接口提供的方法 即高层模块不依赖低层模块，两者都应该依赖其抽象接口 对抽象进行编程，而不是对实现进行编程 合成复用原则 尽量使用聚合、关联、组合等类的关系，其次在考虑继承 里氏替换原则 在使用父类的地方，其子类可以完全替换其父类 子类应该扩展父类的方法，但不要重写父类的方法 迪米特法则 两个实体最好不要直接通信，最好通过第三方通信 开闭原则 对修改封闭，对扩展开放 在程序需要扩展时不应该去修改源代码，而是实现一种热插拔的形式 程序设计扩展性要好、易维护、易升级 即尽量使用接口和抽象类 创建型设计模式单例模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//饿汉构造public class Hungry &#123; public static final Hungry HUNGRY = new Hungry(); private Hungry()&#123;&#125;&#125;//枚举public enum Hungry &#123; INSTANCE;&#125;//饿汉代码块public class Hungry &#123; public static final Hungry HUNGRY; static &#123; /*一般在这个静态代码块中加载配置*/ HUNGRY = new Hungry(); &#125; private Hungry()&#123;&#125;&#125;//懒汉构造public class Lazy &#123; private static Lazy lazy = null; private Lazy()&#123;&#125; //锁的粒度比较粗 public static synchronized Lazy getInstance()&#123; if (lazy == null) return lazy = new Lazy(); return lazy; &#125;&#125;//双重检查锁public final class Lazy implements Serializable&#123; //防止指令重排和使用到半初始化状态的对象 volatile private static final Lazy INSTANCE = null; private Lazy()&#123; //防止反射破坏单例 synchronized&#123; if(INSTANCE != null) &#123; throw new RuntimeException(&quot;不能创建多个单例对象&quot;); &#125; &#125; &#125; public static Lazy getInstance()&#123; //提高效率，当有实例了不用再去争抢锁 if(INSTANCE == null) &#123; synchronized (Lazy.class) &#123; //防止阻塞队列的线程重新创建对象 if (INSTANCE == null) return INSTANCE = new Lazy(); &#125; &#125; return INSTANCE; &#125; //防止反序列化时返回新的对象 public Object readResovle()&#123; return INSTANCE; &#125;&#125;//内部类public final class Lazy &#123; private Lazy()&#123;&#125; private static class inner&#123; private static final Lazy LAZY = new Lazy(); &#125; public static Lazy getInstance()&#123; return inner.LAZY; &#125;&#125; 工厂模式建造者模式 用于构造复杂对象 包含四个角色 抽象建造者类（Builder）：接口 具体建造者类（ConcreteBuilder）：实现Builder接口 产品类（Product）：要构造的复杂对象 指挥者类（Director）：调用ConcreteBuilder来创建Product复杂对象 原型模式 需要频繁创建对象的场景，并且这些对象都属于同一种类型 通过clone方式实现对象创建 一般结合工厂模式实现 使用场景 账单推送 结构型设计模式代理模式组合模式 部分整体 定义个各层次对象的共有方法和属性，预先定义一些默认的行为 定义非叶子节点的行为，存储子节点，组合非叶子节点和叶子节点形成树 定义叶子节点下无分支 有透明组合模式和安全组合模式 透明组合模式是标准模式 不安全，叶子节点不应该具有添加、删除等功能 安全组合模式 安全，不同的节点提供其对应的方法，实现复杂 适配器模式 扩展新的访问方式 使用场景 适用与调用端较多、需求变化频繁的场景 行为型设计模式观察者模式解释器模式 有性能问题和类膨胀问题 采用的是递归的调用方式，复杂度比较高，而且不容易debug，代码维护比较麻烦 每个解释器的语法的结束都会产生一个非终结符表达式，导致类文件过多膨胀，不好维护 模板方法模式 提高现有代码的扩展能力 代码中提供增加扩展的方法，可以用一个集合存放可能扩展的功能接口，然后再代码中遍历调用 大致的实现确定，少部分不确定的，就可以将这部分设计为模板 这部分将推迟实现，提高代码复用性，实现反向控制 使用场景 处理用户行为日志 代码设计简单工厂模式 将调用方和类解耦，将具体业务放在工厂类中实现 封装了创建对象的过程，避免了修改调用方代码，更容易扩展 虽然解除了调用方和类的耦合，但是产生了新的耦合，即工厂类和类的耦合，修改业务时依然需要修改工厂类代码，违背了开闭原则 可以把工厂类中的业务方法定义为静态的，方便调用 两阶段终止模式 一个线程t1 优雅的停止另一个线程t2，给t2一个料理后事的机会 如果直接终止t2会导致t2锁住的资源无法释放，导致死锁 分布式设计分布式寻址哈希取余分区简介 根据集群数量哈希取余，均匀的分配到每一台机器上 优缺点 优点是简单 缺点是不利于扩容，还有就是如果节点宕机需要重新取余，不稳定 一致性哈希算法分区简介 对2^32^ 取余 步骤 算法构建一致性哈希环 将 0 ~ 2^32^ 的线性空间拼接成一个环 服务器IP节点映射到这个哈希环上 key落到服务器的落键规则 请求同样对2^32^ 取余，然后落在环上顺时针走，遇到的第一个服务器就处理这个请求 优缺点 优点 容错性高、扩展性强 缺点 节点太少回导致数据倾斜的问题 通过虚拟节点解决 哈希槽分区简介 用一个 2^14^ 大的数组，作为哈希槽 最多只有16384个槽 因为redis的节点不会超过1000个，够用了 相当于在请求和redis之间添加了一个反向代理（槽），由它来选择存储的redis节点 幂等性接口幂等 同一个接口请求多次结果相同 方案 把传入的数据md5转换后存入redis，使用setnx存入 数据库唯一约束 前端发请求携带一个额外的token，两次token一致则不执行 加乐观锁（csa） 状态机 插入前先查找 加悲观锁 分布式缓存 Redis哨兵集群、分片集群 分布式锁具体实现 MySQL实现 创建一张锁表，加锁时在锁表中添加一条记录，释放锁时删除记录 如果有并发请求同时提交到数据库，数据库会保证只有一个请求能够得到锁 属于数据库 IO 操作，效率不高，而且频繁操作会增大数据库的开销，因此这种方式在高并发、高性能的场景中用的不多 ZooKeeper实现 是一个比较重的分布式组件 Redis实现 setNx，需要加入过期时间 Redission 分布式事务XA协议 因为多个事务在多个不同的节点上执行，其中一个节点失败或者延迟，往往会导致整个系统的一致性受到破坏 角色 AP（Application）：应用系统（服务） TM（Transaction Manager）：事务管理器（全局事务管理） RM（Resource Manager）：资源管理器（数据库） 具体实现 两阶段提交（2PC） 可以保证事务的原子性和一致性，但是需要额外的开销和时间，不适合高并发和高吞吐的系统 整个过程中事务管理器（TM）很关键，如果其宕机会导致资源管理器（RM）不可用 事务处理过程中资源管理器（RM）处于阻塞状态，事务提交后才释放资源 由于网络问题可能出现数据不一致的问题（部分节点没有接收到Commit操作） 三阶段提交（3PC） 为解决两阶段提交协议的单点故障和同步阻塞问题 步骤 CanCommit：准备阶段。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应 PreCommit：预提交阶段。协调者根据参与者在准备阶段的响应判断是否执行事务还是中断事务，参与者执行完操作之后返回ACK响应，同时开始等待最终指令 DoCommit：提交阶段。协调者根据参与者在准备阶段的响应判断是否执行事务还是中断事务 补偿机制（TCC） 在业务层实现的分布式事务，保证最终一致性 配合状态机实现 Try：资源检测和预留 Confirm：完成资源操作业务，Try成功，Confirm一定要能成功 Cancel：预留资源释放，可以看作是try的反向操作，即回滚 规避了两阶段提交数据库性能低下的问题 由于在业务层实现，所以开发成本高，对业务侵入较大和耦合度高 消息队列 使用MQ的事务消息机制 将事务的各个阶段转化为消息的处理，以此来确保事务的顺序性和一致性 存在延迟和数据重复的问题 本地消息表 将分布式事务拆分成本地事务进行处理，属于最终一致性 步骤 在数据库中新增一张消息表，将事务操作记录到消息表中（两个操作在一个事务中） 通过轮询的方式将消息表中新增的消息推送到mq，数据库再去mq中消费信息（保证幂等） 数据库处理完成后 框架 Seata 使用的是两阶段提交 分布式限流限流算法 计数器 设置单位时间内能够处理的最大请求数 存在浪费性能的问题 请求可能在单位时间内早就处理完成了，剩余的时间没处理请求，资源浪费 该问题也称为 突刺现象 漏桶算法 漏桶流算法 令牌桶算法 分库分表","tags":["开发"],"categories":["开发"]},{"title":"代码规范","path":"/2024/01/18/Note/后端/Java/开发/规范/","content":"概念数据模型 值 场景 DTO 接口入参，即前端传给后端的Json接收对象 VO 接口返回对象，即后端传给前端展示数据用的对象 PO 数据库表对应的对象，和Entity等同 BO 业务对象，即一组PO，例如员工信息，包括了（基础，入职、离职等等） DAO 数据访问对象，操作数据库的对象 LomboK 避免使用@Data注解，使用@Getter、@Setter、@ToString替代 尽量自己实现 hashCode 和 equals 方法 在使用 Lombok 的情况下 boolean类型的变量不能以 is 开头 字段名前两个字母最好为小写，非要有大写的话使用 @TableField 注解指定字段，或者专门为其写 get 和 set 方法 返回值处理 如果返回的集合没有数据的话就返回空集合，不要返回null Spring 使用构造注入替代@Autowired注入Bean对象 好处 能够在项目启动时检测出出现循环依赖的模块 可以使用final关键字来修饰依赖字段使其不可变 事务规范 如果事务方法中涉及远程网络调用的情况的话，不要使用spring的事务来控制 因为如果远程网络调用时间过长，事务占用时间就长，占用数据库资源的时间也长，可能会导致数据库连接不够用 数据库规范 如果创建的表在后续可能会新增字段，就在创建表时添加一些扩展字段 尽量不要创建外建约束 可以通过第三张表来表示两张表的关联关系 SQL规范 使用sum函数时如果可能出现为0的情况，需要使用 IFNULL(SUM(), 0) 约束 用String类型接收返回值时要注意null的问题，有可能返回 null 字符串的 尽量不要在已经线上正常运行的sql上加东西，最好再写一个sql 固定长度的字段选择char，不定的才选varchar char速度快，varchar节省空间 大文本字段使用text或longtext，最好用另外一张表存储 存储图片用blob或longblob 金额使用decimal 设置字段默认值，约束 业务规范当接口出现bug时 应该先查询有多少个地方使用了该接口 如果只有一处使用则可以进行修改 如果多出使用必须仔细排查和列出修改后可能出现的情况 xml可能存在复用的情况 项目上线后，当发现代码有错误或者冗余时，尽量不要修改","tags":["开发","技巧","规范"],"categories":["开发"]},{"title":"常见开发问题","path":"/2024/01/18/Note/后端/Java/开发/常见问题/","content":"找不到resource下的文件 在pom下加 本地运行正常，打jar包后运行不了，包重复resultmap问题 常见于资源、lib、代码分开打包的项目，资源中的mapper和resource中的mapper重复导致的 跨域 因为浏览器不能执行其他网站的脚本，它是由浏览器的同源策略导致的，是浏览器对js的安全限制 协议、域名、端口都要相同，一个不同即发生跨域 非简单请求需要先发送一个预检请求，服务器响应允许跨域后才能发送真实请求 post请求 解决方案 使用nginx nginx会和其他服务在同一个域，所以不会出现跨域问题 前提是前端项目、网关、后端服务等需要在一个域 配置当前请求允许跨域，添加响应头 可以在gateway的配置文件中添加全局过滤器 也可以编写配置类 非spring模块下的类加入spring容器 例如将全局异常处理写在了common包下，但是common包不属于spring管理的包，所以不起作用的情况 解决方法 在非spring模块的包里创建一个类，将需要加入容器的类通过@Import导入这个类 1234567@Configuration@Import(value = &#123; GlobalExceptionHandler.class&#125;)@EnableConfigurationPropertiespublic class WebExtendConfiguration &#123;&#125; 在resource下创建META-INF文件夹，文件夹下创建 spring.factories 12//加入org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.xz.market.common.web.WebExtendConfiguration redis集群ip问题 docker生成的主机ip地址，无法搭建集群 容器的ip地址，可以搭建集群，但是集群在客户端不可用，服务端可用 主机的ip地址，无法搭建集群 解决方案： 创建容器的时候指定网络类型为host 弊端：不安全，容器ip地址暴露 Netty冲突 Redis中使用到了netty，elasticSearch中也引入了netty，发生冲突 需要在启动类中添加 System.setProperty(&quot;es.set.netty.runtime.available.processors&quot;, &quot;false&quot;) 打包版本问题 打包的maven插件需要指定版本，与sprigboot版本一致 非法访问异常 Jdk &gt; 1.8 虚拟机加参数 --add-opens java.base/java.lang=ALL-UNNAMED spring-security获取不到Authentication 异常信息 For input string: “ANONYMOUS” 的错误 可能原因 没有获取到登录的用户导致的获取不到用户信息 解决方法 修改鉴权配置 排查代码问题 There is no PasswordEncoder mapped for the id “null” 这个错主要发生在Spring-Sercurity5.X版本上，例如SpringBoot2.x。导致这个错误发生主要原因就是在之前版本中的NoOpPasswordEncoder被DelegatingPasswordEncoder取代了，而你保存在数据库中的密码没有没有指定加密方式。 使用DelegatingPasswordEncoder解决 数据库字段采用一个字母加下划线开头 数据库字段例如：c_type 然后pojo类如果是：cType 会导致前端传参的时候取不到值 解决方法： pojo改为 ctype 然后用@TableField(“c_type”)，前端传 ctype 写XML的SQL如果有del_flag要记得写上注入Service失败 方法一：使用静态变量 加 @PostConstruct 解决。 123456789101112131415161718@Component //关键1public class ArticlesReceiver &#123; @Resource private WechatArticlesTempService wechatArticlesTempService; public static ArticlesReceiver articlesReceiver; //关键2 @PostConstruct //关键3 public void init()&#123; articlesReceiver = this; &#125; public WechatArticlesTemp getResposeArticlesBoby(String mediaId) &#123; WechatArticlesTemp articlesTemp = articlesReceiver.wechatArticlesTempService.getById(mediaId); //关键4 return articlesTemp ; &#125;&#125; 方法二：使用静态变量，加set注入 123456789101112131415@Component //关键1public class ArticlesReceiver &#123; private static WechatArticlesTempService wechatArticlesTempService; //关键2 @Autowired //关键3 public void setWechatArticlesTempService (WechatArticlesTempService wechatArticlesTempService)&#123; ArticlesReceiver.wechatArticlesTempService = wechatArticlesTempService; &#125; public WechatArticlesTemp getResposeArticlesBoby(String mediaId) &#123; WechatArticlesTemp articlesTemp = wechatArticlesTempService.getById(mediaId); //关键4 return articlesTemp ; &#125;&#125; 方法三：代码注入 ， SpringContectHolder类将用到的类的class读入让后再调用类中方法 12345678910@Component //关键1public class ArticlesReceiver &#123; private static WechatArticlesTempService wechatArticlesTempService = SpringContextHolder.getBean(WechatArticlesTempService.class); //关键2 public WechatArticlesTemp getResposeArticlesBoby(String mediaId) &#123; WechatArticlesTemp articlesTemp = wechatArticlesTempService.getById(mediaId); //关键3 return articlesTemp ; &#125;&#125; 导入的接口如果添加了日志注解可能会报错，但是接口能正常通过 解决方法 删除日志注解 序列化异常 可能的原因 redis缓存问题 解决方法 清理redis缓存 Request流只能读取一次 包装Request解决 通过过滤器进行包装request对象 用instanceof 判断是否包装过 创建MyServletRequestWrapper 继承 HttpServletRequestWrapper 通过过滤器包装request 创建数据失败，重启服务后又能成功创建 可能的原因 Redis自增生成的分布式ID返回了null值 推测1：有一段时间内执行了大量的任务，Redis连接未释放 推测2：spring事务中使用increment会返回null 推测3：同时开启spring事务和redis事务导致的（实际原因） 业务代码执行自增操作会返回null，但是redis中的值是会自增的 开启redis事务后，在spring事务中执行的redis命令也会被认为是在redis中执行的，所以不会立即返回结果，所以返回了null值 源码中是有一个Muti方法标记了redis事务块的开始 解决方案 redis事务操作完成后，关闭redis事务，然后再执行spring事务中的redis代码 多线程下可能还是会出现问题 创建两个StringRedisTemplate，一个专门用来执行redis事务，一个用来执行spring相关命令","tags":["开发","问题"],"categories":["开发"]},{"title":"开发技巧","path":"/2024/01/18/Note/后端/Java/开发/技巧/","content":"开发技巧一对多表修改1234567891011121314151617181920212223242526272829303132/*** 修改信息通用方法* exists 数据库存在的记录* params 修改时传的记录* T 是实体pojo* S 是对应的service对象，需要继承 IService* id 是主表的id* key 存id，value存记录*/public &lt;T, S extends IService&gt; Boolean updateCom(HashMap&lt;String, T&gt; exists, HashMap&lt;String, T&gt; params, S s, Long id)&#123; for (Map.Entry&lt;String, T&gt; entry : params.entrySet()) &#123; //修改 if (exists.containsKey(entry.getKey())) &#123; s.update(entry.getValue(), new QueryWrapper&lt;T&gt;().eq(&quot;id&quot;, entry.getKey())); &#125; //增加 if (&quot;null&quot;.equals(entry.getKey())) &#123; T value = entry.getValue(); BeanUtil.setFieldValue(value, &quot;uid&quot;, id); s.save(value); &#125; &#125; for (Map.Entry&lt;String, T&gt; entry : exists.entrySet()) &#123; //删除 if (!params.containsKey(entry.getKey())) &#123; s.remove(new QueryWrapper&lt;T&gt;().eq(&quot;id&quot;, entry.getKey())); &#125; &#125; exists.clear(); params.clear(); return true;&#125; 条件判断中in中for循环123456&lt;if test=&quot;clxz!=null and clxz!=&#x27;&#x27;&quot;&gt; and t2.CLXZ in &lt;foreach collection=&quot;clxz.split(&#x27;,&#x27;)&quot; index=&quot;index&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;item&#125;\t&lt;/foreach&gt;&lt;/if&gt; 使用MD5对第三方api接口进行签名验签 确保我们提供给第三方的api接口数据不会被抓包后篡改数据或进行重放攻击 前后端规定好一个sign，调用接口时需要传MD5加密过的数据 然后后端根据入参凭借规定好的sign加密数据，然后比对前端传进来的加密数据是否一致 还需要设置超时逻辑，允许一段时间内前端向后端发起的请求 实现 拦截器实现 远程调用本地模块中的一些数据 拦截需要给提示信息 拦截器中需要使用到容器中的bean，一般是会出现空指针异常的 在拦截器配置类中使用@Bean注册拦截器类即可 请求拦截后无任何提示信息，空白页面不友好 AOP实现 比较两个集合对象的异同123C.stream().filter(c -&gt; &#123; return I.stream().filter(i -&gt; i.getname() == c.getname()).count() &gt; 0;&#125;).collect(Collectors.toList()).forEach(hjUserContactMapper::insert); 大于0则相同，小于等于0不同 各项求比例后和为100%最大余额法1234567891011121314151617181920212223242526272829/*** 最大余额法 求百分比*/public static List&lt;Integer&gt; calculatePercent(List&lt;Long&gt; list) &#123; Long sum = list.stream().reduce(Long::sum).get(); List&lt;Integer&gt; valueInts = new ArrayList&lt;&gt;(); List&lt;Double&gt; ds = new ArrayList&lt;&gt;(); for (Long percent : list) &#123; double value = percent * 100 / (double) sum; //设置对应的百分比 int valueInt = (int) value; valueInts.add(valueInt); //获取小数点后的值 double d = value - valueInt; ds.add(d); &#125; //求和：当前各项百分比合计。由于我们舍弃了小数位，所以该合计只会小于等于100 int curSum = valueInts.stream().mapToInt(e -&gt; e).sum(); while (curSum &lt; 100) &#123; //找出小数余额最大的组，对其进行加1 Integer max = valueInts.stream().max(Comparator.comparingDouble(e -&gt; ds.get(valueInts.indexOf(e)) )).get(); valueInts.set(valueInts.indexOf(max), max + 1); //当前这个数已经加1了，不应该参与下一轮的竞选 ds.set(valueInts.indexOf(max + 1), 0.0); curSum++; &#125; return valueInts;&#125; 创建Map时添加值12345new HashMap&lt;K, V&gt;()&#123; &#123; put(key, value) &#125;&#125; Stream流取对象列表中日期最大值最小值12m.getValue().stream().min(Comparator.comparing(HjUserWorkHourDTO::getWorkDate)).get().getWorkDate();m.getValue().stream().max(Comparator.comparing(HjUserWorkHourDTO::getWorkDate)).get().getWorkDate(); 运维技巧SQL技巧截取身份证年月日DATE_FORMAT(cast(substring(&#39;44050919990409401X&#39;, 7, 8) as date), &#39;%Y-%m-%d&#39;) 通过身份证计算年龄YEAR(NOW())- SUBSTRING(hui.uid_code,7,4) xml返回Map12@MapKey(&quot;deptId&quot;)HashMap&lt;Long, List&lt;HjUserInfoDTO&gt;&gt; getDeptAndUser(); 1234567891011&lt;resultMap id=&quot;deptAndUser&quot; type=&quot;java.util.Map&quot;&gt; &lt;result property=&quot;deptId&quot; column=&quot;deptId&quot;/&gt; &lt;collection property=&quot;users&quot; javaType=&quot;java.util.ArrayList&quot; ofType=&quot;com.bda.huijun.hr.personnel.entity.vo.HjUserInfoVO&quot;&gt; &lt;result column=&quot;ID&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;UID_TYPE&quot; property=&quot;uidType&quot; /&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getDeptAndUser&quot; resultMap=&quot;deptAndUser&quot;&gt; &lt;/select&gt; 判断是否存在参数 _parmeter.containKey()","tags":["开发","技巧"],"categories":["开发"]},{"title":"工具","path":"/2024/01/18/Note/后端/Java/开发/工具/","content":"EasyExcel 可以使用pig4封装过后的EasyExcel，提供了注解式的使用导入导出，比较方便 下拉框service层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void template(HttpServletResponse response) throws IOException &#123; String fileName = &quot;人员导入模板.xls&quot;; WriteCellStyle headWriteCellStyle = new WriteCellStyle(); // 设置背景颜色 headWriteCellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex()); // 设置头字体 WriteFont headWriteFont = new WriteFont(); headWriteFont.setFontHeightInPoints((short)14); // 字体加粗 headWriteFont.setBold(true); headWriteCellStyle.setWriteFont(headWriteFont); // 设置头居中 headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER); // 内容策略 WriteCellStyle contentWriteCellStyle = new WriteCellStyle(); // 设置内容字体 WriteFont contentWriteFont = new WriteFont(); contentWriteFont.setFontHeightInPoints((short)12); contentWriteFont.setFontName(&quot;宋体&quot;); contentWriteCellStyle.setWriteFont(contentWriteFont); // 设置 水平居中 contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER); // 设置 垂直居中 contentWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER); // 设置单元格格式为 文本 DataFormatData dataFormatData = new DataFormatData(); dataFormatData.setIndex((short)49); contentWriteCellStyle.setDataFormatData(dataFormatData); HorizontalCellStyleStrategy horizontalCellStyleStrategy = new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle); //示例数据 List&lt;HjUserExportExcelVO&gt; example = this.list(Wrappers.&lt;HjUserInfoDTO&gt;query().last(&quot;limit 3&quot;)).stream().map(m -&gt; getHjUserInfoById(m.getId()) ).collect(Collectors.toList()).stream().map(m -&gt; &#123; HjUserExportExcelVO vo = new HjUserExportExcelVO(); BeanUtil.copyProperties(m, vo); vo.setCompanys(m.getCompany().getName()); vo.setDepts(m.getDept().get(0).getName()); return vo; &#125;).collect(Collectors.toList()); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setHeader(&quot;content-Type&quot;, &quot;application/vnd.ms-excel&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;)); // 设置表名，引脚名，文件格式，list数据 EasyExcel.write(response.getOutputStream(), HjUserExportExcelVO.class) .registerWriteHandler(horizontalCellStyleStrategy) .registerWriteHandler(new SpinnerWriteHandler()) .sheet(&quot;模板&quot;) .doWrite(example);&#125; 写拦截器 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Component@NoArgsConstructorpublic class SpinnerWriteHandler implements SheetWriteHandler &#123; private static SysDeptService sysDeptService; private static SysDictServiceImpl sysDictService; @Autowired public void init(SysDeptService sysDeptService, SysDictServiceImpl sysDictService)&#123; SpinnerWriteHandler.sysDeptService = sysDeptService; SpinnerWriteHandler.sysDictService = sysDictService; &#125; @Override public void afterSheetCreate(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder) &#123; //部门数据 List&lt;String&gt; dept = sysDeptService.getDepts(); // 这里的key值 对应导出列的顺序 从0开始 mapDropDown.put(0, dept); Sheet sheet = writeSheetHolder.getSheet(); /// 开始设置下拉框 DataValidationHelper helper = sheet.getDataValidationHelper();// 设置下拉框 for (Map.Entry&lt;Integer, String[]&gt; entry : mapDropDown.entrySet()) &#123; /*** 起始行、终止行、起始列、终止列 **/ CellRangeAddressList addressList = new CellRangeAddressList(1, 1000, entry.getKey(), entry.getKey()); /*** 设置下拉框数据 **/ DataValidationConstraint constraint = helper.createExplicitListConstraint(entry.getValue()); DataValidation dataValidation = helper.createValidation(constraint, addressList); /*** 处理Excel兼容性问题 **/ if (dataValidation instanceof XSSFDataValidation) &#123; dataValidation.setSuppressDropDownArrow(true); dataValidation.setShowErrorBox(true); &#125; else &#123; dataValidation.setSuppressDropDownArrow(false); &#125; sheet.addValidationData(dataValidation); &#125; &#125;&#125; 下拉超过50条不显示解决方案 123456789101112131415161718192021222324252627282930313233343536@Component@NoArgsConstructorpublic class LinenoConfWriteHandler implements SheetWriteHandler &#123; //Dao private static Dao dao; //加载spring容器中的Dao @Autowired public void init(Dao dao)&#123; LinenoConfWriteHandler.dao = dao; &#125; private char[] alphabet = new char[]&#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;&#125;; @Override public void afterSheetCreate(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder) &#123; //通过dao获取的下拉数据数组 String[] datas = dao.get(); //存放下拉数据 Map&lt;Integer, String[]&gt; mapDropDown = new HashMap&lt;&gt;(); mapDropDown.put(0, datas); // 开始设置下拉框 Sheet sheet = writeSheetHolder.getSheet(); DataValidationHelper helper = sheet.getDataValidationHelper(); //隐藏下拉数据的sheet String dictSheetName = &quot;sheet2&quot;; Workbook workbook = writeWorkbookHolder.getWorkbook(); Sheet dictSheet = workbook.createSheet(dictSheetName); workbook.setSheetHidden(workbook.getSheetIndex(dictSheet), true); &#125;&#125; 自定义列宽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.bda.huijun.common.excel.strategy;import com.alibaba.excel.enums.CellDataTypeEnum;import com.alibaba.excel.metadata.Head;import com.alibaba.excel.metadata.data.CellData;import com.alibaba.excel.metadata.data.WriteCellData;import com.alibaba.excel.write.metadata.holder.WriteSheetHolder;import com.alibaba.excel.write.style.column.AbstractColumnWidthStyleStrategy;import org.apache.commons.collections4.CollectionUtils;import org.apache.poi.ss.usermodel.Cell;import java.util.HashMap;import java.util.List;import java.util.Map;public class ExcelCellWidthStyleStrategy extends AbstractColumnWidthStyleStrategy &#123; // 可以根据这里的最大宽度，按自己需要进行调整,搭配单元格样式实现类中的，自动换行，效果更好 private static final int MAX_COLUMN_WIDTH = 50; private Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; CACHE = new HashMap(8); @Override protected void setColumnWidth(WriteSheetHolder writeSheetHolder, List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) &#123; boolean needSetWidth = isHead || !CollectionUtils.isEmpty(cellDataList); if (needSetWidth) &#123; Map&lt;Integer, Integer&gt; maxColumnWidthMap = (Map)CACHE.get(writeSheetHolder.getSheetNo()); if (maxColumnWidthMap == null) &#123; maxColumnWidthMap = new HashMap(16); CACHE.put(writeSheetHolder.getSheetNo(), maxColumnWidthMap); &#125; Integer columnWidth = this.dataLength(cellDataList, cell, isHead); if (columnWidth &gt;= 0) &#123; if (columnWidth &gt; MAX_COLUMN_WIDTH) &#123; columnWidth = MAX_COLUMN_WIDTH; &#125; Integer maxColumnWidth = (Integer)((Map)maxColumnWidthMap).get(cell.getColumnIndex()); if (maxColumnWidth == null || columnWidth &gt; maxColumnWidth) &#123; ((Map)maxColumnWidthMap).put(cell.getColumnIndex(), columnWidth); writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * 256); &#125; &#125; &#125; &#125; private Integer dataLength(List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Boolean isHead) &#123; if (isHead) &#123; return cell.getStringCellValue().getBytes().length; &#125; else &#123; CellData cellData = cellDataList.get(0); CellDataTypeEnum type = cellData.getType(); if (type == null) &#123; return -1; &#125; else &#123; switch(type) &#123; case STRING: return cellData.getStringValue().getBytes().length; case BOOLEAN: return cellData.getBooleanValue().toString().getBytes().length; case NUMBER: return cellData.getNumberValue().toString().getBytes().length; default: return -1; &#125; &#125; &#125; &#125;&#125; HutoolDES加密123456String salt = &quot;&quot;;SymmetricCrypto des = new SymmetricCrypto(SymmetricAlgorithm.DES, salt.getBytes());//加密String s = des.encryptHex(&quot;12345678&quot;);//解密String s1 = des.decryptStr(s); OkHttp3 支持 HTTP2&#x2F;SPDY &#x3D;&#x3D;SPDY&#x3D;&#x3D;是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验 共享Socket，对同一个主机发出的所有请求都可以共享相同的套接字连接，减少对服务器的请求次数 如果 HTTP&#x2F;2 和 SPDY 不可用，OkHttp 会使用连接池来复用连接以提高效率 socket自动选择最好路线，并支持自动重连，拥有自动维护的socket连接池，减少握手次数，减少了请求延迟 当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址 &#x3D;&#x3D;基于Headers的缓存策略&#x3D;&#x3D;减少重复的网络请求 拥有&#x3D;&#x3D;Interceptors&#x3D;&#x3D;轻松处理请求与响应（自动处理&#x3D;&#x3D;GZip&#x3D;&#x3D;压缩） &#x3D;&#x3D;Retrofit&#x3D;&#x3D;底层也是使用OkHttp 功能 文件的上传下载 加载图片(内部会图片大小自动压缩) 支持请求回调，直接返回对象、对象集合 支持session的保持","tags":["开发","工具"],"categories":["开发"]},{"path":"/2024/01/18/Note/后端/Java/开发/常用命令/","content":"Linux 查看端口占用 netstat -tuln 端口号 lsof -i:端口号 复制 cp [选项] 源文件 目标文件 -r：复制文件夹"},{"title":"开发优化","path":"/2024/01/18/Note/后端/Java/开发/优化/","content":"JVM优化目的 减少STW出现的次数 工具 jdk自带的JvisualVM可视化虚拟机内存模型 jps查看运行中的java进程 jmap查看堆内存的占用情况 jstack查看线程栈的情况 jconsole图形界面的，多功能的监测工具，实时监测 Arthas 阿里的JVM监控工具 可以定位死锁和CPU占用高的线程，能定位到异常代码 反编译线上代码 直接修改线上代码的值 将执行中的代码反编译并保存为文件 jad –source-only 全类名 &gt; 文件存放位置 编辑此文件 vim 将修改过后的文件进行编译 mc 文件存放地址 将编译后的字节码文件记载进线上程序 redefine 文件存放地址 JVM指令 效果 指令 堆内存的最大大小 -Xmx {大小} 堆内存的最小(初始)大小 -Xms {大小} 新生代大小 -Xmn {大小} 幸存区比例 -XX:SurvivorRation&#x3D; {大小} 幸存区晋升阈值，即对象进入老年代年龄 -XX:MaxTenuringThreshold&#x3D; {大小} 新生代和老年代比例 -XX:NewRation&#x3D; {大小}: {大小} 禁用显式的垃圾回收 -XX:+DisableExplicitGC 查看垃圾回收详细参数 -XX:+PrintGCDetails -verbose:gc 开启串行垃圾回收器 -XX:+UseSerialGC&#x3D;Serial+SeriaOld 设置from区晋升老年代阈值 -XX:TargetSurvivorRatio&#x3D;90 采用自适应新生代大小 -XX:+UseAdaptiveSizePolicy 调整垃圾回收时间和总时间占比 -XX:GCTimeRatio&#x3D;ratio 最大暂停毫秒数 -XX:MaxGCPauseMillis&#x3D;ms 开启指针压缩 -XX:+UseCompressedOops 查看虚拟机生效的参数 -XX:+PrintFlagsFinal 对字符串去重 -XX:+UseStringDeduplication 类加载器加载的类不再使用时卸载它加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 设置并发标记的起始时间 -XX:InitiatingHeapOccupancyPercent 大对象直接进入老年代(只在Serial和ParNew有效) -XX:PetenureSizeThreshold&#x3D; 优化原则 预估系统产生的对象的大小，调整Eden，Old，Survivor区的比例，尽量使快速过期的对象不进入Old区 可以通过压测来评估 权衡堆的大小 堆大GC时间短，但GC次数多 堆小GC时间长，但GC次数少 Xmx 和 Xms 一样大可以减少GC次数，但GC时间长 可以设置最小空闲比例 MinHeapFreeRatio。默认40，小于则扩展 设置最大空闲比例 MaxHeapFreeRatio，默认70，大于则压缩 对字符串去查 -XX: UseStringDeduplication 新生代优化 尽量能容纳所有 [ 并发量*(请求 - 响应) ] 的数据 幸存区需要大到能保留[ 当前活跃对象+需要晋升的对象 ] 合理的晋升阈值，让长时间存活对象尽早晋升至老年代 老年代优化 调大老年代的内存 大对象直接进入老年代 设置对象进入老年代的年龄 幸存区优化 提高From区的利用率，超过90%时进入老年代 -XX: TargetSurvivorRatio=90 Spring优化事务优化 避免大事务，事务粒度应该小一些 数据库优化索引设计原则 针对数据量大，查询频繁的表需要建立索引 对经常需要作为查询条件，排序，分组的字段建立索引 对区分度高的字段建立索引，尽量建唯一索引 尽量使用联合索引，并满足最左前缀法则，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 索引不是越多越好，会影响增删改效率 不能为可以为null的字段建立索引，需要使用 not null 约束，当优化器知道每列是否包含null值时，它可以更好的确定哪个索引最有效的用于查询 索引失效 没有满足最左前缀法则，跳过其中某一列或顺序不正确则其之后索引失效 联合索引中使用了 &gt; &lt; ，（&gt;&#x3D;，&lt;&#x3D;不会失效） like “%xx”（左模糊） 字符串没加引号 or两端有一端没有索引 MySQL评估走全表更快时 索引的字段进行运算时 索引的字段进行类型转换 索引的字段使用了函数 返回的字段很多，musql可能会选择不走索引 联合索引前部分用值比较，后面用了模糊比较，则从模糊比较处索引失效 索引的优化 对较长的字符型字段建立前缀索引 create Index on 表名(字段(长度)) 前缀的长度的大小最好是： 按前缀长度去重后的数量 &#x2F; 总数量 越接近1越好 使用 force index 强制使用索引 查询的字段尽量覆盖索引，减少 select * 的使用 mysql5.6之后支持索引下推，能减少回表 如果存储介质是机械硬盘的话，可以打开MRR，它可以把id存到buffer中，排序后写入磁盘 插入大批量数据时，使用load指令 手动提交事务 按主键顺序操作数据 SQL性能分析 慢查询日志 默认没有开启，需要在 /etc/my.cnf 中配置以下内容 show_query_log = 1 开启慢查询日志 long_query_time = 2 SQL查询超过2秒的为慢查询 重启mysql，在/var/lib/mysql/localhost-slow.log 中查看日志 SQL执行频率 show session / global status like &#39;Com_&#39; 查看SQL耗时情况 每一条SQL耗时：show profiles 指定SQL各阶段耗时：show profile for query &#123;id&#125; 指定SQL的CPU使用情况：show profile cpu for query &#123;id&#125; 查看SQL执行计划 explain sql语句 id：sql序列号，id值越大越先执行 select_type：查询的类型 simple：简单单表查询 primary：主查询，即外层的查询 union：联合查询后的查询 subquery：select&#x2F;where后的子查询 type：连接类型（null、system、const、eq_ref、ref、range、index、all） 如果使用的是主键索引或唯一索引一般是const possible_key：可能使用到的索引 key：实际使用到的索引 key_len：索引中使用的字节数（最大可能长度），越短越好 rows：必须要执行的查询的行数，innodb引擎中是一个估值 filtered：返回结果行数占需读取行数的百分比，越大越好 SQL优化 如果存储介质是机械硬盘，可以设置MRR开启顺序存储，这个功能会将插入的值按id排好序存到buffer中，顺序写入磁盘，提高插入效率，因为机械硬盘需要一个磁盘寻址的过程会影响效率 插入大批量数据时使用 load 指令 手动提交事务 插入时按主键顺序插入 MySQL5.6 之后支持索引下推，能减少回表 分页查询时使用 覆盖索引 + 子查询（想查询的id） select * 优化，使用具体的字段 排序优化 在创建索引是可以指定索引排序规则，符合规则的sql语句效率高 需要注意各字段的升降序，尽量一致，尽量覆盖索引 可以适当的增大排序缓冲区的大小 sort_buffer_size 默认是256k Join 优化 小表 join 大表 连接字段需要是索引字段 左右连接才有优化，内连接的话由mysql自行判断顺序 增大 join buffer 的大小 减少不必要的查询字段，可以缓存更多的数据 大表 join 大表的话可以为大表建立分区 算法 NLJ算法：双重for，连接字段为非索引就是用这个算法 BNLJ算法：把 join 的驱动表放到了内存 buffer 中，减少了循环次数 INLJ算法：连接字段为索引字段用这个算法，内层表的连接索引字段进行匹配，减少内层表的循环次数","tags":["优化","开发"],"categories":["开发"]},{"title":"Web","path":"/2024/01/18/Note/后端/Java/基础/Web/","content":"IO模型 BIO NIO AIO IO多路复用 类型 同步阻塞 同步非阻塞 异步非阻塞 异步阻塞 组成 字节流&#x2F;字符流 Buffer、Channel、Selector 场景 连接数少，短链接 连接数多，流量小 连接数多，流量大 连接数多，流量 BIO分类字节流 FileInputStream FileOutputStream 字符流 FileReader 可以读一个字符或一个字符数组 FileWriter 可以写一个字符或一个字符数组或字符数组的一部分 缓冲流 缓冲流自带8kb的缓存区，可以提高原始字节流读写数据的性能 字节缓存流： BufferedInputStream &#x2F; BufferedOutputStream 字符缓冲流： BufferedReader &#x2F; BufferedWrite 可按行读取 转换流 InputStreamReader 可以解决字符流读取不同编码乱码的问题 可以指定编码把原始字节流转换成字符流，解决乱码 OutputStreamWriter 按指定编码把字节输出流转换成字符输出流 序列化 对象输入流，反序列化 ObjectInputStream 对象输出流，序列化 ObjectOutputStream 打印流 字节输出流 PrintStream 字符输出流 PrintWriter 数据流 数据输入流 DataInputStream 数据输出流 DataOutputStream 弊端 一个Socket会创建一个线程，线程间的竞争和上下文切换开销很大 每个线程还会占用栈空间和CPU资源 Socket等待时浪费系统资源 无法支持高并发场景，可用线程池优化，但并不能真正的解决问题 NIO简介 Buffer缓冲区 是一个内存块，底层是一个数组，负责数据的读取和写入 固定容量，不能修改，读写需要指定操作数据的大小，不能超过容量 可以标记一个位置，然后通过reset方法跳到标记的位置 内部clear方法不会清除数据，它只会把position的位置设为0 可以分配直接内存给Buffer Channel管道 是一个接口 一个Channel对应一个Buffer 负责传输，可以非阻塞的读写，也支持异步读写，双向传输 Selector选择器 一个Selector对应多个Channel AIOIO多路复用 传统的select和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要遍历 IO多路复用epoll则会通知用户进程有Socket就绪并写入用户空间 Select 使用一个bitmap用来表示哪几个文件描述符是被监听的，大小是1024位， 每次与内核交互都需要传递这个bitmap，开销大且不好修改 位图不能复用，每次使用前需要将位图初始化 执行select函数是会将用户态的bitmap复制到内核态中，交给内核来判断事件，是一个阻塞函数，当事件有变动时会将描述符对应的事件置位，然后返回 开销比较大，而且当有事件就绪时不能明确知道是哪个事件，每次都需要遍历 poll 封装了一个对象pollfd，可复用 执行poll函数是会将用户态的pollfd复制到内核态中，交给内核来判断事件，当事件有变动时会将pollfd中的revents置位为1，然后返回 每次都要将就绪的事件置位后拷贝到内核空间，开销还是比较大的 当有事件就绪时不能明确知道是哪个事件，每次都需要遍历 epoll epoll使用一个文件描述符管理多个描述符，将用户关心的事件放到内核中的一个事件表，这样在用户空间和内核空间只需要复制一次且只需要保存一个fd的引用即可，开销小 在内核态中，用户态通过一个fd就可以找到内核态中epoll 有一个监听列表、就绪队列和等待队列 监听列表是红黑树结构的 等待队列保存的是调用epoll_wait的进程 epoll对文件操作符的操作有两种触发模式 LT（水平触发）： 事件就绪后，用户可以选择处理或不处理，如果用户不处理，那么下次调用epoll_wait方法是还会将未处理的事件返回，即不会删除就绪列表中未处理的事件 ET（边缘触发）： 事件就绪后，用户必须处理，因为就绪列表在返回后已经清空了 网络编程Socket 客户端套接字，是两台机器间通信的端点 使用构造方法和服务器创建连接 ServerSocket 服务端套接字 使用构造方法侦听并接收连接服务端套接字的连接 JavaWebTomcat部署方式 把目录拷贝到tomcat目录下的webapps 访问的路径就是项目的名称 可以把项目压缩成war包，拉入webapps就会自动创建项目 在tomcat&#x2F;conf&#x2F;server.xml文件中配置项目 &lt;context path=&quot;虚拟路径&quot; doBase=&quot;实际地址&quot; /&gt; 不安全，一般不使用 在tomcat&#x2F;conf&#x2F;Catalina&#x2F;localhost下新建一个xml文件 &lt;context path=&quot;虚拟路径&quot; doBase=&quot;实际地址&quot; /&gt; 热部署 Servlet执行原理​ 1.当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资 源路径​ 2.查找web.xml文件，是否有对应的​ 3.找到对应的全类名​ 4.tomcat会将字节码文件加载进内存，并为其创建对象​ 5.调用其方法。 生命周期​ 创建时：执行init方法，只执行一次​ 默认情况下，第一次被访问时，servlet被创建，并执行init​ 配置servlet的创建时机：（在xml中配置）​ &lt;load-on-startup&gt;num​ num大于等于0在服务器创建时启动​ num小于0在第一次访问时启动​ 注意：​ init只执行一次，说明Servlet在内存中只有一个对象，即是单例的​ 多个用户同时访问时，可能存在线程安全问题​ 尽量不要在Servlet中定义成员变量，即使定义了，也不要修改值。​ 提供服务：执行service方法，执行多次​ 每次访问Servlet时会执行​ 被销毁：执行destroy方法，执行一次​ 服务正常关闭才会调用，会在销毁之前调用，一般用于释放资源 体系结构​ HttpServlet extends GenericServlet extends Servlet​ GenericServlet:​ 将Servlet的方法做了默认实现，之间Service()做了抽象​ HttpServlet:​ 对http协议的一种封装，简化操作​ 重写doGet和doPost.实际上也是Service方法,只是区别了提交方式 缺点​ 每次创建servlet都需要写xml配置信息​ 解决：​ 在servlet3.0中支持注解配置，不需要配置xml了​ @WebServlet(urlPatterns&#x3D;”资源路径”)​ 可以定义多个资源路径 {“&#x2F;a”,”&#x2F;b”….}","tags":["基础"],"categories":["Java基础"]},{"title":"Spring全家桶","path":"/2024/01/18/Note/后端/Java/基础/Spring全家桶/","content":"Spring5IOC IOC：控制反转，即将对象的创建个调用交给Spring管理 DI：依赖注入 容器主要通过两个接口来实现容器的创建 BeanFactory： spring核心容器，主要是内部使用 使用到对象是才创建，懒加载 提供getBean()方法 ApplicationContext： 继承了BeanFactory，扩展了更多功能国际化、匹配资源、发布事件、环境信息等 加载配置是就创建所有的对象，体验更好但是启动慢 Bean加载方式 XML中 &lt;Bean id&#x3D;”” class&#x3D;”” &#x2F;&gt; @Component、@service、@Controller、@Repository、@Import、@Bean @ComponentScan(“路径”)、@Configuration @ImportResource(“xml名”) @Configuration(proxyBeanMethods &#x3D;) FactoryBean&lt;T&gt; 容器对象.registerBean() 容器对象.registerSingleton(“Bean名”, Bean对象) 不会走bean的创建、依赖注入、初始化过程 实现 ImportSelector、ImportBeanDefinitionRegister、BeanDefinitionRegistryPostProcessor 接口，实现对应的方法 构造注入 加载控制 @Conditional() 根据一些条件决定是否加载Bean 作用域 singleton：单例 prototype：多例 request session application 生命周期 实例化前 实例化后 初始化前 初始化后 使用 销毁 后处理器Bean后处理器 AutowiredAnnotationBeanPostProcessor 解析@Autowired、@Value CommonAnnotationBeanPostProcessor 解析@Resource、@PostConstruct、@PostDestroy ConfigurationPropertiesBindingPostProcessor 解析@ConfigurationProperties AnnotationAwareAspectJAutoProxyCreator 解析AOP相关注解 获取所有切面 通过findEligibleAdvisors(目标类) 找到所有作用于目标类的切面，会将高级切面转化为低级切面 创建代理 通过wrapIfNecessary(目标类对象)，需要判断findEligibleAdvisors()返回的集合是否为空 BeanFactory后处理器 ConfigurationClassPostProcessor 解析@ComponentScan、@Bean、@import、@ImportResource MapperScannerConfigurer 解析@MapperScan internalConfigurationAnnotationProcessor 解析@Configuration、@Bean AOP是什么 AOP是IOC流程中的一个扩展点 作用是在不通过修改源代码的基础上，对其进行功能的添加 体现了装饰器模式 代理对象一般是在初始化之后创建 出现循环依赖时，则会在依赖注入之前创建，并暂存二级缓存中 使用的场景 记录日志、缓存处理、spring内置的事务处理 实现 ajc编译器静态代理 需要添加aspec-maven-plugin 原理是直接将增强方法写进类中，不使用代理，不走IOC Agent类静态代理 需要添加JVM参数 -Javaagent:maven仓库路径/ 原理也是直接将增强方法写进类中，不使用代理，不走IOC JDK动态代理 代理对象有实现接口则使用JDK代理，创建的代理和代理对象一个等级 前16次通过反射调用方法，后续都是直接调用 Cglib动态代理 创建的子类代理对象，所以被代理对象不能是final修饰的 直接调用被代理方法 基于ASM 实现的，动态字节码操作 AspectJ 属于编译时增强，基于字节码操作 切面多的话AspectJ性能更强 使用 创建一个AOP处理类，添加@AspectJ 和 @Component 使用@Pointcut标注一个方法，指定代理的方法 execution 表达式匹配方法名 @Annotation() 表达式匹配注解名 选择对应的通知类型 @Before、@After、@AfterReturning、@Around、@AfterThrowing 切面 @Advice 优先级 @Order(值) 前置通知值小优先，后置通知值大优先 注意 代理对象无法增强静态方法 Jdk代理和代理对象时同级关系，而cglib代理和代理对象时父子关系，所以代理对象不能是final修饰 Jdk代理前16次都是通过反射的方式调用目标方法 cglib代理通过代理方法直接调用目标方法 事务是什么 即要么都成功，要么都失败，不能存在中间状态 事务一般加在Service层 底层使用AOP，通过TransactionInterceptor实现 @Transaction propagation传播属性 isolation隔离级别 rollbackFor noRollbackFor 事务的传播行为 Requirded：A有B就用A的，没有就创建 Required_New：不管A有没有，B创建新的 Supports：A有就用A的，没有就不用 Not_Supports：A有就挂起，B不用事务 Mandatory：A没有就抛异常 Never：A有就抛异常 Nested：A里有，B在A里的事务执行，A里没有就在里面创建 事务失效的场景 异常捕获处理 即catch到异常并处理时，spring就没发现有异常，所以事务失效 需要抛出才能回滚 抛出非运行时异常&#x2F;检查异常 非运行时异常如io读取异常等等，即编译阶段可以发现的异常 在@Transaction标注回滚异常类型为Exception可以解决 非public方法 非代理对象调用被代理对象的方法 在事务方法中直接调用其他事务方法 因为直接调用不是用到代理对象调用，其实是用的this 设置@EnableTransactionManagement(exposeProxy &#x3D; true)，然后使用AopContext.currentProxy()获取代理对象，然后执行方法 多线程下可能出现失效 mysql没开启事务 内置功能Aware BeanNameAware：注入Bean的名字 BeanFactoryAware ：注入BeanFactory容器 ApplicationContextAware： 接口 注入ApplicationContext容器 EmbeddedValueResolverAware：解析 $ { } InitializingBean 容器初始化接口 SpringWebFlux简介 异步非阻塞的框架、响应式编程，功能和SpringMVC类似，基于Netty SpringWebFlux + Reactor + Netty 请求和响应是 ServerReuquest 和 ServerResponse 观察者模式 Oberver（Flow取代） 主要使用Flux 和 Mono Flux 声明多个数据流 可传入数组（fromArray）、集合（fromItertr）、流（fromStream） Mono 声明0个或1个数据流 可以发送信号 错误信号 需要订阅后才能发出数据流 subscribe() 操作符 map 映射 flatMap 将元素映射成流 SpringBoot简介 基于spring的框架，有内置的tomcat，可以独立运行 约定大于配置理念，最大的简化配置 核心功能在于依赖管理和自动配置 依赖管理： spring-boot-dependencies 几乎声明了所有开发中常用依赖的版本号，实现自动版本仲裁 自动配置 启动时自动加载所有的自动配置类 如果不想使用默认的配置，可以直接@Bean替换底层的组件 配置文件密码加密 自定义后置处理器，实现EnvironmentPostProcessor接口 监听器SpringMVC解决乱码问题 配置全局过滤的filter 1234567891011121314&lt;filter&gt;\t&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;\t&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 拦截器（Interceptor） 自定义拦截器 创建拦截器类实现HandlerInterceptor接口 preHandle() 处理前被调用 有返回值，返回false后续的方法都不会执行了 postHandle 处理之后被调用 在DispatcherServlet进行视图渲染之前调用，所以我们可以对ModelAndView对象进行操作 afterCompletion 配置拦截器，xml或者配置类 SpringCLoud注册中心Eureka 支持服务注册和拉取、心跳检测 Eureka采用AP方式 服务提供者启动时会向Eureka注册信息，每30秒发送一次心跳 Eureka为服务消费者提供服务提供者的信息 负载均衡策略 默认是轮询，定时任务30s获取服务提供者信息 Nacos 支持服务注册和拉取、心跳检测 临时实例采用心跳检测，非临时采用主动检测 临时实例不正常会剔除，非临时不会 支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群采用AP模式，集群中存在非临时实例采用CP模式 基于Java语言实现的 服务分级存储模型 服务 - 集群 - 实例 可以进行地域划分集群 负载均衡策略 默认是随机访问 需要在配置文件中配置使用Nacos负载均衡规则 服务调用优先调用本地集群，本地集群不可用时访问其他集群 可以在nacos控制面板中设置实例权重 权重设置为0则不处理请求 实例可以选择临时实例或者非临时实例 本质上也是通过mvc调用接口实现 配置中心Nacos 统一配置管理，实现热更新，常配置开关或者格式 服务拉取Nacos配置 新建一个boostrapt.yml 或者 properties 文件 配置Nacos地址，配置文件后缀名，模块名 使用@NacosValue可以获取配置文件信息 配置自动刷新，优先使用nacos的配置 接口上添加 @RefreshScope 实现自动刷新 也可以创建一个类专门完成属性的加载 类上添加 @ConfigurationProperties(prefix &#x3D; “”)、@Component 对应Nacos配置中的前缀 创建一个变量接收这个配置的信息 环境隔离NameSpace 多环境配置共享 Nacos控制面板中可以创建命名空间，在配置文件中配置namespace，内容是命名空间自动生成的id 多种配置的优先级 服务名称-开发环境.yaml &gt; 服务名称.yaml 中 &gt; 本地配置 命名空间可以按服务来划分，各个服务使用自己的命名空间 可以使用配置多配置文件，将配置信息都放在nacos上 负载均衡Ribbon 请求先到Ribbon，然后Ribbon取注册中心找服务地址 使用时往Spring容器中添加IRule对应的子类即可（全局），也可以在配置文件中配置（部分微服务） 默认是懒加载的，第一次访问时才会创建LoadBalanceClient，请求时间比较长 可以设置饥饿加载，启动时就会创建，可以指定饥饿加载的服务器 规则 RoundRobinRule：轮询 AvailabilityFilteringRule：忽略短路和并发数过高（可以指定上限）的服务器 WeightedResponseTimeRule：服务器响应时间越久，服务器的权重越小 ZoneAvoidanceRule：分区，再对区内轮询 BestAvailableRule：忽略短路的服务器，选择并发数低的服务器 RandomRule：随机 RetryRule：重试机制 LoadBalance远程调用Dubbo简介 服务治理框架 支持多协议 Feign简介 是一个声明式Http客户端 传统的Http远程调用是使用 RestTemplate ，存在一些问题 代码可读性差，编程不统一 参数复杂Url难以维护 自定义Fegin的配置 Fegin运行自定义的配置来覆盖默认配置 配置： fegin.Longger.Level：修改日志等级 NONE：没任何日志 BASIC：一次请求的请求时间，结束时间，耗时时间等基本信息 HEADERS：基本信息 + 请求头信息 FULL：基本信息 + 请求头信息 + 请求体 + 响应体 fegin.codec.Decoder：响应结果的解析器，将Json 转换为 Java对象 fegin.codec.Encoder：请求参数编码 fegin.Contract：支持的注解格式，规定支持的注解，默认是SpringMVC的注解 fegin.Retryer：失败重试机制，默认是不重试 使用 配置文件 加入Spring容器，创建对应的配置类 全局配置：@EnableFeignClient(defaultConfiguration &#x3D; 配置类) 局部配置：@FeignClient(value &#x3D; “作用的服务”, configuration &#x3D; 配置类) 性能优化 底层的客户端，修改为支持连接池的客户端（导包 - 配置） 默认是 URLConnection，不支持连接池 Apache HttpClient：支持连接池 OKHttp：支持连接池 日志级别最好设置为Basic 最佳实践 继承 创建一个接口写这个方法声明，再让Client和Controller去继承和实现 缺点 对SpringMVC不起作用，这个接口的参数列表中的映射不会被继承 服务紧耦合 抽取 将方法声明，使用到的Pojo，默认配置等抽取为一个模块 缺点 会将所有方法引入，多余了一些 OpenFeign网关Gateway 基于WebFlux实现d 拦截所有客户端请求，进行身份认证和权限校验 进行服务路由，负载均衡 请求限流 路由断言工厂 （predicates） 配置写的字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件 spring 提供了11个断言工厂 After、Before、Between、Cookie、Header、Host、Method、Path、Query、RemoteAddr、Weight 过滤器 （filters） 当前路由过滤器 默认过滤器 Default-filter 全局过滤器 GlobalFilter 接口 执行顺序 指定Order来决定执行顺序，值相同时，先执行默认，然后局部，然后全局 安全监控Sentinel 雪崩问题 超时处理：一定时间没响应就返回错误信息 舱壁模式（线程隔离）：限定每个业务能使用的线程数，避免tomcat资源耗尽 熔断降级：断路器统计业务执行的异常比例。超出阈值则熔断该业务，拦截访问该业务的一切请求 流量控制：限制业务访问的QPS，避免服务流量突增发生故障 流量控制雪崩问题隔离 线程池隔离 信号量隔离 降级授权规则 通过过滤器给请求添加一个特殊标识的头信息，携带这个信息的请求才可以正常访问 规则持久化线程隔离 线程池 支持主动超时、支持异步调用 线程开销大 支持低扇出 信号量（默认实现） 轻量级，开销小 无主动超时和异步调用 高频调用、高扇出 熔断降级 断路器 closed：服务正常调用，统计服务异常比例，达到阈值则熔断，进入open状态 open：熔断状态，禁止目标服务调用，熔断持续一段时间后进入half-open状态 half-open：尝试请求服务，如果能正常访问则恢复到closed状态 熔断策略 慢调用：响应时间慢，一点数量的请求慢则熔断，可以设置响应时间阈值 异常比例：在一定请求中抛异常的请求数量超过一定比例则熔断 异常数：异常请求达到设置的异常数则熔断 SpringSecurity简介身份验证权限管理 按照安全规则或者安全策略控制用户只能访问被授权的资源 权限管理包括用户身份认证和授权，简称认证授权 认证：身份认证，就是判断用户是否合法（登录、指纹、人脸等等） 授权：即访问控制，对不同的用户分配不同的权限 解决方案 shiro 轻量、简单、易于集成 但在微服务和扩展能力没有优势 SpringSecurity 易于集成，微服务首选框架 自定义权限管理 大项目、大公司需要，因为可以做到更安全 整体架构 认证器（Authentication） AuthenticationManager主要的实现类为ProviderManager，该实现类中管理了很多AuthenticationProvider实例，用来允许实现多种认证方式 Authentication实现类用来保存认证以及认证成功的信息 SecurityContextHolder用于获取认证信息， 原理是用的ThreadLocal实现与线程绑定 第一次认证时的登录信息会保存到SecurityContextHolder中，使用完后会保存到session中，然后清空SecurityContextHolder 之后再请求时会先查session，如果存在登录信息则放入SecurityContextHolder中，用完再放回session并清空 方便在各个层级使用 授权器（Authorization） AccessDecisionManager：访问决策管理器，用来决定此次访问是否被允许 AccessDecisionVoter：访问决策投票者，会检查用户是否有对应的角色并进行投票 ConfigAttribute：用来保存授权时的角色信息 认证 &amp; 原理 本质上是用的一系列的spring提供的过滤器filter，并不是原生的filter spring提供了DelegatingFilterProxy，将spring的filter转换为原生的filter，使用了代理模式实现 使用了FilterChainProxy，管理了spring的filter，并使其按一定的顺序执行，使用了责任链的设计模式 通过FilterChainProxy嵌入到原生的filter过滤链中，由FilterChainProxy统一管理SecurityFilter 过滤器 由SpringSecurityFilterChain管理了所有需要使用的过滤器 默认会加载这15个filter 自定义认证密码加密Remenber Me会话管理CSRF跨域CROS异常处理授权 &amp; 授权模型OAuth2 &amp; Jwt单点登录注解@Bean 向容器注册组件 只能标注方法 @Bean标注的方法不支持重载，只有参数最多的方法会执行 @Autowired spring提供的，先ByType后ByName，对象必须存在 失效的情况 创建对象后创建BeanFactoryPostProcessor scope失效的情况 单例对象中注入多例对象，多例会失效 可以添加@Lazy解决（原理是代理） 可以在@Scope(value &#x3D; “prototype”, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS) 使用ObjectFactory&lt;多例对象&gt;解决 使用容器对象的getBean方法获取多例对象 @Qualifer 不注入 @Resource 有JDK提供，ByType和ByName，可以指定Name @Value - @Import 向容器中创建组件，默认组件名字是全类名 @Mapper 扫描mapper包，获取其元信息，判断是否是注解 获取Bean定义，传入MapperFactoryBean类作为参数 @Configuration 被标注的类相当于一个工厂类，类中@Bean标注的方法相当于工厂方法 会给标注的类生成代理对象，目的是保证bean的单例特性 默认是单例模式，可设置为多例 @Nullable - @Indexed 在编译时将标注了该注解的Bean，会生成&#x2F;META-INF&#x2F;spring.components文件并加入其中 扫描包时会先查这个文件并加载其中的Bean 没有再走包sao’miao @Order 数字越小的优先级越大 @Lazy 标注类上是延迟创建 标注方法参数或成员变量上， @primary 优先注入该Bean @Conditional 条件装配，有很多子实现 写在方法上有先后执行 设定条件，按条件装配容器 @ImportResource 导入资源（xml） @RequestMapping 映射浏览器的请求 @ResponseBody 将方法返回的内容写给浏览器 @RestController 等于 @ResponseBody 加 @Controller @EnableConfigurationProperties 启用 @ConfigurationProperties 的功能 @ConfigurationProperties 将.property文件中的键值信息和Bean的属性进行绑定 @RequestMapping method 请求方式 method &#x3D; RequestMethod.请求方式 params 指定限制请求参数的条件，支持简单的表达式 页面跳转 直接返回字符串 进行视图跳转 通过ModelAndView对象返回 new一个ModelAndView对象进行返回 @RequestBody 将前端传递过来的Json数据映射到类上 @ResponseBody 将后端返回的数据封装为Json格式返回 @RequestParam 当请求的参数名称与业务方法上形参的名字不一致时，使用该注解命名 value 客户端请求的参数名 required 是否必须包含value值，默认时true，没有则报错 defaultValue 默认值 @PathVariable 在请求映射上添加占位符(请求方式为get) @RequestMapping(“&#x2F;user&#x2F;{username}“); 可以用method 来区分请求方式 形参前加**@PathVariable**(value&#x3D;”username”) username 的值会自动赋值给形参 @RequestHeader 获得请求头信息 value 请求头名字 required 是否必须携带此请求头 @CookieValue 可以获得指定的Cookie的值 @RestController @ResponseBody + @Controller @CrossOrigin 处理Ajax请求的跨域问题 @RequestPart 用于接收MultipartFile等复杂类型的入参 工具类DigestUtils md5加密","tags":["框架"],"categories":["Java框架"]},{"title":"JVM虚拟机","path":"/2024/01/18/Note/后端/Java/基础/JVM/","content":"简介JVM内存模型堆 存放new出来的对象、字符串常量池、静态变量 字符串常量池是在1.7的时候移入堆中，之前都是在方法区中 堆内存由年轻代和老年代组成 栈 主要存放的是线程，每个线程开辟一块内存空间，称为线程栈 最多占用1m内存 线程栈中由多个栈帧组成，栈帧是调用的每个方法 栈帧包括：，局部变量， 操作数栈：方法运行期间数据的操作空间 动态链接：符号引用转变为直接引用 方法出口：记录方法结束时下一句执行的代码的地址 本地方法栈 存放本地方法（native method） 本地方法是底层方法，主要是c和c++语言编写的 方法区 存放类的信息，静态方法信息、类加载器，全局变量，常量 类信息就是常量池就是一张表，里面有类名，方法名，参数类型，字面量等信息 当类被加载时，常量池的信息会放入运行时常量池，里面的符号地址变为真实地址 1.7之前称为永久代，1.8之后称为元空间并开始使用物理（本地）内存，不受JVM管理了 类加载器将类信息加载进元空间，当类加载器加载的所有类不再被引用时，gc会将类加载器、加载的类、元空间的类信息释放 在1.7之前永久代空间不足会触发堆的垃圾回收 程序计数器 存放下一条要运行的代码的地址 便于线程切换 通过寄存器实现，是线程私有的，不会出现内存溢出 字符串常量池 StringTable，1.7之后在堆中，是不能扩容的，底层是一个hash表 编译期优化 123456789String s = &quot;ab&quot; //是加到字符串常量池中的String s1 = &quot;a&quot; ,String s2 = &quot;b&quot; //s1+s2 //相当于 new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() //new出来的是在堆中的 &quot;a&quot; + &quot;b&quot; //如果字符串常量池中有则引用，没有则创建&quot;a&quot; + &quot;b&quot; //javac在编译期间已经确定结果一定为”ab&quot;s1 + s2 //javac在编译期间已经不能确定结果一定为”ab&quot;，因为s1和s2是变量 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制。来避免创建重复的字符串对象 字符串拼接的原理时StringBuilder 字符串常量拼接的原理时编译期优化 可以使用intern方法，将字符串对象放入串池 1.8时，串池有则不放入，没有则放入，会把串池中的对象返回 1.6时，串池有则不放入，没有则把对象赋值一份，放入串池，会把串池中的对象返回 设置StringTable桶的个数减少哈希冲突 -XX:StringTableSize&#x3D;(1009 - ….) 最少是1009个 将字符串对象入池优化 总结 栈、本地方法栈、程序计数器是线程私有的 堆、方法区&#x2F;元空间是线程共享的 Java内存模型 Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行 JMM定义的是线程本地内存和主内存的抽象关系，用于屏蔽各种硬件和操作系统的内存访问差异 可见性：当线程修改了共享变量，其他线程能立即知道改变更 原子性：要么都发生，要么都不发生 有序性：按顺序执行 本地内存是一个抽象的概念，并不真实存在，是一种规范，它包括了缓存，写缓冲区，寄存器、编译器 写缓冲区：可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用 从 java 源代码到最终实际执行的指令序列，会分别经历三种重排序 编译器优化重排序 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序 指令级并行的重排序 如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序 内存系统的重排序 由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行 happens-before 先行发生原则，判断数据是否存在竞争，线程是否安全 次序规则：一个线程内的前一步操作后的结果对后一步来说一定是可见的 锁定规则：同一个锁的unlock操作一定先于lock操作 volatile变量规则：写操作后的数据一定是可以被读到的 传递规则：如果A先行于B，B先行于C，那么A一定先行于C 线程启动规则：Thread对象的start方法先行于线程中的所有操作 线程中断规则：interrupt方法先行于interrupted方法才能检测出线程中断事件 线程终止规则：线程中的所有操作都先行于线程的终止检测 isAlive 对象终结规则：初始化方法的执行一定先行于终止方法finalizefang’fa 类加载子系统类定义 魔数与class文件的版本 常量池 变量的属性、类型和名称 方法的属性、类型和名称 访问标志 类索引、父类索引、接口索引 字段表属性 方法表属性 属性表属性 类加载过程 加载 根据类的全限定名，将类的信息加载进方法区 在堆中生成一个对象指向该类，作为方法区的数据访问入口 如果这个类没有父类，会先加载他的父类 验证 验证类是否符合JVM规范，例如检查class文件的魔数，符号引用验证 准备 为静态变量分配空间，如果静态变量是基本数据类型的话为其设置默认值 解析 将类中的符号引用解析为直接引用 初始化 初始化即调用 ()V 方法，虚拟机会保证这个类的构造方法的线程安全 为静态变量赋值 初始化是懒惰的，使用时才初始化 类在main方法中 类的静态变量或静态方法被访问 子类初始化时父类会在其之前初始化 子类访问父类的静态变量，只会触发父类初始化 new、class.forName 使用 销毁 类加载器 Bootstrap ClassLoader 一级 加载 JAVA_HOME&#x2F;jre&#x2F;lib 下的类，无法直接访问 C语言实现的，所以打印时为null Extension ClassLoader 二级 加载 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下的类，显示为null Application ClassLoader 三级 加载 classpath下的类，线程上下文加载器 自定义类加载器 四级 加载自定义位置的类，通过接口实现，常见于tomcat中 步骤： 继承ClassLoader父类 要遵从双亲委派机制，重写findClass方法 读取类文件的字节码 调用父类的defineClass方法来加载类 使用者调用该自定义类加载器的loadClass方法 双亲委派模式 JDK1.2之后才有该模型 避免类的结构混乱，保护核心类不被篡改，安全 就是调用类加载器的loadClass方法，所经历的过程 检查该类是否已经加载，有加载则返回 没加载找上级，让上级loadClass，上级有加载则返回 没加载再找上级，如果没上级了，则找BootstrapClassLoader，有则返回 每一层都找不到，调用findClass方法（每个类加载器自己扩展）来加载 字节码执行引擎 执行方法区中的字节码文件 修改程序计数器的数据 垃圾收集线程 解释器 将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 将字节码解释为针对所有平台都通用的机器码 JIT即时编译器 将字节码编译为机器码，存入CodeCache中，下次遇到相同的代码，直接执行缓存中的，无需重复解释 根据平台类型，生成平台特定的机器码 垃圾回收简介 gc root 对象不可被回收 GCRoots对象包括：虚拟机运行过程中的核心类对象，虚拟机栈中的局部变量表引用的对象，方法区中类静态属性引用和常量引用对象，本地方法栈中的引用的对象，被加锁的对象，活动线程中引用的对象 引用队列 ReferenceQueue 引用类型 强引用 在堆中创建对象并用一个变量引用为强引用 软引用 SoftReference&lt;&gt;(软引用, 引用队列) 垃圾回收过后内存仍然不足则会回收软引用，前提是没用强引用引用它 当软引用的对象被回收时，软引用会进入引用队列 弱引用 WeakReference&lt;&gt;(软引用, 引用队列)，用于解决内存泄漏问题 垃圾回收过后会回收软引用，前提是没用强引用引用它 当弱引用的对象被回收时，弱引用会进入引用队列 full gc 会清除所有弱引用对象 虚引用 也称幽灵引用，一旦创建就被回收了，所以需要队列cun’chu 当虚引用的对象被回收时，虚引用会进入引用队列 引用队列会定期查看引用队列中是否有虚引用 有虚引用的话会调用虚引用的clean方法调用unsafe.freeMemory()方法释放直接内存 终结器引用 当对象重写了终结方法finalize()并且没用强引用时，它就会被垃圾回收 对象没有强引用时，JVM会创建终结器引用引用该对象，并将终结器引用加入引用队列 finalizeHandler会定期查看引用队列中是否有终结器引用 有终结器引用时会调用引用对象的finalize方法 回收算法 引用计数法（已过时） 当对象没有被强引用所指向时在gc时就进行清除 有A引用B，B引用A无法清除的问题 标记+清除算法 标记是使用可达性分析算法（沿着根对象寻找），三色标记法标记存活对象 记录起始位置和结束位置，新数据直接覆盖旧数据，速度快 空间碎片多不连续 标记+清除+整理算法（老年代） 可以进行整理解决标记清除算法产生碎片的问题， 但移动对象会涉及地址改变，速度慢 复制算法（新生代） 将不回收的数据迁移到另一个相同大小的区域，然后交换这两个区域 效率高，不会产生内存碎片，但会占用双倍的的内存空间，浪费空间 分代回收 新生代 伊甸园 + 幸存区from + 幸存区to 8：1：1 伊甸园满了触发 minor gc minor gc 会暂停所有线程STW 把存活的对象复制到幸存区to，且寿命+1 然后交换幸存区to和幸存区from的位置 当幸存区的对象寿命超过阈值（默认是15），就将其加入老年代 使用的是复制算法 老年代 使用标记清除+整理算法 当老年代内存不足时触发minor gc，如果空间仍不足则触发full gc 触发老年代GC的时机 老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开 老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC 新生代Minor GC后的存活对象大于Survivor，那么就会进入老年代，此时老年代内存不足full gc 就是“-XX:CMSInitiatingOccupancyFaction”参数 如果老年代可用内存大于历次新生代GC后进入老年代的对象平均大小，但是老年代已经使用的内存空间超过了这个参数指定的比例，也会自动触发Full GC。 对象直接进入老年代的情况 大对象直接进入老年代 需要设置-XX:PretenureSizeThreshold，只在Serial和ParNew收集器下有效 单位是字节 对象动态年龄判断 当Survivor区内的对象总大小超过50%（可以设置），那么这些对象中年龄最大的都会直接进入老年代，对象动态年龄判断一般在minor gc后触发 年龄15岁，cms为6岁的会进入老年代 垃圾收集器CMS（Concurrent mark sweep) 注重响应时间，但对cpu压力大 可以并发标记，并发清除，存在并发漏标,不会STW 使用标记清除算法，有内存碎片 三色标记法解决并发漏标，会STW 有并发失败兜底策略（Failback Full GC） 有一些Bug 依然会产生漏标 浮动垃圾上升老年代的Bug G1 jdk1.9默认 注重吞吐量和响应时间 超大堆内存，将堆划分为大小相等的Region 每个区都可以充当（eden、survivor、old、humongous(用于存放大对象)） 单区域是标记+整理算法，区域之间是复制算法 当新生代大小超过阈值时触发新生代回收，使用标记复制法到幸存区（跨区域） 当老年代占堆内存45%是触发并发标记，采用原始快照法解决漏标问题，处理漏标记录依然需要STW 并发标记结束后。开始混合收集，会选择回收价值高的老年代，eden，survivor，可能需要执行多次 并发失败兜底策略（Failback Full GC） 可达性分析 从GC Roots对象为起点开始向下搜索引用的对象，找到的都标记为非垃圾对象，其余没找到的都标记为垃圾对象 GC Roots：线程栈中的本地变量、方法区中的静态变量、本地方法栈的变量等等 不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。 当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，因为如果一个对象在 finalize() 方法中执行缓慢，将很可能会一直阻塞 F-Queue 队列，甚至导致整个内存回收系统崩溃。 在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。 OopMap数据结构存储GCRoot对象，但是随着系统的运行会导致OopMap会逐渐变大，所以也并不会存储所有的GCRoot对象，而是在一个所谓的安全点进行记录GCRoot对象。 实际上，HotSpot的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）——即程序执行时只有在到达安全点时才能暂停。 Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。 对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。 这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension） 抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。 主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。 三色标记法 没处理的对象为白色，孩子对象未处理的为灰色，自己和孩子对象都处理了为黑色 记录标记过程中的变化，主要有两种解决方法 Incremental Update CMS解决方案 只要引用发生改变，被改变引用的对象需要被记录 通过写屏障，黑-&gt;白 时 黑变灰 有BUG 依然会产生漏标，当黑变灰后另一个垃圾回收线程将其又变黑，白漏标 CMS后续解决方案是再从头到尾扫一边，虽然有优化但效率还是低 Snapshot At The Beginning, SATB G1解决方案 （原始快照法） 记录标记过程的新增对象 记录被删除引用关系的对象 灰-&gt;白 断开了，记录白，下次排查，有黑-&gt;白不清除，反之清除 但是判断白是否有引用比较困难，但是G1每个分区头部有记录哪些分区引用了当前分区，Rset（记忆集） 最后在STW时处理这些记录 对象组成​ 对象头（markword）+ 类型指针（classpointer） + 数据（data） + （数组Length） + 对齐区（padding） markword： 32位虚拟机中占4字节，64位占8字节 结构 状态 hashcode: | age: | biased_lock: 0 | 01 普通状态 thread: | epoch: | age: | biased_lock: 1 | 01 偏向状态 ptr_to_lock_record: | 00 轻量级锁 ptr_to_heavyweight_monitor: | 10 重量级锁 垃圾收集器信息 | 11 GC状态 classpointer： 表示这个对象属于哪个类型，正常情况下4个字节，因为经过压缩 当系统内存超过32g将会膨胀到8个字节 data：存放对象数据 如果对象是数组还有一个Length，4字节 padding：如果整个对象不能给8整除，补齐，追求效率 定位 直接指针引用 变量指向堆中对象，对象中的类型指针指向方法区中类型 垃圾回收时变量指向要改变 句柄 变量指向一组指针，这组指针一个指向堆中对象，一个指向方法区中类型 好处是对象小，垃圾回收时不用频繁改动变量指向，改动的是指针组中的指向 创建 使用new关键字 使用Class.newInstance 使用Constructor.newInstance 使用Clone方法 对象必须实现Cloneable接口，重写clone方法，调用父类的clone方法 在Object中这个方法是protected的，重写才能调用 使用反序列化 对象需要实现Serializable接口 动态绑定 JVM 的方法调用指令有五个，分别是： invokestatic：调用静态方法； invokespecial：调用实例构造器构造方法、私有方法和父类方法； invokevirtual：调用虚方法； invokeinterface：调用接口方法，运行时确定具体实现； invokedynamic：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。 其中，invokestatic 和 invokespecial 用于静态绑定，invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法和接口方法。 静态绑定在编译期就已经确定，这是因为静态方法、构造器方法、私有方法和父类方法可以唯一确定。这些方法的符号引用在类加载的解析阶段就会解析成直接引用。因此这些方法也被称为非虚方法，与之相对的便是虚方法。 虚方法的方法调用与方法实现的关联（也就是分派）有两种，一种是在编译期确定，被称为静态分派，比如方法的重载；一种是在运行时确定，被称为动态分派，比如方法的覆盖。对象方法基本上都是虚方法。 这里需要特别说明的是，final 方法由于不能被覆盖，可以唯一确定，因此 Java 语言规范规定 final 方法属于非虚方法，但仍然使用 invokevirtual 指令调用。 静态绑定、动态绑定的概念和虚方法、非虚方法的概念是两个不同的概念。 以 invokevirtual 指令为例，在执行时，大致可以分为以下几步： 先从操作栈中找到对象的实际类型 class 找到 class 中与被调用方法签名相同的方法，如果有访问权限就返回这个方法的直接引用，如果没有访问权限就报错 java.lang.IllegalAccessError 如果第 2 步找不到相符的方法，就去搜索 class 的父类，按照继承关系自下而上依次执行第 2 步的操作； 如果第 3 步找不到相符的方法，就报错 java.lang.AbstractMethodError 可以看到，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。 商用虚拟机为了保证性能，通常会使用虚方法表和接口方法表，而不是每次都去判断。以虚方法表为例，虚方法表在类加载的解析阶段填充完成，其中存储了所有方法的直接引用。也就是说，动态分派在填充虚方法表的时候就已经完成了。 在子类的虚方法表中，如果子类覆盖了父类的某个方法，则这个方法的直接引用指向子类的实现；而子类没有覆盖的那些方法，比如 Object 的方法，直接引用指向父类或 Object 的实现。 直接内存 分配回收成本较高，但读写性能高，不受JVM内存回收管理 NIO中的 ByteBuffer对象.allocateDirect(1024) 可以申请直接内存 这个对象创建时是调用的Unsafe对象的allocateMemory()和setMemory() 方法完成直接内存的分配 当这个ByteBuffer对象被回收时，然后会由ReferenHandler线程通过虚引用类型 Cleaner.clean 方法调用unsafe.freeMemory()方法来回收直接内存 推荐使用unsafe对象手动的管理直接内存 优化逃逸分析 JVM将执行状态分成了5个层次 0层：解释执行 1层：使用c1即时编译器执行，不带profiling 2层：使用c1即时编译器执行，带基本的profiling 3层：使用c1即时编译器执行，带完全的profiling 4层：使用c2即时编译器执行 profiling是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数 对于不常用的代码，采取解释执行，对于热点代码，采取编译执行 方法内联 如果被调用的方法是热点方法，且其内部代码不长时，会进行内联 所谓的内联就是把调用的方法内部的代码拷贝至调用者的位置上，还会进行常量折叠 字段优化 尽量使用局部变量，而不使用成员变量和静态成员变量 反射优化 当通过反射调用方法超过膨胀阈值时，会转换成类调用","tags":["基础"],"categories":["Java基础"]},{"title":"Maven","path":"/2024/01/18/Note/后端/Java/基础/Maven/","content":"命令 命令 参数 作用 mvn clean 清除target mvn compile 编译 mvn test 单元测试 mvn package 打包 mvn install 打包到本地仓库 mvn deploy 打包到远程仓库 关键字dependencyManagement 只是声明依赖，并不引入，子类需要声明引用 scope provided 目标环境已存在，不用打包 properties 版本管理","tags":["基础"],"categories":["Java基础"]},{"title":"JUC并发编程","path":"/2024/01/18/Note/后端/Java/基础/JUC/","content":"简介为什么需要多线程 解决可见性问题：因为CPU和内存间存在缓存，存在主从不一致的情况 解决有序性问题：因为编译程序执行指令时为了提高缓存使用效率，会调整指令的执行次序 解决原子性问题：因为有多线程、多进程、分数复用CPU，导致存在资源共享的问题 线程安全问题 多个线程访问同一个共享变量就会出现线程安全问题 private 和 final可以一定程度上提供线程安全 线程安全的方法组合起来就不能保证线程安全了 在多线程的情况下满足JMM规范就可以避免线程安全问题 线程安全程度 不可变 final、枚举、Number部分子类（Long、Double、BigInteger、BigDecimal）、使用Collections.unmodifiableXXX() 包装的集合 不可变类：DateFormatter、String 绝对线程安全 调用者都不需要任何额外的同步措施 相对线程安全 有一定的安全，但有意外的情况，例如顺序的连续调用 通过一些同步方法来保证安全 线程兼容 对象本身不安全，需要通过一些同步方法来保证安全 线程对立 即使使用了同步方法也无法保证线程安全 临界区 多线程读写同一个共享资源，这个共享资源就称为临界区 竟态条件 多个线程同时在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件 创建线程的方式 继承Thread 代价比较大，不建议 内部实现了Runnable接口 实现Runnable接口 本质上并不是创建线程，实际执行还是需要通过线程调用 实现Callable接口 本质上并不是创建线程，实际执行还是需要通过线程调用 可以有返回值（FutureTask），需要实现call方法 内部是FutureTask实现了RunnableFutrue接口，这个接口继承了Runnable和Future接口 内部实现也是执行的run方法，在方法中创建了Callable对象并执行call方法，将结果值返回 线程池创建 合理利用线程资源，减少频繁创建销毁的开销 内部创建的worker线程也是实现了Runnable接口 守护线程和非守护线程 守护线程就像是守护其他线程一样，其他的完成了他也就结束了 非守护线程都运行结束了，即使守护线程还没结束也会直接结束 main主线程是一个非守护线程 setDaemon(true) 将线程设置为守护线程 垃圾回收器（gc）就是一个守护线程 Tomcat中的 Acceptor 和 Poller 线程也是守护线程 Java的线程和操作系统的线程有区别吗？ java线程分为守护线程和用户线程 在window上线程是一样的，在Unix上采用Pthread实现 jdk1.2之前是jvm自己有一套线程管理机制，即和操作系统上的不一样 jdk1.2之后采用了操作系统原生的内核级线程，将线程的调度交给了操作系统内核 总的来说，java的线程就是操作系统的线程，Java线程与操作系统线程一对一映射，依赖于操作系统的具体实现 方法sleep() Thread提供的方法，不会释放锁 使当前线程进入阻塞状态，可通过interrupt()打断 睡眠结束后线程未必会立刻得到执行，等cpu轮转 wait &#x2F; notify object的方法，必须与synchronized一起使用，会释放锁 在多个线程之间通信需要保证线程间对共享变量的修改是可见的 synchronized就可以保证可见性 实现多线程之间的通信 调用 wait() 方法让当前线程进入waitSet中等待 通过 notify() &#x2F; notifyAll() 唤醒等待中的线程 防止虚假唤醒 &#x3D;&#x3D;yield&#x3D;&#x3D; 调度执行其它同优先级的线程 如果有，当前线程挂起等待相应的线程执行结束 如果没有，则继续运行当前线程 interrupt interrupt()设置打断标记为true 睡眠中的线程被打断不会将标记设置为true isInterrupted() 判断线程是否被打断 不会清除标记 interrupted() 判断线程是否被打断 会清除标记 即设置为false &#x3D;&#x3D;Join&#x3D;&#x3D; 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，直到目标线程结束 Park 让当前线程停下来 如果打断标记为false则停止线程 ，如果打断标记为true则不会停止线程 即只能打断一次 优先级设置 setPriority() 为线程设置新的优先级。默认是5 getPriority() 返回线程的当前优先级 Fork &#x2F; join 体现的是一种分治思想，把递归交给线程做 默认会创建与cpu核心数数量相同的线程池 需要继承RecursiveTask&lt;V&gt;（有返回结果）或RecursiveAction（无返回结果） 覆盖重写compute()方法，实现任务拆分 创建ForkJoinPoll线程池，执行RecursiveTask实现类对象 生命周期 &#x2F; 运行状态cpu层面 创建：create 就绪：Runnable 运行：run 等待：wait 终结：Terminated java层面，在Thread类中有一个枚举类，规定了java线程的六种生命周期 新建 - New 运行 &amp; 就绪 -Runnable 阻塞 - Blocker（Waiting、Time_Wating） 销毁 - Terminated 关键字Synchronized 是Java提供的同步关键字，可以修饰在方法和类上，可以以代码块形式使用 可以通过锁的对象来控制锁的作用范围 锁静态对象或类对象，那么就是一个全局锁 锁普通实例对象，那就是取决于对象的生命周期 锁升级轻量级锁 锁对象虽然是多线程访问的，但是线程间不存在竞争，此时Synchronized会优化为一个轻量级锁 偏向锁 在轻量级锁的情况下，线程每次访问锁对象时都需要进行CAS操作，增加了开销 java6时引入了偏向锁来优化，在cas前会判断线程id和锁对象的对象头中的线程id是否一致，一致直接通过 偏向锁默认是开启的，但是默认也是延迟的，即看不出实际的效果 可以设置 -XX:BiasedLockingStartupDelay=0 来禁用延迟 -XX:-UseBiasedLocking 关闭偏向锁 偏向锁关闭的情况 锁升级 对象调用了hashcode 调用wait&#x2F;notify 当撤销偏向锁的次数超过了阈值，整个类的所有对象都会变为不可偏向 重量级锁（Monitor锁 &#x2F; 管程锁） 结构 WaitSet： EntryList：阻塞队列 Owner：持有的线程 加锁流程 当线程获取重量级锁时，Owner指向当前线程 其他线程获取锁时会会先进行自旋获取锁，失败一定次数后进入EntryList等待 jdk 1.6 后自旋是自适应的，会根据之前线程的平均自旋次数自动调整自旋的次数 线程释放锁后，唤醒EntryList中等待的线程来竞争锁，是非公平的 锁优化锁膨胀 循环的粒度太小导致频繁的加锁释放锁，JIT即时编译器会将锁的粒度变大来优化 自旋优化 重量级锁竞争时会先通过自旋尝试获取锁，没获取到再进入阻塞队列 有一定的次数，也有自适应的自旋 锁粗化 多个细粒度的加锁流程会被优化为一个大粒度的锁，减少频繁的加锁释放锁 锁消除 JIT即时编译器判断锁对象不会被共享时会消除锁 Volatile 可以保证在多线程环境下共享变量的可见性 对于增加了 volatile 关键字修饰的共享变量，JVM会自动增加一个#Lock汇编指令，这个指令会根据CPU 型号自动添加总线锁或缓存锁 通过增加内存屏障防止多个指令之间的重排序 因为CPU引入了 StoreBuffer机制，而这一种优化机制会导致 CPU 的乱序执行，Volatile通过内存屏障来避免CPU重排序 跳过编译器的指令重排序 JUC工具包原子变量 AtomicBoolean、AtomicInteger、AtomicLong 底层使用的Unsafe提供的Cas实现线程安全的计算 AtomicReference、AtomicMarkableReference、AtomicStampedReference、AtomicIntegerArray …FieldUpdater AQS 全称是AbstractQueuedSynchronizer，是一个多线程同步器和阻塞式锁的框架，很多JUC组件的底层都是由它实现的，如Lock、CountDownLatch、Semaphore等 本质上来说，AQS提供两种锁的机制，分别是排他锁和共享锁，用state属性来表示资源的状态 提供了一个volatile修饰的int类型的state 锁记录线程是否持有 Semaphore记录有多少资源 CountDownLatch中作为计数器 提供了基于FIFO的等待队列（双向链表），类似于Monitor的EntryList 提供条件变量ConditionObject来实现等待队列，也是一个双向链表， 唤醒机制，调用了await的线程会在这个队列中等待唤醒 支持多个条件变量。类似于Monitor的WaitSet ReentrantLock 锁的粒度由lock和unlock之间包裹的代码范围决定，作用域则取决于lock实例的生命周期 基于AQS，内部有一个sync抽象静态内部类，它有两个实现类 支持公平锁和非公平锁，默认非公平 NonfairSync 非公平同步器 FailSync 公平同步器 自旋获取锁，会判断在自己之前是否有线程 加入队列执行 addWaiter方法和 acquireQueued方法 可重入、可打断、支持锁超时、多条件变量，支持非竞争获取锁 锁的竞争是使用 CAS 机制来实现的 ReentrantReadWriteLock 基于AQS实现的，将state拆成了两部分 写锁占state的低16位，读锁是state高16位 使用了ThreadLocal解决多线程读时无法判断线程的重入次数 ThreadLocal记录了线程重入次数 读读不加锁，类似数据库意向共享锁 内部分别使用读锁保护数据的read方法，写锁保护write方法 读锁不支持条件变量 持有读锁时去获取写锁，会导致获取写锁永久等待 读写锁用的是同一个Sycn同步器，所以等待队列，state也是同一个 有写锁饥饿问题 当有大量读操作持有锁时会导致写锁等待 新的读操作需要排到写操作之后执行才能避免写锁饥饿 即每个读锁获取锁资源前先判断是否有等待的写锁 ThreadLocal 是一种线程隔离机制，它提供了多线程环境下对于共享变量访问的安全性 ThreadLocal本身不存储数据，像是一个工具类，去操作Thread中的ThreadLocalMap ThreadLocalMap是ThreadLocal的一个内部类 ThreadLocalMap是基于Entry数组实现的 key是ThreadLocal对象本身，value就是要存的数据 真正存数据的地方是Thread中的成员遍历ThreadLocalMap Thread的key是弱引用，在GC时会被清除，因为存在内存泄露的风险 如果想用强引用类型的可以使用ThreadLocal的子类InheritableThreadLocal get时遇到key为null值，会将其value置为null set时遇到key为null值，会替换key-value，还会删除改位置一定范围内的key为null的键值，范围和map中的元素个数有关 推荐使用后用remove删除元素，因为value是会出现内存泄漏的问题的 推荐设置ThreadLocal对象为static final 的，这样Gc就不会删除了，避免了内存泄漏 每个ThreadLocal会对每一个线程创建一个ThreadLocalMap，第一次使用才会创建 key是ThreadLocal实例，value是数据 初始容量是16，扩容2倍，负载因子是2&#x2F;3, 大于等于阈值时扩容 开放寻址法解决hash冲突 插入位置有数据时，接着遍历找没数据的位置后插入 存在ABA问题，可以通过版本号解决 ConcurrentHashMap 本质上还是HashMap，只是做了并发安全的处理 扩容时采用了多线程并发扩容的机制，也是通过创建新的数组然后数据qian’yi 提供的方法是保证线程安全的，但是多个方法同时使用不是线程安全的 结构 1.7：segment段+HashEntry数组+链表 1.8：数组+链表 &#x2F; 红黑树 LongAdder 原子累加器，用一个原子整型模拟锁 用了@Contended解决了伪共享的问题 Condition 相当于wait&#x2F;notify StampedLock jdk8加入的，用于优化读性能，使用读写锁时配合使用 支持乐观读，读取完毕后做一次戳校验，通过则表示这期间没有写操作，数据可以安全使用，如果没通过需要重新读取数据 不支持条件变量、不可重入 Semaphore 信号量，用于限制访问共享资源线程的上限，限流 CountdownLatch 用来进行线程同步协作，内部维护一个计数器，线程完成计算减一 CyclicBarrier 用来进行线程同步协作，内部维护一个计数器，等待线程满足某个计数，即可调用wait进行等待，再等待满足某个计数再继续执行 计数要和线程数一致 CompletableFuture 1.8 引入的一个基于事件驱动的异步回调类 使用异步线程去执行一个任务的时候，在任务结束以后触发一个后续的动作 提供了 5 种不同的方式 thenCombine：把两个任务组合在一起，当两个任务都执行结束后触发事件回调 thenCompose：把两个任务组合在一起，这两个任务串行执行，也就是第一个任务执行完以后自动触发执行第二个任务 thenAccept： 线程池简介 是一种资源复用的思想，目的是减小线程频繁创建和销毁带来的开销，因为线程创建会涉及到cpu的上下文切换，内存分配等工作 仅适合短链接的场景，使用时推荐手动创建ThreadPool对象而不是shi’yong 核心参数 corePoolSize：核心线程数 maximumPoolSize：最大线程数 keepAliveTime：救急线程的空闲时间 unit：时间单位 workQueue：阻塞队列 默认是LinkedBlockingQueue threadFactory：线程工厂 设置线程的信息，起名，设置守护线程、优先级等等 当任务没有核心线程去执行时会加入阻塞队列，队列满了会创建救急线程 handler：拒绝策略 AbortPolicy：抛出异常，默认 CallerRunsPolicy：主线程帮忙处理任务 DiscardOldestPolicy：抛弃等待队列头节点任务，即最早的任务 DiscardPolicy：抛弃当前任务 处理机制 当有新的任务进来时 如果核心线程数没满，即使有空闲的核心线程也会创建新的核心线程来处理任务 如果核心线程满了，就把任务加入等待队列 如果队列满了，创建救急线程处理队列中的任务 如果最大线程数和等待队列都满了，则根据拒绝策略处理任务 种类 newFixedThreadPool 固定的线程池 都是工作线程 newSingleThreadExecutor 单例线程池，只有一个工作线程 顺序消费 newCachedThreadPool 没有工作线程，任务进来后丢进阻塞队列，然后创建救急线程去执行 频繁的创建和销毁线程，性能不好 newScheduleThreadPool 定时任务的线程池 阻塞队列是DelayWorkQueue，底层是堆 newWorkStealingPool 基于ForkJoinPool实现的 每个线程都有一个阻塞队列，当线程对应的阻塞队列为空时，会去访问其他线程的阻塞队列并取出任务执行 会将任务进行拆分，然后并行处理，并将所有返回的结果合并 属性 &#x2F; 状态 crl 原子整形 32位，高三位是线程池的状态，低29位是线程池的数量 状态 111 &#x3D; -1：Running，正常处理任务，刚构建出来时的状态 000 &#x3D; 0：Shutdown，不接收新任务，会处理完所有的任务 shutdownNow方法会直接进入stop状态 001 &#x3D; 1：stop，不接收新任务，所有的任务中断 本质上是执行interrupt方法 010 &#x3D; 2：Tidying，过度阶段 011 &#x3D; 3：Terminated，关闭线程池 可以实现该方法，实现一些关闭前的操作","tags":["基础"],"categories":["Java基础"]},{"title":"JavaSE","path":"/2024/01/18/Note/后端/Java/基础/Java/","content":"简介面向对象语言 封装 将数据和操作封装为一个不可分割的整体 隐藏内部的实现细节，对外暴露安全的访问方法 提高了安全性和复用性，减少耦合 继承 从已有对象中派生出一个类，这个类具有父类的属性和方法 private方法不会被继承 提高了复用性，增加了耦合性 多态 条件：继承，子类对象指针指向父类、满足里氏替换原则 优缺点 优点：提高代码的可扩展性 缺点：无法使用子类特有方法 分为编译时多态和运行时多态 编译时多态：方法的重载 运行时多态：程序中定义的对象引用所指向的具体类型在运行期间才确定 rt.jar、dt.jar、tools.jar rt.jar 代表runtime JAR，包含Core Java API的所有类，包含所有核心Java 运行环境的已编译calss文件 位于JRE的lib目录下，包含了JVM信任的class文件，JVM加载时不会对其他class文件进行严格的安全检查 是一个类似zip的压缩文件，精确称为 Java archive（Jar），存储了Java class文件和程序所需的全部资源。它还可以包含&#x3D;&#x3D;mainfest&#x3D;&#x3D;文件，还可以包含&#x3D;&#x3D;Main-Class条目&#x3D;&#x3D;，变成可执行JAR dt.jar 是系统用来编译一个类的时候用到的，即执行javac的时候用到。 tools.jar dt.jar是关于运行环境的类库，主要是swing包。 Fail-Fast和Fail-Safe Fail-Fast：一旦发现遍历时有修改，则立刻抛异常，例如ArrayList，vector ArrayList内部的modCount记录了修改次数，当遍历时会获取modCount 遍历过程会比较当前modCount和获取时的值，不一致抛异常 Fail-Safe：遍历的同时有修改，会有相应的策略，例如CopyOnWriteArrayList 概念关键字transient 修饰的字段不参与序列化，只能修饰变量 当这个变量可以通过其他变量来获得时就可以不参加序列化，即添加transient修饰 例如：三角形的长，宽，面积，则面积可以不参与序列化 Logger对象也不需要 static 修饰的静态变量是不参与序列化的 volatile 修饰的变量不会被cpu所缓存 finaltry &#x2F; catch &#x2F; finallythrow &#x2F; throws数据类型基本数据类型 数据类型 长度 &#x2F; 字节数 byte int 4字节 long 8字节 float 4字节 double 8字节 decimal 引用数据类型 String 使用双引号创建字符串和使用new创建字符串是不一样的 抽象类 自底向上的抽象，将共性方法抽取出来作为父类 有抽象方法的类是抽象类，但抽象类也可以有其他普通方法 接口 自顶向下，对行为的规范，体现了模板设计思想 1.8之前只能有抽象方法，1.8之后可以有默认方法、静态方法 静态方法只能被接口调用 默认方法，作用是实现接口演化，为老接口扩展新功能，并且其实现类不用重新实现该新方法从，但是所有实现类都会默认携带这个新方法，有一点违背接口隔离原则 只能有static final 修饰的成员变量 方法hashcode() &#x2F; equals() 在集合中存储自定义对象类型最好重写这两个方法 重写hashcode()是为了对象的key在整个hashmap中有更好的分布，提高查询性能 重写equals()是为了防止两个对象的hash值一样，通过比较值来区分 反射 可以在运行期间获取类的各种信息，常用于一些动态修改属性值的操作 如果对象为private等类型，可使用setAccessible(true)暴力获取 注解元注解 @Target：描述注解能够作用的位置 @Retention：描述注解被保留的阶段 @Documented：描述注解是否被抽取到api文档 @Inherited：描述注解是否被子类继承 预定义注解 @Override：检测方法是否覆盖重写父类方法 @Deprecated：标注的内容表示已过时 @suppressWarnings：压制警告 自定义注解 本质上就是一个接口，可定义方法，需要有返回值 创建一个。。。。实现功能 异常 分类 Throwable 包含了线程创建时线程执行堆栈的快照，提供了printStackTrace()等接口用于获取堆栈信息 Error 是程序无法处理的异常，例如虚拟机运行错误、堆栈溢出等等 无法检测的异常 Exception 程序可以捕获且处理的异常 分为运行时异常和编译时异常 运行时异常：RuntimeException类及其子类 编译时异常：需要处理才能编译通过的异常 自定义异常 需要继承RuntimeException 定义错误码和错误消息，还有各种参数的构造函数，包含异常信息，在抛异常的时候传入 异常捕获 使用try&#x2F;catch手动捕获 自己对异常进行处理 直接抛出方法外，让调用方对异常进行处理 使用异常拦截器拦截统一处理（推荐） 底层 底层是通过异常表Exception Table 异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下 from 可能发生异常的起始点 to 可能发生异常的结束点 target 上述from和to之前发生异常后的异常处理者的位置 type 异常处理者处理的异常的类信息 泛型 可以在定义类或方法时不传入特定类型的对象或参数，更具通用性 可以控制类的上限和下限 静态方法和异常中不能使用类的泛型 如果没有指定泛型的类型，默认是Object 枚举 常用于集中管理相同类型的信息，避免硬编码于代码中 代理序列化 就是将对象转换成字节序列，实现持久化和网络传输 方式 实现Serializable接口 实现Externalizable接口 实现writeExternal() 实现readExternal() transient可以防止属性序列化，因为序列化可能会破坏单例 集合ListArrayList 有序，可重复，可null 底层是数组，增加、删除、扩容都是通过数组的复制 可以利用CPU缓存，&#x3D;&#x3D;局部性原理&#x3D;&#x3D; LinkedList 占用内存多，可null 底层是一个双向链表 内部维护了First和last节点，所以对首尾的操作方便 &#x3D;&#x3D;在遍历时会判断从前往后较快还是从后往前较快&#x3D;&#x3D; Vector 线程安全，速度慢，早期使用Elements遍历 Enumeration接口是迭代器前身 CopyOnWriteArrayList 底层实现采用写入时拷贝的思想，增删改会将数组拷贝一份，在拷贝的数据上更改，不影响其他线程的并发读，读写分离 DequeArrayDeque 用作栈或队列 初始容量8，扩容两倍 底层是循环数组，维护了 head 和 tail，非线程安全，不可存null值 QueuePriorityQueue 优先级队列，不可null 能保证每次取出的元素都是队列中权值最小的 底层是小顶堆结构，用数组实现，是按层序遍历树排列 初始容量11，扩容通过数组的复制，最大长度是数组的最大值 BlockingQueue 获取队列元素时队列为空会阻塞等待至队列不为空时，存储元素时队列满了会阻塞至队列直到队列可用 可以很好的实现生产者消费者模型 ArrayBlockingQueue 有界阻塞队列， 基于循环数组实现，需要提前初始化数组 内部维护一把锁，ReentrantLock 和 Condition LinkedBlockingQueue 无界阻塞队列 内部使用了两把锁，分别锁头尾指针，允许两个线程同时执行 保证了头尾节点的线程安全 LinkedQueueConcurrentLinkedQueue 内部维护两把CAS锁，允许两个线程同时执行 SetHashSet 非线程安全，不重复，无序，底层hash表 对HashMap进行了一个封装，内部都是调用的hashmap的方法，适配器模式 key存值，value存的是常量 LinkedHashSet 有序，不重复 底层哈希表 MapHashMap 无序，可null，数组是懒惰创建的 底层 1.7：数组+链表 1.8：数组+链表 or 红黑树 默认16，扩容2倍，数组复制 1.7： 大于等于阈值且插入时的位置不为空时扩容 1.8： 大于阈值就扩容，不改变原链表或红黑树的顺序 put元素时 1.7 插入后超过阈值则扩容 将key和value封装为entry对象 头插法插入到当前节点下链表的头部（扩容死链出现的原因） 1.8 插入前超过阈值或链表长度大于8时则扩容 判断当前位置下是链表还是红黑树 链表：将entry尾插，节点数大于8转换为红黑树 红黑树：将node插入 常见问题 HashMap用红黑树？为什么不用AVL树 用树结构主要是用来避免DoS攻击，防止链表超长时性能下降 红黑树插入删除快，AVL慢，因为AVL旋转次数更多，平衡和调试更难，但AVL读取快，适合读取密集型任务 HashMap红黑树何时会退化？ 当因为扩容时导致树的节点少于6时会退化为链表 当删除树的节点时，主要看root，root.left，root.right，root.left.left 如果删除前以上节点还存在则不会退化为链表，反之退化 HashMap树化阈值为什么为8？ hash值如果足够随机，则在hash表内按泊松分布，在负载因子为0.75的情况下，链表长度超过8的概率为 6*10^-7^ 索引如何计算？ 计算对象的hashCode()，再调用HashMap的hash()方法进行第二次哈希运算，最后 &amp; (容量 - 1) 得到索引 二次哈希值 &#x3D; 原始哈希code ^ 原始哈希code&gt;&gt;&gt;16 注意这里的容量必须是2的n次幂 已经有hashCode方法为什么还要提供hash方法？ 为了使哈希分布更加均匀，减少哈希碰撞 容量为何是2的n次幂？ 在HashMap中进行二次hash时可以用按位与运算代替掉取模运算，从而提升一定的计算性能 容量是2的n次幂存在一个问题，当要存储的元素奇偶分布不均时，哈希分布就不那么均匀了 把容量设置为一个质数可以解决这个问题 设置为质数可以在第一次hash时就能有不错的散列分布 如果想要好的性能则选2的n次幂，想要更好的散列分布则选质数 扩容时如何确定新位置？ 1.8才有的优化 在扩容时会将元素的二次hash值 和 未扩容前的原始容量 进行按位与（**&amp;**）运算 如果结果为0，表示这些元素扩容后位置不会发生改变 如果结果不为0，则表示这些元素将移动到新的位置 新的位置 &#x3D; 原始位置 + 原始容量 会把结果为0的和结果不为0的串成两条链表，批量操作 扩容因子为什么默认是0.75？ 在空间占用和查询时间之间取得较好的平衡 大于这个值，空间节省了，但是链表较长影响性能 小于这个值，冲突减少了，但链表扩容频繁，空间占用多 多线程下hashMap存在什么问题？ jdk7有扩容死链问题 是因为1.7扩容后的链表会以头插法插入 当多个线程同时进行扩容时，一个线程扩容后次序改变了，另一个线程再扩容导致死链 jdk8有数据丢失问题 当多个线程同时往map的同一个位置存放数据时，容易出现覆盖丢失数据 LinkedHashMap 非线程安全，有序，可null 底层是哈希表+双向链表（存储顺序） HashTable 单线程，线程安全，速度慢，不可null 底层是哈希表 初始容量是11，每次扩容是：容量 × 2 + 1，因为容量为质数有较好的hash分布 TreeMap 不能重复，有序，非线程安全 底层红黑树 WeakHashMap key是弱引用，gc时回收 Stream流函数式接口 Comparator&lt;T&gt;： Supplier&lt;T&gt;：返回一个指定类型的数据 Consumer&lt;T&gt;：用于消费数据 Predicate&lt;T&gt;：对数据进行判断 Function&lt;T,R&gt;：将一个类型的数据转换为另一个类型的数据 方法 方法 作用 备注 Stream() 将集合转换为流 Stream.of(数组) 将集合转换为流 reduce() 实现聚合计算，求和 mapToXXX() 映射为对应的类型 orElse() &#x2F; orElseGet() 找不到值则返回给定的值 使用方法时，即使没有值，也会执行 orElse 内的方法 Collect 收集为指定类型的集合 动态代理 为一个类创建一个代理类，这个代理类可以调用类中的方法 SPI机制​ 是Java提供的一种热插拔机制，只要在META-INF目录下定义该类的全路径信息，就可以在Java启动时自动加载对应的类 APIequals() equal是Object 的方法，和他功能相似的是运算符 &#x3D;&#x3D; &#x3D;&#x3D; 比较的是地址，equal比较的是值 &#x3D;&#x3D; 比较快，&#x3D;&#x3D; 是运算符 equal 源码中也是用的 &#x3D;&#x3D; 进行判断，但是引用类型重写了equals方法 重写需要满足 自反性、对称性、传递性、一致性、非空性 类Unsafe Unsafe提供了非常底层的方法，包括操作内存，线程调度、CAS、系统、内存屏障、对象操作、Class 使Java拥有了类似c语言一样的指针，所以不安全 LookSupport中的unpark也是调用的unsafe的方法 Unsafe不能直接调用 通过反射获得 12345Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);theUnsafe.setAccessible(true);Unsafe unsafe = theUnsafe.get(null);Copy Unsafe提供了一个静态方法getUnsafe可以获取Unsafe实例，但是必须使用引导类加载器加载Unsafe类才能使用，因为有CallerSensitive注解标注，为危险方法 命令行中输入：java -Xbootclasspath/a: $&#123;path&#125; // 其中path为调用Unsafe相关方法的类所在jar包路径","tags":["基础"],"categories":["Java基础"]},{"title":"服务发现","path":"/2024/01/18/Note/后端/Java/中间件/服务发现/","content":"Zookeeper数据模型 ZK是一个树形结构 每一个节点都称为ZNode，每个节点保存数据和节点信息 节点可以拥有子节点，也允许少量数据存储 节点分为四大类 Persistent 持久化节点 Ephemeral 临时节点 Persistent_Sequential 持久化顺序节点 Ephemeral _Sequential 持久化临时节点 命令 启动服务 ./zkServer.sh start 查看服务状态 ./zkServer.sh status 停止服务 ./zkServer.sh stop 重启服务 ./zkServer.sh restart 连接zk ./zkCLi.sh -server ip:port 创建节点值 create /节点path value 设置节点值 set /节点path value 获取节点值 get /节点path 删除节点值 delete /节点path 删除有子节点的节点值 deleteall /节点path 创建临时节点 create -e /path value 创建顺序节点 create -s /path value 查询节点详细信息 ls -s /path Curator 建立连接 1234567891011//重试策略RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10);//第一种方式CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;ip地址&quot;, session过期时间, 连接过期时间, 重试策略);//第二种方式，建造者模式CuratorFramework client = CuratorFrameworkFactory.builder().connectString(&quot;ip地址&quot;) .sessionTimeoutMs() .connectionTimeoutMs() .retryPolicy(retryPolicy).namespace(&quot;&quot;).build();//开启连接client.start(); 添加节点 123456public void Create() throws Exception&#123; //创建节点，没传数据的话，则会将当前客户端的ip地址存储 //.withMode(CreateMode.*)设置节点类型，默认是持久化 //.creatingParentsIfNeeded()创建多级节点，路径名/节点名 String path = client.create().forPath(&quot;路径名&quot;, &quot;数据&quot;.getBytes());&#125; 查询节点 123456789public void Get() throws Exception&#123; //查询节点 byte[] data = client.getData().forPath(&quot;路径名&quot;); //查询子节点 List&lt;String&gt; path = client.getChildren().forPath(&quot;路径名&quot;); //查询节点状态，保存在status中 Stat status = new Stat(); client.getData().storingStatIn(status).forPath(&quot;路径名&quot;);&#125; 修改节点 12345public void Set()&#123; //通过status.getVersion()获取version //.withVersion(version) client.setData().forPath(&quot;路径名&quot;, &quot;数据&quot;.getBytes());&#125; 删除节点 123456789101112public void Delete()&#123; //删除节点 client.delete().forPath(&quot;路径名&quot;); //删除带有子节点的节点 client.delete().deletingChildrenIfNeeded().forPath(&quot;路径名&quot;); //保证删除成功 client.delete().guaranteed().forPath(&quot;路径名&quot;); //失败回调 client.delete().guaranteed().inBackground((client, event) -&gt; &#123; //回调逻辑 &#125;).forPath(&quot;路径名&quot;);&#125; 事件监听 Curator引入了Cache实现服务端的事件监听 NodeCache：监听一个节点 123456789101112public void NodeCache()&#123; //创建NodeCache对象 final NodeCache nodeCache = new NodeCache(client, &quot;路径名&quot;); //注册监听 nodeCache.getListenable().addListener(()-&gt;&#123; /*节点发生变化后执行的逻辑*/ //获取节点此时的数据 byte[] data = nodeCache.getCurrentData().getData(); &#125;); //开启监听 nodeCache.start();&#125; PathChildrenCache：监听一个节点的子节点 1234567891011121314public void PathChildrenCache()&#123; //创建PathChildrenCache对象 PathChildrenCache pathChildrenCache = new PathChildrenCache(client, &quot;路径名&quot;, 是否缓存数据); //注册监听 pathChildrenCache.getListenable().addListener((client, event) -&gt; &#123; /*节点发生变化后执行的逻辑*/ //获取节点此时的数据 PathChildrenCache.Type type = event.getType(); //获取类型 if(type.equals(PathChildrenCache.Type.CHILD_UPDATED)) //判断类型是否是Update byte[] data = event.getData.getData(); &#125;); //开启监听 pathChildrenCache.start();&#125; TreeCache：监听所有节点 12345678910public void TreeCache()&#123; //创建TreeCache对象 TreeCache treeCache = new TreeCache(client, &quot;路径名&quot;); //注册监听 treeCache.getListenable().addListener((client, event) -&gt; &#123; /*节点发生变化后执行的逻辑*/ &#125;); //开启监听 treeCache.start();&#125; 分布式锁 核心思想：当客户端需要获取锁时，则创建节点，使用完锁后，删除该节点 客户端获取锁时，在lock节点下创建临时顺序节点 获取lock下所有子节点 若发现自己创建的节点序号最小，那么获取锁，使用完后释放锁并删除节点 若发现自己创建的节点序号不是最小，那么找到那个最小的节点，对其注册监听器，监听其删除事件 监听到最小节点被删除时，再次判断自己的创建的节点是否是序号最小的 是就获取锁，使用完后释放锁并删除节点 不是就重复上面的步骤 12345678910111213141516171819//获取连接RetryPolicy retryPolicy = new ExponentiaBackoffRetry(3000,10);CuratorFramework client = CuratorFrameworkFactory.builder() .connectString(&quot;地址&quot;) .sessionTimeoutMs(&quot;会话超时时间 毫秒&quot;) .connectionTimeoutMs(&quot;连接超时时间 毫秒&quot;) .retryPolicy(retryPolicy) .builder();//开启连接client.start();//创建锁InterProcessMutex lock = new InterProcessMutex(client, &quot;/lock&quot;);//获取锁lock.acquire(超时时间，时间单位);---临界区---//释放锁lock.release(); 集群 Leader选举，获得半数以上选票 Serverid：服务器ID，值越大，选中Leader可能性越大 Zxid：数据ID，值越大，选中Leader可能性越大 配置 在&#x2F;data下创建myid文件，内容是服务器ID 编辑&#x2F;conf下的zoo.cfg文件 123server.服务器ID=服务器ip地址:服务器之间通信端口:服务器之间投票选举端口server.服务器ID=服务器ip地址:服务器之间通信端口:服务器之间投票选举端口server.服务器ID=服务器ip地址:服务器之间通信端口:服务器之间投票选举端口 角色 Leader 领导者 处理事务请求 集群内部各服务器调度者 Follower 追随者 处理非事务请求，转发事务请求给Leader 参与Leader选举投票 Observer 观察者 处理非事务请求，转发事务请求给Leader","tags":["中间件"],"categories":["Java中间件"]},{"title":"消息队列","path":"/2024/01/18/Note/后端/Java/中间件/消息队列/","content":"MQ协议MOM（Message Oriented Middleware 面向消息中间件） PO 面向过程 OO 面向对象 AO 面向切面 JMS（Java Message Service） Java消息服务协议，是一种MOM的设计实现 标准的生产、发送、接收消息 ActiveMQ是该协议的典型实现 STOMP（Streaming Text Orientated Message Protocol） 面向文本流的消息协议，是一种MOM的设计实现 可互操作的连接格式，允许客户端与任意的STOMP消息代理进行交互 ActiveMQ是该协议的典型实现，RabbitMQ可通过插件实现 AMQP（Advanced Message Queuing Protocol） 高级消息队列协议，是一种MOM的设计实现 是一个应用层协议，是一种标准，不受客户端&#x2F;中间件&#x2F;语言的限制 RabbitMQ是该协议的典型实现 MQTT（Message Queuing Telemetry Transport） 消息队列遥测传输，即时通信协议，是一种二进制协议，也是一种MOM的设计实现 用于服务器和低功耗LOT设备间的通信，支持所有平台，可以把所有联网物品和外部连接起来 RabbitMQ可通过插件实现 RocketMQ组件 Producer 消息生产者 Producer Group 一类Producer集合，发送一类消息，发送逻辑一致 Consumer 消息消费者，后台异步消费 Push Consumer 服务端向消费者端推送消息 Pull Consumer 消费者端向服务端定时拉取消息 Consumer Group 一类Consumer集合，消费一类消息，消费逻辑一致 NameServer 组织协调者 收集Broker的工作情况 Broker pic的核心，负责消息的发送，接收，高可用等（是真正干活的） 需要定时发送自身情况到NameServer，10秒发送一次，超过2分钟没发，NameServer会认为该Broker失效 Topic 在Broker中 不同类型的消息以不同的Topic进行区分 MessageQueue 消息队列，用于存储消息 使用创建Topic12345678public static void CreateTopic()&#123; //设置nameserver的地址 producer.setNameservAddr(&quot;ip地址:端口号&quot;); //启动生产者 producer.start(); //创建topic producer.createTopic(&quot;broker名称&quot;, &quot;topic名称&quot;, 队列数量);&#125; 生产者 生产者需要在构造时创建或加入分组 信息需要设置topic、broke名，可以添加tags，队列数量 发送消息 同步：send(message) message需要设置topic、tags、消息内容（字节数组） 异步：send(message, new SendCallback(){ &#x2F;&#x2F;重写两个方法 }) 消费者 订阅topic，设置接收的信息类型（可以根据tags选择） 创建监听器（并发 &#x2F; 顺序） 消息过滤器(需要开启) 消费者接收消息是可以进行筛选 MessageSelector.bySql(“”) 生产者发送信息时可为信息设置一些属性 message.putUserProperty(name, value) 如果需要实现顺序消费消息 生产者需要将信息存入同一个topic中同一个队列 消费者需要按顺序从同一条队列中取消息 监听器选择MessageListenerOrderly 分布式事务消息生产者 使用TransactionMQProducer，设置NamesrvAddr，设置事务监听器（TransactionListener），需要传入事务监听器实现类 实现类需要实现executeLocalTransaction（业务实现）和checkLocalTransaction（回查） 事务回查 在executeLocalTransaction中需要设置各个阶段事务的状态，存储在一个Map集合中，事务id为key 在checkLocalTransaction中，从Map中根据事务id从Map中获取事务状态返回 使用Spring 实现PicLocalTransactionListener 接口 添加@PicTransactionListener(txProducerGroup = &quot;生产者组名&quot;) 保存事务的状态 消息推送消费者推送模式 push模式 服务端有消息就推送给客户端，需要建立长连接，客户端多时消耗资源 pull模式 客户端轮询服务端，有消息就拉取，存在实时性问题 长轮询 使用长轮询解决了push和pull的问题，即长连接+轮询 消息模式 集群（默认） 某个消费者可以接收 广播 每个消费者都可以接收 通过 setMessageModel 设置 重复消息 消费端处理业务保证幂等性 每条消息都有唯一的编号，判断消息是否处理过即可 不保证消息不重复，需要在业务端处理 数据存储 零拷贝（mmap+write） 文件系统采用Linux Ext4 往磁盘写入是顺序写入的，由ConsumeQueue和CommitLog配合 CommitLog 真正存储数据的文件 ConsumeQueue 存储消息在CommitLog 中的位置信息 刷盘 同步刷盘 写入磁盘后再返回成功 异步刷盘 写入内存后就返回成功，内存积累一定信息后批量刷盘 重试策略生产者 设置重试次数 setRetryATimesWhenSendFaild(次数) 在发送消息时指定超时时间 send(message, 超时时间) 并不是所有的异常都会触发重试 消费者 异常失败 每次重试的时间间隔不同，不能修改 重新获取的消息id是不同的，但是内容是相同的 超时失败 RQ服务器会不断重试发送，直到发送成功 集群集群模式 单master 风险最大 多master 全是master 一个机器宕机，未消费的信息不可订阅，实时性受到影响 多master多slave 异步复制 master和slave之间有短暂消息延迟，毫秒级，速度快，磁盘损坏丢失少量信息 同步双写 master和slave同时写，速度慢，消息无延迟，高可用 RabbitMQ组件 channel：操作MQ的工具 exchange：路由消息到队列中 queue：缓存消息 virtualHost：虚拟主机 多租户，相互隔离 创建角色后需要为其分配虚拟主机 类似命名空间 消息模型基本消息队列（BasicQueue）工作消息队列（WorkQueue）发布订阅（Publish、Subscribe） Fanout Exchange：广播 Direct Exchange：路由 Topic Exchange：主题 生产者&#x2F;消费者生产者 创建连接 通过连接工厂（ConnectionFactory） 设置地址、端口、虚拟主机、用户名、密码 建立连接 创建通道 创建队列 发送消息 关闭通道和连接 消费者 创建连接 通过连接工厂（ConnectionFactory） 设置地址、端口、虚拟主机、用户名、密码 建立连接 创建通道 创建队列 防止队列不存在，因为消费者有可能先建立了连接 订阅信息 &#x2F; 消费信息- 回调函数异步处理消息 手动事务消息 提供了一套api实现 会导致Channel阻塞，造成吞吐量下降 生产者确认机制（Publisher Confirm） 新版本扩展 类似的事务消息基本一致 Kafka","tags":["中间件"],"categories":["Java中间件"]},{"title":"OSS","path":"/2024/01/18/Note/后端/Java/中间件/文件服务/","content":"MinIO简介 是一个对象存储服务，存储非结构化存储，GoLang写的 Bucket Object 断点续传 本质上就是分块上传，主要区别在于粒度的划分 minio默认的合并分块时最小得是5m，小于这个值的话会报错 合并分块后一般需要校验是否完整，可以使用 md5 实现 具体流程 前端在上传分块之前先检查该文件在minio上是否存在 传一个待上传文件的md5值，后端在数据库和minio中查询是否存在即可 有可能出现数据库有minio没有，也要上传 开始上传分块，需要先判断分块是否存在 传一个待上传分块的md5值和分块的序号（一般就是分块的文件名），后端在minio中查询是否存在即可 上传分块 使用md5的前两位作为minio上文件的存储目录 使用md5值作为文件名 合并分块","tags":["中间件"],"categories":["Java中间件"]},{"title":"数据库操作","path":"/2024/01/18/Note/后端/Java/中间件/数据库操作/","content":"JDBC获取数据库连接的几种方式 通过第三方api 123456Driver driver = new com.mysql.jdbc.Driver();String url = &quot;jdbc:mysql://localhost:3306/test&quot;;Properties info = new Properties();info.setProperty(&quot;user&quot;,&quot;root&quot;);info.setProperty(&quot;password&quot;,&quot;&quot;);Connection connect =driver.connect(url,info); 通过反射 1234567Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);Driver driver = (Driver) clazz.getConstructor().newInstance();String url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8 &quot;;Properties info = new Properties();info.setProperty(&quot;user&quot;,&quot;root&quot;);info.setProperty(&quot;password&quot;,&quot;&quot;);Connection conn =driver.connect(url,info); 通过DriverManager 1234567891011//获取Driver实现类Class aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);Driver driver = (Driver) aClass.getConstructor().newInstance();//提供连接需要的信息String url = &quot;jdbc:mysql://localhost:3306/test&quot;;String user = &quot;root&quot;;String password = &quot;&quot;;//注册驱动DriverManager.registerDriver(driver);//获取连接Connection conn = DriverManager.getConnection(url,user,password); 加载驱动 123456789//提供连接需要的信息String url = &quot;jdbc:mysql://localhost:3306/test&quot;;String user = &quot;root&quot;;String password = &quot;&quot;;//加载Driver（可以省略，最好不省略）//加载Driver类会执行其内部的静态代码块，会进行注册Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);//获取连接Connection conn = DriverManager.getConnection(url,user,password); 读配置文件 12345678910111213//加载配置文件（获取类加载器加载资源文件）InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;JDBC.properties&quot;);Properties prop = new Properties();//读取配置信息prop.load(is);String user = prop.getProperty(&quot;user&quot;);String password = prop.getProperty(&quot;password&quot;);String url = prop.getProperty(&quot;url&quot;);String driverClass = prop.getProperty(&quot;driverClass&quot;);//获取Driver实现类Class.forName(driverClass);//获取连接Connection conn = DriverManager.getConnection(url, user, password); preparedstatement 预编译sql语句，对应的参数使用占位符表示，可避免sql注入攻击 结合反射和泛型使用更灵活 Blob 用于保存图片 读取时是以流的形式读取的 Batch 用于批量操作，提高效率 事务 用一次连接完成一组sql语句，提高速度 事务的特性即一致性，要么都成功提交，要么都失败回滚 MyBatis简介 底层封装了JDBC JDBC存在的问题 数据库配置信息硬编码 连接对象是要通过http连接数据库，每次都需要创建和释放连接，性能低 SQL、参数、结果集都是硬编码，不灵活 结果集需要手动封装处理，繁琐不灵活 操作 作用 操作符 xml写法 大于 &gt; &amp;gt; 大于等于 &gt;&#x3D; &amp;gt;&#x3D; 小于 &lt; &amp;lt; 小于等于 &lt;&#x3D; &amp;lt;&#x3D; 不等于 !&#x3D; &amp;lt;&amp;gt; 转义 标签if 用于动态拼接SQL语句，底层是使用的OGNL表达式来解析的，可以支持不同数据类型之间的比较 分页​\tMyBatis默认的一对多分页会有一点问题，查询后分页他会以多的那部分计算分页条数，导致查询出来的数据条目对不上 使用resultMap解决 自定义分页插件，比较困难 条件查询中嵌套子查询 单表查询后分页在连接多表 动态SQL条件查询 123456select * from A &lt;where&gt;\t&lt;if test=&quot;&quot;&gt; &lt;/if&gt;&lt;/where&gt; test后可用双引号也可用单引号 动态连接表 12345678&lt;choose&gt;\t&lt;when test=&quot;&quot;&gt; 表 &lt;/when&gt; &lt;otherwise&gt; 表 &lt;/otherwise&gt;&lt;/choose&gt; 遍历集合 12345&lt;where&gt;\t&lt;foreach collection=&quot;集合&quot; open=&quot;开始字符&quot; close=&quot;结束字符&quot; item=&quot;下标名&quot;, separator=&quot;分隔符&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/where&gt; Sql语句抽取 123&lt;sql id=&quot;&quot;&gt;\ttong&#x27;yongSQL&lt;/sql&gt; HandlerTypeHandlers&lt;T&gt; T是想要转换的类型 自定义类型转换器 继承BaseTypeHandler，实现四个方法 setNonNullParameter() 将Java类型转换成数据库需要的类型 getNullableResult() 有三个重载 将数据库中的数据转换成Java类型 PluginsPageHelperPageHelper.startPage(第几页,一页几条数据); 用于分页，与查询解耦 多表操作 使用resultMap封装对象的成员变量 使用association封装对象中的对象 使用collection封装集合数组等 对象可以是一个子查询 可以在mapper上使用注解来编写sql @One：一对一结果集封装 @Many：一对多结果集封装 @Result &#x2F; @Results：封装结果集 MyBatisPlus常用注解TableField 对象中的属性名和字段名不一致 TableField(value &#x3D; “”) 对象中的属性字段在表中不存在 TableField(exist &#x3D; false) 想让对象中的属性不被查询出来 TableField(select &#x3D; false) 自动填充 @TableField(fill = FieldFill.INSERT_UPDATE) TableLogic 逻辑删除 value 表示显示的值，delval表示删除的值 Wrapper QueryWrapper&lt;User&gt; UpdateWrapper&lt;User&gt; 基本操作字符 操作符 作用 wrapper.eq(“字段名”,值) 等于 wrapper.set(“字段名”,值) 设置 wrapper.ne(“字段名”,值) 不等于 wrapper.gt(“字段名”,值) 大于 wrapper.ge(“字段名”,值) 大于等于 wrapper.lt(“字段名”,值) 小于 wrapper.le(“字段名”,值) 小于等于 wrapper.between(值1, 值2) 在值1和值2之间 wrapper.notBetween(值1, 值2) 不在值1和值2之间 wrapper.in(值1, 值2) 值1或值2 wrapper.notIn(值1, 值2) 不是值1或值2 wrapper.alleq(map, 是否处理null值) 全相等 wrapper.like(“字段名”,值) like %值% wrapper.notLike(“字段名”,值) not like %值% wrapper.likeLeft(“字段名”,值) %值 —&gt; 以这个值结尾 wrapper.likeLeft(“字段名”,值) 值% —&gt; 以这个值开头 wrapper.orderBy(“字段名”) 升序排序 wrapper.orderByAsc(“字段名”) 升序排序 wrapper.orderByDesc(“字段名”) 降序排序 wrapper.or() or wrapper.and() and wrapper.select(“字段名1”,”字段名2”) 指定输出的字段 可以在参数中写连接条件，返回值是boolean Wrappers 可替代wrapper对象使用 填充器 实现MetaObjectHandler接口，实现insertFill和updateFill方法 需要在实体类上添加@TableField并指定fill的策略 Druid简介 是一个JDBC组件，包含三个部分 DruidDriver：代理Driver，能够提供基于Filter－Chain模式的插件体系 DruidDataSource ：高效可管理的数据库连接池 SQLParser ： 用途 监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助 高效、功能强大、可扩展性好 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback SQL执行日志，Druid提供了不同的 LogFilter，能够支持 Common-Logging、Log4j 和 JdkLog 可以通过Druid提供的Filter-Chain机制，很方便编写JDBC层的扩展插件 使用步骤 导入依赖 单数据源配置配置 12345678910111213spring: application: name: druidDemo datasource: url: jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8 driver-class-name: com.mysql.jdbc.Driver username: xxx # 数据库账号 password: xxx@ # 数据库密码 type: com.alibaba.druid.pool.DruidDataSource # 设置类型为 DruidDataSource # Druid 自定义配置，对应 DruidDataSource 中的 setting 方法的属性 druid: # 设置 Druid 连接池的自定义配置。然后 DruidDataSourceAutoConfigure 会自动化配置 Druid 连接池。 min-idle: 0 # 池中维护的最小空闲连接数，默认为 0 个。 max-active: 20 # 池中最大连接数，包括闲置和使用中的连接，默认为 8 个。 多数据源配置 123456789101112131415161718192021spring: application: name: druidDemo datasource: mall: url: jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8 driver-class-name: com.mysql.cj.jdbc.Driver username: root # 数据库账号 password: root0319@ # 数据库密码 type: com.alibaba.druid.pool.DruidDataSource # 设置类型为 DruidDataSource min-idle: 0 # 池中维护的最小空闲连接数，默认为 0 个。 max-active: 20 # 池中最大连接数，包括闲置和使用中的连接，默认为 8 个。 # 用户数据源配置 users: url: jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8 driver-class-name: com.mysql.cj.jdbc.Driver username: root # 数据库账号 password: root0319@ # 数据库密码 type: com.alibaba.druid.pool.DruidDataSource # 设置类型为 DruidDataSource min-idle: 0 # 池中维护的最小空闲连接数，默认为 0 个。 max-active: 20 # 池中最大连接数，包括闲置和使用中的连接，默认为 8 个。 配置监控台 12345678910druid: # 设置 Druid 连接池的自定义配置。然后 DruidDataSourceAutoConfigure 会自动化配置 Druid 连接池。\tfilter: stat: # 配置 StatFilter log-slow-sql: true # 开启慢查询记录 slow-sql-millis: 5000 # 慢 SQL 的标准，单位：毫秒 merge-sql: true # SQL合并配置\tstat-view-servlet: # 配置 StatViewServlet enabled: true # 是否开启 StatViewServlet login-username: root # 账号 login-password: root # 密码 stat文档：https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter stat-view-servlet文档：https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE Druid监控台：http://127.0.0.1:8082/druid/sql.html 使用 123456789101112public static Connection getConnection()&#123; try &#123; InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;Druid.Properties&quot;); Properties prop = new Properties(); prop.load(is); DataSource source = DruidDataSourceFactory.createDataSource(prop); return source.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; HikariMyCat分库分表垂直分库水平分库分库规则 范围分片 取模分片 一致性hash 针对主键不是纯数字类型 枚举 应用指定 固定分片hashid值取二进制低10为 &amp; 1111111111 字符串hash解析 截取子字符串进行hash计算 &amp; 1023 按天分片 按自然月分片 管理界面 登录9066的管理端口 安装Mycat-eye 需要安装zookeeper 主从分离一主一从双主双从","tags":["中间件"],"categories":["Java中间件"]},{"title":"容器化","path":"/2024/01/18/Note/后端/Java/中间件/容器化/","content":"Docker简介 不同环境的操作系统不同，Docker如何解决的 将用户程序（配置、依赖）和需要用到的系统函数库一起打包（镜像），只要内核相同都可以运行 互相隔离，沙箱机制 与虚拟机的差别 docker是容器虚拟化，虚拟的是操作系统，虚拟机虚拟的是硬件 虚拟机可以运行不同的操作系统，容器只能运行同一类型的操作系统 docker性能更好，硬盘占用小，秒级启动速度，支持上千个容器 镜像 docker将用户程序（环境、配置、依赖）和需要用到的系统函数库一起打包为一个镜像 容器 运行镜像形成的进程就是容器，docker会给容器做隔离，对外不可见 DockerHub hub.docker.com 架构 CS架构 服务端：Docker守护线程（Docker Daemon），负责处理Docker命令，管理镜像、容器 客户端：向Docker发送命令 常用命令 效果 指令 可选参数 参数说明 启动docker systemctl start docker 拉取镜像 docker pull 查看镜像 docker images 推送&#x2F;发布 镜像 docker push 压缩镜像 docker save -o 压缩包名称 解压缩镜像 docker load 重命名镜像 docker tag 原名 新名 查看运行中的容器 docker ps -a 查看所有 删除容器 docker rm id r m i-f 删除镜像强制删除 创建容器 docker run {相关参数} 镜像名 -v–name-p-d-e 挂载数据卷 数据卷名:容器内路径容器名称端口映射 宿主机 : 容器后台运行环境变量 进入容器 docker exec{容器名} -it bash 允许与容器交互（输入&#x2F;出）终端交互命令 查看容器日志 docker logs -f 实时打印日志 查看容器内部配置信息 docker inspect 关闭&#x2F;开启&#x2F;重启容器 docker stop&#x2F;start&#x2F;restart 将DockerFile构建为镜像 docker build -t . 名字:版本构建dockerfile所在的目录 数据卷相关命令 docker volume createinspectlsprunerm 创建一个数据卷显示一个或多个数据卷的信息列出所有的volume删除未使用的数据卷删除指定的数据卷 部署集群 docker-compose up -d 后台运行 容器自动启动 docker update 容器名 –restart&#x3D;always 常用操作 容器转镜像 docker commit 容器id 镜像名称:版本号 docker save -o 压缩文件名称 镜像名称:版本号 docker load -i 压缩文件名称 查看最新的几条日志 docker logs -f -t --tail 条数 模块名 数据卷 是一个虚拟目录，指向宿主机文件系统中的目录（&#x2F;var &#x2F;lib &#x2F;docker &#x2F;volumes &#x2F; ） 分目录挂载和文件挂载 目录挂载：由docker管理，目录路径较长 文件挂载：手动创建，目录清晰，但需要自己管理 安装 卸载旧版本 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装所需软件包 123sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 配置阿里云源 123sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装 1sudo yum install docker-ce docker-ce-cli containerd.io 设置开机自启 1sudo systemctl enable docker 容器加速服务 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://a3fp19zs.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker DockerFile结构 基础镜像层(BaseImage) 包含系统的函数库、环境变量、文件系统 入口(EntryPoint) 镜像中应用程序启动的命令 层(Layer) 在基础镜像层基础上添加安装包、依赖、配置等，每次操作形成一层 指令 关键字 作用 备注 from 指定父镜像 说明是基于哪个image构建的 run 执行一段命令 entrypoint 镜像启动命令 入口 copy 复制文件 复制文件到image中 expose 指定容器运行时端口 env 设置环境变量 指定环境变量 步骤 创建一个空的文件夹 导入jar包，程序jar包，DockerFile DockerFile内容 12345678#指定基础镜像FROM java:8-alpine#复制jarCOPY ./jar路径 目标路径/xxx.jar#暴露端口EXPOSE 8081#入口 Java项目的启动命令ENTRYPOINT java -jar 目标路径/xxx.jar 虚悬镜像 仓库名、标签都是&lt;none&gt;的镜像 构建或者删除镜像时出现的错误 使用 docker image prune 删除 Docker Compose简介 通过compose文件快速部署分布式应用 安装123456#下载curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-&#x27;uname -s&#x27;-&#x27;uname -m&#x27; -o /usr/local/bin/docker-compose#设置权限chmod +x /usr/local/bin/docker-compose#查看版本信息docker-compose -version 部署Nginx+SpringBoot项目123#创建目录并进入mkdir ~/docker-composecd ~/docker-compose 123456789101112131415#编写文件 docker-compose.ymlversion: &#x27;&#x27;services:\tnginx: image: nginx ports: - 80:80 links: - qpp volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - &quot;8080&quot; 12#创建/nginx/conf.d 目录mkdir -p ./nginx/conf.d 123456789#创建并编写xxx.confserver&#123;\tlisten 80;\taccess_log off;\tlocation / &#123; proxy_pass http://app:8080;\t&#125;&#125; 123#在~/docker-compose目录下启动容器docker-compose up#测试 部署微服务集群 编写各个微服务的dockerfile，并且和微服务的jar包放在同一级目录下 mysql需要打包配置和数据 编写docker-compose.yml文件 修改各个微服务内服务调用时的ip，用服务名替代 将docker-compose和所有微服务的dockerfile和jar打包到服务器上 私有仓库搭建 使用docker-compose部署具有图形化界面的DockerRegistry 123456789101112131415version: &#x27;3.0&#x27;services:\tregistry: image: registry volumes: - ./registry-data:/var/lib/registry\tui: image: joxit/docker-registry-ui:static port: - 8080:80 environment: - REGISTRY_TITLE= - REGISTRY_URL=http://registry:5000 depends_on: - registry 配置Docker信任地址，私服一般是http协议，docker默认不信任 12345678#打开要修改的文件vi /etc/docker/daemon.json#添加内容&quot;insecure-registries&quot;:[&quot;http:...&quot;]#重加载systemctl daemon-reload#重启dockersystemctl restart docker 使用 推送镜像需要先tag（重命名镜像） Docker Net简介 docker启动时会在宿主机上创建一个网络配置 用于在不同docker之间的网络通信以及端口映射 一共有四种网络模式 bridge：为每个容器分配、设置ip，并连接到docker0 （默认） host：使用宿主机的ip和端口 none：容器有独立的网络空间，但没有设置，需要自定义 container：共享某个容器的ip bridge模式下 容器被删除其ip会被回收 命令docker network 效果 指令 可选参数 参数说明 connect create disconnect inspect 查看网络列表 ls 删除无用网络 prune 删除网络 rm 问题桌面端打不开 netsh winsock reset 整合Redis 拉取 1docker pull redis 启动 12345docker run -p 6379:6379 --name redis\\\t-v /mydata/redis/data:/data\\ #数据文件挂载\t-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf\\ #配置文件挂载\t-d redis redis-server /etc/redis/redis.conf #后台运行\t--appendonly yes #开启aof持久化 进入容器 1docker exec -it redis redis-cli Nginx docker run --name nginx -p 80:80 -v html:/usr/share/nginx/html -d nginx 容器内路径可以在dockerhub上查看 123456789101112131415161718#拉取镜像#创建挂载目录# 生成容器docker run --name nginx -p 9001:80 -d nginx# 将容器nginx.conf文件复制到宿主机docker cp nginx:/etc/nginx/nginx.conf 本地位置/conf//nginx.conf# 将容器conf.d文件夹下内容复制到宿主机docker cp nginx:/etc/nginx/conf.d 本地位置/conf/conf.d# 将容器中的html文件夹复制到宿主机docker cp nginx:/usr/share/nginx/html 本地位置/html# 关闭该容器docker stop nginx# 删除该容器docker rm nginxdocker run -p 80:80 --name nginx -v C:\\Soft\\Docker\\config ginx ginx.conf:/etc/nginx/nginx.conf -v C:\\Soft\\Docker\\config ginx\\conf.d:/etc/nginx/conf.d -v C:\\Soft\\Docker\\log ginx:/var/log/nginx -v C:\\Soft\\Docker\\html ginx:/usr/share/nginx/html -d nginx:stable-alpine3.17-slim MySQL 拉取 1docker pull mysql 启动 123456docker run -p 3306:3306 --name mysql\\\t-v /mydata/mysql/log:/var/log/mysql\\\t-v /mydata/mysql/data:/var/lib/mysql\\ #数据文件挂载\t-v /mydata/mysql/conf:/etc/mysql/conf.d/hmy.cnf #配置文件挂载\t-e MYSQL_ROOT_PASSWORD=123456\\\t-d mysql #后台运行 挂载是文件夹需要存在 进入容器 1docker exec -it mysql bash Camunda 拉取 1docker pull camubda 启动 1234567docker run -d --name camunda -p 8000:8000 \\ -e DB_DRIVER=com.mysql.cj.jdbc.Driver \\ -e DB_URL=jdbc:mysql://服务器IP:3306/camunda \\ -e DB_USERNAME=root \\ -e DB_PASSWORD=123456 \\ -e WAIT_FOR=服务器IP:3306 \\ camunda镜像名 创建camunda数据库 RabbitMQElasticSearch123456789101112131415161718192021#拉取ElasticSearchdocker pull elasticsearch#拉取kibanaocker pull kibana#挂载数据卷和配置mkdir -p 本地位置/configmkdir -p 本地位置/pluginsmkdir -p 本地位置/dataecho &quot;http.host:0.0.0.0&quot; &gt;&gt; 本地位置/config/elasticsearch.yml#启动容器docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; -v 本地位置/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\t-v 本地位置/data:/usr/share/elasticsearch/data\t-v 本地位置/plugins:/usr/share/elasticsearch/plugins\t-d elasticsearch\tdocker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; -v C:\\Soft\\Docker\\config\\es\\elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v C:\\Soft\\Docker\\volume\\es:/usr/share/elasticsearch/data -v C:\\Soft\\Docker\\plugins\\es:/usr/share/elasticsearch/plugins -d elasticsearch:7.17.7 -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;\t#防止es占满全部内存 Kibana1234567#拉取docker pull kibana#运行容器docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.11.94:9200 -p 5601:5601 -d kibana:7.17.7docker stop kibanadocker rm kibana Oracle1docker run -d --restart always -p 1524:1521 -p 5502:5500 -e ORACLE_SID=ORCLCDB -e ORACLE_PDB=ORCLPDB1 -e ORACLE_PWD=123456 -e ORACLE_EDITION=standard -e ORACLE_CHARACTERSET=AL32UTF8 -v C:\\Soft\\Docker\\volume\\oracle:/opt/oracle/oradata --name orcl19c_03 doctorkirk/oracle-19c Jenkins简介 持续部署 需要有Maven环境、Java环境、Docker环境、Git环境 可在Jenkin中安装插件 Maven插件 Publish Over SSH 插件 在DashBoard -&gt; Manage Jenkins下 Configure System中添加远程服务器 然后在Post Steps和Pre Steps中可以使用 用于杀死原Java进程 后台运行Java进程 Kubernetes简介 为了容器编排的问题，即容灾和扩展 本质是一组服务器集群，实现资源管理自动化 特点 服务发现和负载均衡：可以使用DNS名称或IP地址公开容器，k8s可以负载均衡并分配网络流量，从而使部署稳定 存储编排：允许自动挂载选择的存储系统 自动部署和版本回退：一次性将所有相关的服务进行版本升级或者回退 自动装箱计算：允许指定容器所需的CPU和内存 自我修复：重新启动失败的容器，替换容器，杀死不响应运行状况检查的容器 密钥与配置管理：存储敏感信息 组成部分 控制节点（master）（硅谷总部） ApiServer（秘书部）：资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制 所有的组件交互都通过ApiServer Scheduler（调度者）：负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上 ControllerManager（决策者）：负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等 Etcd（资料库）：负责存储集群中各种资源对象的信息 工作节点（node）（东西南北厂） Kubelet（厂长）：负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器 按一定频率访问ApiServer，获取最新的决策信息 监控改节点所有的服务的状态 服务出问题也会通知ApiServer KubeProxy（门卫）：负责提供集群内部的服务发现和负载均衡 负责所有项目的访问，所有的网络访问都是通过KubeProxy访问的 记录了所有服务的位置 KubeProxy之间是相互同步的 Docker：负责节点上容器的各种操作作 环境搭建 安装Docker 设置环境信息 123456789101112131415161718192021#设置主机名（节点间主机名不可重复）hostnamectl set-hostname xxx#将 SELinux 设置为 permissive 模式（相当于将其禁用）sudo setenforce 0sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config#关闭swap分区swapoff -ased -ri&#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab#允许 iptables 检查桥接流量cat &lt;&lt;EOF sudo tee /etc/modules-load.d/k8s .confbr netfilterEOFcat &lt;&lt;EOF sudo tee /etc/sysct1.d/k8s .confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsudo sysctl --system 安装Kubelet、Kubectl、kubeadm 1234567891011121314cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\thttp://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kubelet kubeadm kubectlEOFsudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetessudo systemctl enable --now kubelet 安装镜像 1234567891011121314151617181920sudo tee ./images,sh &lt;&lt;-&#x27;EOF&#x27;#!/bin/bashimages=(kube-apiserver:v1.20.9kube-proxy:v1.20.9kube-controller-manager:v1.20.9kube-scheduler:v1.20.9coredns:1.7.0etcd:3.4.13-0pause:3.2)for imageName in $&#123;images[@]&#125; ; dodocker pull registry.cn-hangzhou.aliyuncs,com/lfy_k8s_images/$imageNamedoneEOFchmod +x ./images .sh &amp;&amp; ./images .sh#所有机器添加master域名映射，以下需要修改为自己的echo &quot;master节点ip地址 cluster-endpoint” &gt;&gt; /etc/hosts 初始化主节点（master节点） 123456789#主节点初始化kubeadm init--apiserver-advertise-address=master节点ip地址 \\--control-plane-endpoint=cluster-endpoint \\--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \\--kubernetes-version v1.20.9 \\--service-cidr=10.96.0.0/16 \\--pod-network-cidr=192.168.0.0/16#所有网络范围不重叠 1234#第5步完成安装后会提示这个，以第5步提示的为准mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf HOME/.kube/configsudo chown s(id -u):$(id -g) SHOME/.kube/config 主节点部署网络插件 12curl https://docs.projectcalico.org/v3.20/manifests/calico.yaml -Okubectl apply -f calico.yaml 设置为工作节点 1234#第5步完成安装后会提示这个，以第5步提示的为准kubeadm join cluster-endpoint:6443 --token x5g4uy.wpjjdbgra92s25pp 、--discovery-token-ca-cert-hashsha256:6255797916eaee52bf9dda9429db616fcd828436708345a308f4b917d3457a22 使用 kubeadm kubernete init 初始化为master节点 kubernete join 其他节点作为工作节点 命令 命令 功能 kubectl get nodes 查看集群所有节点 kubectl apply -f xxxx.yaml 根据配置文件，给集群创建资源 docker ps | &#x3D;&#x3D;&#x3D; kubectl get pods -A 查看集群部署了哪些应用 kubectl get pods -A 运行中的应用在docker里面叫容器，在k8s里面叫Pod","tags":["中间件"],"categories":["Java中间件"]},{"title":"工作流","path":"/2024/01/18/Note/后端/Java/中间件/工作流/","content":"Activiti7简介 做审批和流程 是一个引擎 传统的实现方式是通过状态字段来实现的 缺点是一旦流程节点增加或减少都要修改代码，很麻烦 链路追踪也麻烦，需要保存历史数据 Activiti 其实就是封装了上面的操作，用工具来制定流程图规则 Activiti会将流程图转换成xml文件，然后再解析xml，将对应的记录插入数据库 一个流程图中的所有阶段都会存在一张表里 一条记录代表一个节点 每处理完一个节点就删除上一个节点 Camunda简介 源自Activiti5 支持组件模式和云原生 高性能（乐观锁、缓存）、高扩展、高稳定、独有的外部任务模式、支持多租户、完善的Api 使用方式嵌入用法 与业务深度整合，生命周期和业务一致 不用单独部署和维护 不方便扩容 组件式用法 不常用 中间件用法 部署为平台模式，支持多项目公用，与业务完全解耦 方便扩容 存在单点风险，远程调用存在一定的性能损耗 云原生用法（camunda8）","tags":["中间件"],"categories":["Java中间件"]},{"title":"网络传输","path":"/2024/01/18/Note/后端/Java/中间件/Web中间件/","content":"Netty简介 在NIO上做了很多优化 零拷贝 高性能无锁队列 内存池 支持多种通信协议 http websocket 解决拆包粘包的问题，内置了拆包策略 是一个异步的，基于事件驱动的网络应用框架，即使用了IO多路复用的技术 基于NIO，在NIO上做了很多优化 零拷贝 高性能无锁队列 内存池 解决拆包粘包的问题，内置了拆包策略 解决epoll空轮询CPU 100%问题 提供了易用的Api 支持多种通信协议 http websocket WebSocket简介 基于TCP的全双工通信，双向传输 SpringBoot整合WebSocket 发送消息 session.sendMessage(TextMessage对象) WebSocket拦截器 可以在建立连接之前写一些业务逻辑 12345678910111213public class MyHandshakeInterceptor implements HandshakeInterceptor&#123; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpReponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception&#123; //将用户id放入socket处理器的会话中 attributes.put(&quot;uid&quot;, 1001); return true; &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpReponse response, WebSocketHandler wsHandler, Exception exception)&#123; //握手成功后的逻辑 &#125;&#125; 编写WebSocketConfig，添加拦截器后才能生效 12345678910public class WebSocketConfig implements WebSocketConfigurer&#123; @Autowired private MyHandshakeInterceptor myHandshakeInterceptor; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry)&#123; registry.addHandler() .addInterceptors(myHandshakeInterceptor); &#125;&#125; 分布式WebSocket 生产者 当发现发送信息的对象toid为空或者不在线时，可能在其他节点中 通过rocketMQ去查询其他socket服务端是否存在该客户端的session 注入Rocket’MQTemplate，使用convertAndSend(topic:tags, 序列化的message)发送到MQ消息系统 消费者 需要实现RocketMQListener接口 添加@RocketMqMessageListener(topic &#x3D; “topic”, selectorExpression &#x3D; “tag”, messageModel &#x3D; , consumerGroup &#x3D; “”) 重写 onMessage(String msg) Nginx反向代理定义 正向代理 客户端挂了VPN访问外网 反向代理 服务器挂了VPN传输数据给客户端 这个VPN就是Nginx 负载均衡 策略 轮询（默认） 每个请求按时间顺序分配到不同的服务器，如果服务器down会自动剔除 weight（权重） 默认是1，权重越高被分配的客户端越多 一般按服务器性能分配 ip_hash 每个请求按照访问ip的hash结果进行分配，使每个访客固定访问一个服务器， 可以解决session的问题 fair 按后端的响应时间来分配，响应时间短的优先分配 动静分离 就是把静态资源放置在一个独立的服务器上，不用每次都从jar包中加载，提高效率 实现方式方式一 把静态资源文件独立成单独的域名，放在独立的服务器上 方式二 把动态和静态资源一起发布，通过nginx分离 配置文件全局块（开头到events之间） worker_processes 并发处理的数量 events块 主要影响服务器与用户的网络连接 worker_connections 最大的连接数 http块 代理、缓存、日志等大多数功能和第三方模块都在这配置 包含两大块 http全局块 文件引入、定义、连接超时时间，连接请求数上限 server块 和虚拟主机有关 包含两大块 全局server块 端口、主机名 location块 地址 常用命令 需要进入到 ..&#x2F;nginx&#x2F;sbin&#x2F; 下执行 service start nginx 启动nginx .&#x2F;nginx -s stop 关闭nginx .&#x2F;nginx -s quit 安全退出 .&#x2F;nginx -s reload 重新加载nginx配置文件 Nginx常见问题 Nginx为什么快 采用了异步非阻塞模式，使用了epoll模型以及队列 Nginx的优缺点 优点：占用内存小，响应快，支持高并发，配置简单，不会暴露服务器ip地址 缺点：处理动态页面鸡肋 Nginx使用的场景 静态服务器，虚拟主机，反向代理，动静分离，负载均衡，限流 限流的方式 正常流量限制访问频率 突发流量限制访问频率 限制并发连接数 漏桶流和令牌桶 漏桶流 突发流量转变为平稳的流量，大口进，小口出 令牌桶 有一个大小固定的令牌桶，以固定的速度生成令牌并放入令牌桶中，拿到令牌的请求才可以执行对应的业务逻辑","tags":["中间件"],"categories":["Java中间件"]},{"path":"/2024/01/18/Note/后端/Java/中间件/定时任务/","content":"@Scheduled步骤 在类上添加@EnableScheduling启用调度注解 在需要执行定时任务的方法上添加@Scheduled cron表达式 123456789┌───────────── second (0-59)│ ┌───────────── minute (0 - 59)│ │ ┌───────────── hour (0 - 23)│ │ │ ┌───────────── day of the month (1 - 31)│ │ │ │ ┌───────────── month (1 - 12) (or JAN-DEC)│ │ │ │ │ ┌───────────── day of the week (0 - 7) (0 or 7 │ │ │ │ │ ││ │ │ │ │ │* * * * * * zone：时区 timeUnit：时间单位 fixedDelay：固定间隔 fixedRate：固定速率 initialDelay：第一次延时时间 XXL-JOB"},{"path":"/2024/01/18/Note/后端/Go/框架/Beego/","content":"简介 MVC架构"},{"path":"/2024/01/18/Note/后端/Go/基础/Go库/","content":"基础库 函数名 作用 参数 备注 Scanf 接收键盘输入 格式符, &amp;变量 Scan 接收键盘输入 &amp;变量 len 获取对象的长度 对象 cap 获取切片容量 切片对象 append 切片末尾追加数据 切片对象 切片空间不足会扩容 make 创建一个数据类型 copy range 遍历数组对象 遍历中的修改是深拷贝 panic 抛出异常，终止程序 程序出现异常内部会调用 recover 捕获panic抛出的异常 只在defer调用的函数中有效 数据类型() 强制转换为对应的数据类型 Goroutine 函数名 作用 参数 备注 Gosched 用于让出CPU时间片 Goexit 立即终止当前go协程 Gomaxprocs 设置cpu核数 返回值为修改前核心数 Channel"},{"title":"Go","path":"/2024/01/18/Note/后端/Go/基础/GO/","content":"简介 速度快，易学，支持高并发 适合网络编程、区块链开发 类c语言 成员属性和方法如果是大写开头就是public的，小写开头的就是private的 命令 命令 功能 备注 build 编译包和依赖 run 编译并运行 clean 移除当前源码包和关联源码包里面编译生成的文件 env 打印Go的环境信息 fix 将旧的API替换成新的API mod 模块维护 get 将依赖项添加到当前模块并安装它们 基本数据类型 类型 默认值 字节 格式符 备注 byte 1 %c 单个字符 string %s \\0结束，中文3字符，不可变 bool false %t int 0 8 %d 有符号 uint 8 无符号 float32 %f 小数点后7 float64 %f 小数点后15，常用 double complex64 %v 复数，64 位实数+64 位虚数 complex128 %v 64 位实数+64 位虚数 地址值 十六进制 %p 类型 %T 复合数据类型切片 截取集合中的一部分数据 结构 一个指针，指向数组中 slice 指定的开始位置 长度，即 slice 的长度 最大长度，也就是 slice 开始位置到数组的最后位置的长度 内置函数 len：获取长度 cap：获取最大容量 append： 追加一个或者多个元素，然后返回一个和 slice 一样类型的slice 追加元素会影响到原数组和其他指向该数组的切片 当追加元素超过切片最大长度时会创建一个新的数组空间，不会影响到其他 copy：copy 从源 slice 的 src 中复制元素到目标 dst，并且返回复制的元素的个数 数组 函数传递数组是深拷贝，函数传切边是浅拷贝 切边截取是浅拷贝 切边扩容x2，大于1024字节后x 1&#x2F;4 123456789101112131415161718192021222324252627282930//定义var 数组名 [元素数量]类型//自动推导,数量可以省略用...替代数组名 := [数量]类型&#123;对应的值&#125;//嵌套数组数组名 := [2][4]int&#123; [4]int&#123;1, 2, 3, 4&#125;, [4]int&#123;5, 6, 7, 8&#125;&#125;//可省略，需要数组类型一致数组名 := [2][4]int&#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;&#125;//初始化var 数组名[元素数量] 类型 = [数量]类型&#123;对应的值&#125;var 数组名[元素数量] 类型 = [数量]类型&#123;下标:对应的值&#125;//切片创建//1var 切片名 []类型//2，自动推导切片名 := []类型&#123;&#125;//3,长度是初始化长度，容量是最大长度make([]类型,长度,容量)//4，获取数组切片切片名 = 数组名[开始下标:结束下标] map 无序，kv存储 k不重复 函数中是浅拷贝 12345678//创建 &amp; 初始化 var map名 map(key类型)value类型 = map[key类型]value类型&#123;k:v&#125;map名 := map(key类型)value类型&#123;k:v&#125;map名 := make(map(key类型)value类型)map名[k] = v//判断value是否存在, 如果值存在a, b = map名[k] 结构体 函数传递结构体是深拷贝，函数传递切片是浅拷贝 1234567891011121314151617//创建type 结构体名 struct&#123; 成员变量 类型 `标签:值` //如果需要序列化 成员变量 类型 `json:成员变量名`&#125;//切片var 切片名[] 类型//转jsonimport &quot;encoding/json&quot;//结构体转jsonhsonStr, err := json.Marshal(结构体)//json转结构体err = json.Unmarshal(json, 结构体对象) 指针 数组指针取值时应该 (*p)[下标]， 因为括号的优先级高 Go优化成了：p[下标] 指针数组取值时应该 *p[下标] 多级指针 123456789//创建普通指针var 指针名 *类型 = &amp;对象//数组指针var 指针名 *[数量]类型 = &amp;数组//指针数组var 指针名 [数量]*类型//切片var 指针名 *[]类型 channel 解决协程之间的同步问题 没有设置容量的channel为无缓冲channel 需要同时读写，会阻塞，适合同步任务 有缓冲channel适合异步任务 channel关闭后不能写数据，但是可以读数据 创建时默认是双向channel，可以设置单向channel 双向channel可以转换为任意单向channel，反之不行 有一个定时器的类 1234567891011121314151617//创建双向channelvar ch chan channel中数据的类型ch := make(chan channel中数据的类型，容量)//单向写channelvar ch chan &lt;- channel中数据的类型ch := make(chan &lt;- channel中数据的类型，容量)//单向读channelvar ch &lt;- chan channel中数据的类型ch := make(&lt;- chan channel中数据的类型，容量)//写入ch &lt;-//读取s &lt;- ch//关闭close(ch) 常量 &#x2F; 变量 常量格式 const 名称 【类型】&#x3D; 值 变量格式 var 名称 类型 【 &#x3D; 值】 var 名称1，名称2，名称3 类型 【 &#x3D; 值1，值2，值3】 名称 :&#x3D; 值 （简短声明 &#x2F; 自动推导）（只能用在函数中） _（下划线）是个特殊的内置变量，任何赋予它的值都会被丢弃 以声明未使用的值会在编译阶段报错 字符串不可变，怎么修改 1234567891011//1转为字节数组 []byte(c)s := &quot;hello&quot;c := []byte(s) c[0] = &#x27;c&#x27;s2 := string(c) // 再转换回 string 类型fmt.Printf(&quot;%s &quot;, s2)//2用切片拼接s := &quot;hello&quot;s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作fmt.Printf(&quot;%s &quot;, s) 如果想输出多行的字符串，需要使用 &#96; 括起来 12str := `abc def` 大写字母开头的变量&#x2F;函数，是可导出的，其它包可以读取，小写字母开头的则不行 函数 &#x2F; 方法123456//定义func method(参数 类型)(返回值1 返回值类型, ...)&#123; &#125;//使用，多个返回值a, b = method(); 如果方法是公共的，返回值最好命名 函数也是一种变量，可以通过type来定义它，可以用作参数进行传递 关键字 defer 相当于java中的final，c中的析构，即函数结束前执行的操作 执行顺序是后进先出，栈式执行，逆序执行，先执行最下面的 return比defer先执行 select 监听channel上的数据流动 语法类似switch 多个满足条件的随机执行一个 如果一直走到default会导致忙轮询，不建议使用default iota 自动枚举，默认值为0，调用一次加1 每遇到一个 const 关键字，iota 就会重置 fallthrough 在switch中使用，强制执行满足条件之后的所有条件，包括default 面向对象 封装 定义结构体时的this最好指向对象的地址，这样是浅拷贝 继承 123type 子类 struct&#123; 父类&#125; 多态 父类指针指向子类对象 接口12345678910111213141516171819//接口定义type 接口名 interface&#123; 方法名() 【返回值类型】&#125;//接口实现type 实现 struct&#123; 成员变量&#125;func (this &amp;实现) 接口方法名 【返回值类型】&#123;\t实现方法&#125;//万能接口，可接收任意类型func method(arg interface&#123;&#125;)&#123; &#125;//万能接口提供了类型断言value, ok := arg.(string) //判断arg是否是字符串 反射1234567//获取对象的typereflect.TypeOf(对象)//获取对象的valuereflect.ValueOf(对象)//获取对象中的成员的标签t := reflect.TypeOf(对象).Elem()tagIt.Field(下标).Tag.Get(&quot;标签名&quot;) 异常 实际发生异常时系统内部是通过panic函数去抛出这个异常，尽量少用 可以使用errors中的方法对异常进行处理 延迟函数defer会正常执行 文本处理123456789101112131415161718192021222324252627//创建文件file, err := os.Create(&quot;路径&quot;)str = &quot;内容&quot;//写入文件1length, err := file.WriteString(str)//写入文件2，接收字节数组length, err := file.Write([]byte(str))//写入文件3，写入指定位置，会覆盖数据，length, err := file.WriteAt([]byte(str), 下标)//定位文件内容下标length, err := file.Seek(追加空格数，io.SeekEnd)//读取文件1file, err := os.OpenFile(&quot;路径&quot;， 模式， 权限[0-7])//读取文件2，只读，无权限file, err := os.Open(&quot;路径&quot;)//读取文件内容，buffer为读取缓冲区，空余区域会用0填充//buffer存储的Abuffer := make([]byte, 1024 * 2)length, err := file。Read(buffer)//关闭文件defer file.close 协程 gorountine 提高CPU的利用率 主要是gorountine和channel 内存占用几kb 早期的调度器需要获取锁才能执行go协程，性能比较差 调度器设计策略 复用线程 利用并行 抢占 全局G队列 GMPGo调用以太坊 启动rpc端口 geth --identity &quot;XZ&quot; --http --http.port 8545 --datadir &quot;C:\\Go\\test2\\testBlock&quot; --http.api &quot;net,eth,personal,db,web3&quot; --http.corsdomain &quot;*&quot; console identity：节点身份标识 http：开启rpc http.port ：rpc端口 http.api：对外提供的api http.corsdomain：允许连接的url，*无限制，默认只有本机能访问 datadir：区块数据文件夹 networkid：net_version的id，即网络类型 1是主网络，其余是测试网络 port：监听其他端口 nodiscover：隐藏节点，需手动添加 在区块数据文件夹下创建Go工程 导入以太坊相关api 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//获取连接Clientvar client Clientclient = rpc.Dial(&quot;ip：端口&quot;)//获取网络类型networkidvar networkid stringclient.Call(&amp;networkid, &quot;net_version&quot;)//获取是否监听var is_listing boolclient.Call(&amp;is_listing, &quot;net_listening&quot;)//获取节点数量var count stringclient.Call(&amp;count, &quot;net_peerCount&quot;)//获取账户var account []stringclient.Call(&amp;account, &quot;eth_accounts&quot;)//获取账户余额var balance stringclient.Call(&amp;balance, &quot;eth_getBalance&quot;, 账户地址，区块编号(latest、))//获取当前gas价格var gas stringclient.Call(&amp;gas, &quot;eth_gasPrice&quot;)//获取挖矿地址账户var coinbase stringclient.Call(&amp;coinbase, &quot;eth_coinbase&quot;)//获取当前以太坊协议版本var protocolVersion stringclient.Call(&amp;protocolVersion, &quot;eth_protocolVersion&quot;)//获取当前是否在挖矿var isMining boolclient.Call(&amp;isMining, &quot;eth_mining&quot;)//获取挖矿速率var hashrate stringclient.Call(&amp;hashrate, &quot;eth_hashrate&quot;)//获取指定地址发生的交易数量var transactionCount stringclient.Call(&amp;transactionCount, &quot;eth_getTransactionCount&quot;, &quot;地址&quot;，区块编号(latest、))//获取节点当前块编号var blockNum stringclient.Call(&amp;blockNum, &quot;eth_blockNumber&quot;)//创建账户var account string var pwd string // 参数client.Call(&amp;account, &quot;personal_newAccount&quot;, pwd)//获取账户列表var accounts []string client.Call(&amp;accounts, &quot;personal_listAccounts&quot;)//锁定指定账户var lock boolclient.Call(&amp;lock, &quot;personal_lockAccount&quot;, &quot;地址&quot;)//解锁指定账户var lock boolclient.Call(&amp;lock, &quot;personal_unlockAccount&quot;, &quot;地址&quot;, &quot;密码&quot;)//写入数据库 Go调用智能合约 通过remix部署合约获取abi信息，新建一个abi后缀名的文件 或者通过工具solc生成 solc -bin test.sol -o test.abi 使用abigen工具，根据abi文件生成对应的go文件 abigen --abi abi文件 --pkg 包名 --type 结构体名 --out 文件名.go","tags":["language","go"],"categories":["Go"]},{"path":"/2024/01/18/Note/区块链开发/源码/以太坊/","content":"目录结构结构块头1234567891011121314151617type Header struct&#123; ParentHash common.Hash //父区块的hash值 UncleHash common.Hash //父区块fen&#x27;cha区块的hash值 Coinbase common.address //挖出区块的矿工的地址 Root common.Hash //状态树根节点hash值 TxHash common.Hash //交易树根节点hash值 ReceiptHash common.Hash //收据树根节点hash值 Bloom Bloom //布隆过滤器，配合收据树使用 Difficulty *big.Int //挖矿难度 Number *big.Int // GasLimit uint64 //区块能消耗的汽油费的上限，可微调1024分之1 GasUsed uint64 //区块汽油费总和 Time *big.Int //区块产生时间 Extra []byte // MixDigest common.Hash // Nonce BlockNonce //挖矿随机值，符合难度要求的&#125; 交易12345678type txdata struct &#123; AccountNonce uint64 //交易序号 Price *big.Int //单位汽油费 GasLimit uint64 //最大汽油费 Recipient *common.Address //收款人地址 Amount *big.Int //转账金额 Payload []byte //data域，存放的是调用的合约的哪一个函数&#125; 统一的树结构1234567//MPT树结构type Trie struct&#123; db *Database root node originalRoot\tcommon.Hash cachegen, cachelimit uint16&#125; 交易树收据树1234567891011//收据树结构type Recipt struct&#123; PostState []byte Status uint64 //jiao&#x27;yi CumulativeGasUsed\tuint64 Bloom Bloom //布隆过滤器，根据log生成，多个收据多个Bloom合并 Logs []*Log TxHash common.Hash ContractAddress common.Address GasUsed uint64&#125; 账户1type 文件block.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//2018版ETH-创建区块func NewBlock(header *Header, txs []*Transaction, uncle []*Header, receipts []*Receipt) *Block&#123; b := &amp;Block&#123; header: CopyHeader(header), td: new(big.Int) &#125; //判断交易列表是否为空 if len(txs) == 0&#123; //为空则交易树的根hash值为空hash值 b.header.TxHash = EmptyRootHash &#125;else&#123; //不为空则调用DeriveSha获取交易树的根hash值并设置 b.header.TxHash = DeriveSha(Transactions(txs)) b.transactions = make(Transactions, len(txs)) copy(b.transactions, txs) &#125; //判断收据列表是否为空 if len(receipts) == 0&#123; //为空则收据树的根hash值为空hash值 b.header.ReceiptHash = EmptyRootHash &#125;else&#123; //不为空则调用DeriveSha获取交易树的根hash值并设置 b.header.ReceiptHash = DeriveSha(Receipts(txs)) //创建布隆过滤器 b.header.Bloom = CreateBloom(receipts) &#125; //判断叔父区块是否为空 if len(uncle) == 0&#123; //为空则叔父区块的hash值为空hash值 b.header.UncleHash = EmptyUncleHash &#125;else&#123; //不为空则调用 CalcUncleHash 计算出叔父区块的hash b.header.UncleHash = CalcUncleHash(uncles) //构建叔父区块的数组 b.uncles = make([]*Header, len(uncles)) for i := range uncles &#123; b.uncles[i] = CopyHeader(uncles[i]) &#125; &#125;&#125;//获取列表Hash值func DeriveSha(list DerivableList) common.Hash &#123; keybuf := new(byte.Buffer) trie := new(trie.Trie) for i := 0; i &lt; list.Len(); i++ &#123; keybuf.Reset() rlp.Encode(keybuf, uint(i)) trie.Update(keybuf.Bytes(), list.GetRlp(i)) &#125; return trie.Hash()&#125; 函数布隆过滤器12345678910111213141516171819202122232425262728293031323334353637//创建布隆过滤器func CreateBloom(receipts Receipts) Bloom&#123; bin := new(big.Int) //将多个收据的bloom合并 for _, receipt := range receipts&#123; bin.Or(bin, LogsBloom(receipt.Logs)) &#125; return BytesToBloom(bin.Bytes())&#125;//生成每个收据的bloom func LogsBloom(logs []*Log) *big.Int&#123; bin := new(big.Int) //根据log生成bloom for _, log := range logs&#123; //将每个log的地址取hash后加入bloom bin.Or(bin, bloom9(log.Address.Bytes())) for _, b := range log.Topics&#123; //将每个log的topic取hash后加入bloom bin.Or(bin, bloom9(b[:])) &#125; &#125;&#125;//bloom中使用的hash函数func bloom9(b []byte) *big.Int&#123; //生成一个256位32字节的hash值 b = crypto.Keccak256(b[:]) //要返回的bloom r := new(big.Int) //对生成的32字节的hash值取前6位，每2位组成一组，即3轮循环 for i := 0; i &lt; 6; i += 2&#123; t := big.NexInt(1) //对2048取余，因为bloom的大小是2048位 b := (uint(b[i+1]) + (uint(b[i]) &lt;&lt; 8)) &amp; 2047 r.Or(r, t.Lsh(t, b)) &#125; return r&#125; 123456//查看bloom，判断bin这个过滤器中是否存在dui&#x27;yingfunc BloomLookup(bin Bloom, topic bytesBacked) bool &#123; bloom := bin.Big() cmp := bloom9(topic.Bytes()[:]) return bloom.And(bloom, cmp).Cmp(cmp) ==0&#125; 挖矿算法 通过seed计算出Cache数组 1 难度调整1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func calcDifficultyByzantium(time uint64, parent *types.Header) *big.Int&#123; //当前时间戳 bigTime := new(big.Int).SetUint64(time) //父区块的时间戳 bigParentTime := new(big.Int).Set(parent.Time) //难度 x := new(big.Int) //难度调整单位 y := new(big.Int) //算出出块时间，然后再除9 x.Sub(bigTime, bigParentTime) x.Div(x, big9) //判断是否有叔父区块 if parent.UncleHash == types.EmptyUncleHash&#123; x.Sub(big1, x) &#125;else&#123; x.Sub(big2, x) &#125; //与最小难度-99相比，不能比它更小 if x.Cmp(bigMinus99) &lt; 0 &#123; x.set(bigMinus99) &#125; //计算难度调整单位 //上一个区块的难度的2048分之1 y.Div(parent.Difficulty, 2048) x.Mul(y, x) x.Add(parent.Difficulty, x) //难度最小不能小于131072 if x.Cmp(params.MinimumDifficulty) &lt; 0&#123; x.Set(params.MinimumDifficulty) &#125; //难度炸弹计算 //区块号 fakeBlockNumber := new(big.Int) //如果父区块号大于3百万，则减去3百万 if parent.Number.Cmp(big2999999) &gt;= 0&#123; fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) &#125; periodCount := fakeBlockNumber //除于100000 periodCount.Div(periodCount, expDiffPeriod) // if periodCount.Cmp(big1) &gt; 0 &#123; //当前区块号-2 y.Sub(periodCount, big2) y.Exp(big2, y, nil) x.Add(x, y) &#125; &#125;"},{"path":"/2024/01/18/Note/区块链开发/源码/Uniswap/","content":"结构1234graph TD;\tUniswapV2ERC20 --继承--&gt; UniswapV2Pair --引用--&gt; UniswapV2Factory\t项目方 --创建流动性--&gt; UniswapV2Router --调用--&gt; UniswapV2Factory --部署--&gt; UniswapV2Pair\t用户 --交易--&gt; UniswapV2Router --调用--&gt; UniswapV2Pair 接口IUniswapV3Factory 工厂接口 合约UniswapV3Factory 工厂合约"},{"title":"EVM","path":"/2024/01/18/Note/区块链开发/源码/EVM/","content":"简介 类似JVM虚拟机，是一个基于栈的虚拟机 结构 Storage结构 以太坊中采用的是插槽 slot 存储，KV映射，k是slot，有32个字节，v也是32个字节 slot 空间不足时会自动存入下一个slot 操作的时候也是对整个slot进行操作 基本数据类型是从slot中的低位向高位存储数据 结构体和定长数组的存储会单独创建一整块slot进行存储 映射mapping会通过占位符占据整块slot数组，然后value存储在keccak256(slot下标.key) 动态数组会用数组长度占据1块slot数组，然后数据存储keccak256(slot下标.value) bytes和string 数据长度 &lt;&#x3D; 31字节：数据存高31位，最低一位存数据长度 * 2 数据长度 &gt;&#x3D; 31字节：会存储一个数据长度 * 2 + 1，数据会另外存储 EVM会将有空余空间的slot填充到32位，这增加了gas费 编译器会将多个元素合并到一个slot，所以需要保证这些元素是可以紧密存储的 变量和结构体存储时可以考虑占满一个slot Memory结构 0x40指向的是现在能操作的空闲的地址 只能创建定长数组 创建数组时要指定长度，创建的数组不能进行大小的变更操作 在返回值中使用memory的话，是不会存在函数的默认内存空间中的，会开辟一块新的内存空间 不定长的数据类型作为返回值需要加上memory Solidity中的函数默认返回值存储在堆栈上，而堆栈空间是有限的。如果函数返回的数据类型是不定长的，并且长度超过堆栈的大小限制，那么将会导致栈溢出错误 日志 日志用来存储Solidity中的事件 结构 topics 主题 是一个数组，长度不超过4 第一个元素是事件的签名，此外最多可以包含三个indexed参数 indexed标注的参数可以看作是事件的索引键 data 数据 普通参数会保存在data中 可以看作是事件的值 不可以被直接检索，可以存储任意大小的数据 data存储数据消耗的gas比topics少 汽油费 智能合约是一个图灵完备的编程模型 如果出现死循环（停机问题） 执行合约中的指令需要收取汽油费，由发起交易的人支付 不同指令消耗的汽油费是不同的 简单的指令汽油费低，复杂或者需要存储数据的指令就很贵","tags":["web3"],"categories":["Web3"]},{"title":"区块链基础","path":"/2024/01/18/Note/区块链开发/基础/区块链知识/","content":"简介WEB3 WEB1：只读，静态内容，信息聚合 WEB2：可读写，可交互，数据存储在中心化服务器，受监管 WEB3：可读写，可拥有，去中心化，不可篡改 平台对比 以太坊 Fabric Corda 节点许可 基于智能合约的规则，将基于文件的每个节点的规则作本地覆盖（override） 可在节点(node)，通道(channel)和联盟(consortium)级别上配置 可信网络映射服务，由每个节点上基于文件的配置进行补充。Corda网络被划分为由单独的证书颁发机构(Certificate Authorities)管理的兼容区域 身份 公钥-分布式的，可在以太坊的链之间可互操作。通过证明(proofs)与PKI耦合 基于具有本地组织身份的PKI。在共识和许可中始终使用组织身份，而不是个人身份 基于个人和组织身份的PKI 加密算法 secp256k1 可插拔 (内置有 secp256r1 和 secp384r1的椭圆算法). ed25519 secp256r1 secp256k1 RSA (3072bit) PKCS#1 SPHINCS-256 (experimental 试验阶段) 交易共识 排序(Order)-&gt;执行(Execute)&#x2F;验证(Validate) 执行-&gt;排序-&gt;验证 执行&#x2F;验证-&gt;排序&#x2F;公证(Notarize) 应用的责任 将签名的交易发送到网络中的一个节点 直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking) 直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking) 共识算法 Proof-of-Authority 权威证明 (BFT). Raft (CFT with trusted leader，有可信领导). Istanbul BFT (BFT with deterministic leader rotation 有确定性领导轮换). Tendermint Kafka&#x2F;Zab (CFT with trusted leader 有可信领导). Raft (CFT with trusted leader有可信领导) Raft (CFT with trusted leader有可信领导) BFT 智能合约引擎 EVM, 进程内沙盒(in-process sandbox) 容器隔离(Docker isolation) 确定性JVM(Deterministic JVM) 智能合约语言 DSL (Solidity, Serpent), 保证确定性 多语言 (Go, Node.js, Java), 可容忍的非确定性 Java, Kotlin, 通过推荐的库来实现确定性 智能合约生命周期 不可篡改，部署容易，链上储存 需要细致的过程(elaborate process)来部署&#x2F;更改。链下存储 需要节点级管理操作才能部署&#x2F;更新。链下存储。 正在进行的工作是将共识关键代码与非共识关键代码拆分为不同的存储策略（分别在链上和链下） 智能合约升级 通过编程模式来扩展&#x2F;迁移代码和数据 通过管理程序和升级交易来替换链下代码 具有基于哈希约束的合同通过节点级管理程序和协调流程进行显式升级和授权。只要根据约束条件和哈希匹配项进行签名，具有签名约束条件的合同就会自动允许执行新版本 资产数字化&#x2F;通证化 原生带有多标准功能: ERC20&#x2F;ERC721&#x2F;ERC777 etc. 无原生通证，定制化方案 定制化方案，通过Corda通证SDK更容易实现 多链 每个链都是唯一的，并且需要单独的节点运行时（最少或3或4个，取决于共识） 具有共享对等runtime和共享顺序器的本机功能（通道）。用于创建具有隔离状态的侧链的内置治理 没有链的概念（共享账本）。交易始终明确地针对特定节点。状态的范围仅限于指定的公证节点，可以将其重新定向到其他公证 私有交易 公共哈希代表输入 公共哈希代表输入和私有结束状态 继承的所有交易都是私有的。所有的交易对对验证公正节点 社区贡献者（至2019年10月） Go-Ethereum: 429 Quorum: 383 Besu: 60 Autonity: 360 Fabric: 185 Corda: 146 社区活跃度(Month of Nov. 2019) Go-Ethereum: 15 authors, 98 PRs Quorum: 9 authors, 13 PRs Besu: 23 authors, 66 PRs Autonity: 6 authors, 6 PRs Fabric: 31 authors, 220 PRs Corda: 33 authors, 91 PRs 链种对比 公有链 联盟链 私有链 中心化程度 完全 部分 可控性 弱 强 数据隐秘性 弱 强 交易速度 慢 快 场景 溯源、慈善、金融、保险 密码学基础 是区块链底层安全机制的保障 对消息签名使用的是非对称加密的签名算法，运用到了 RSV 柯尔霍夫原则 密钥是保密的，算法和参数是公开的 不需要数学上不可解，现实不可解即可 加密 对称加密 DES、AES、伪随机数生成 非对称加密 公私钥 安全性来源都是基于数学难题 哈希算法 collisiom resistance：输入转hash结果不变，但存在哈希碰撞 hiding：根据哈希值无法预测输入 puzzle friendly：根据输入无法预测哈希值 默克尔树 依靠hash来快速确认某个值是否在集合中 区块链简介 区块链提供了一种让多个参与方在没有一个唯一可信方的情况下达成合作 区块链上的数据是不可篡改的 区块链的安全性是通过使用hash和签名的方式进行加密，使用的是 sha-256 加密算法 创建账户原理 因为是去中心化的，所以个人即可创建账户，无需审核 创建账户的过程就是创建一个公私钥 公钥就是账号 私钥就是操作账号的权限 对交易进行加密，用私钥加密，公钥解密，也就是一个签名的过程 挖矿 挖矿是无记忆的，即和已经挖矿的时长无关 在互不信任的对象之间建立联系 结构哈希指针 保存指向区块的哈希值和区块地址 每个区块有一个指针指向前一个区块 这个指针的hash值为前一个区块的数据+前一个区块的hash值 即前一个区块的数据如果发生变化，后一个区块的hash指针就找不到前一个区块了 区块结构 不同的加密货币中区块的内容不同 交易 交易现在本地上执行完成，再进行挖矿 因为要先确认块头中的信息 要验证交易的合法性、智能合约的正确执行 比特币简介 区块链1.0 区块链中的第一个区块为创世区块 一个节点最大1mb，一个交易250字节，最多有4000个交易，每秒处理大概7个交易 是一个基于栈的语言 很大程度的保证数据不可篡改 使用非对称加密椭圆曲线ECC中的secp256k1曲线 转账操作都需要签名（转账发起人的私钥） 转账需要说明币的来源 节点分为全节点和轻节点 全节点 一直在线，维护完整的区块信息 监听区块链网络上的交易信息，验证每个交易的合法性 决定哪些交易会被打包到区块里 监听其他矿工挖出的区块，验证其合法性 轻节点 包含block header 不是一直在线的 只保存与自己相关的交易，并只能检验与自己相关的交易的合法性 无法检测其他人发布的区块的正确性 可以验证挖矿难度 能检测最长链，但不能检测最长合法链 由于网络带宽限制和算力分布限制，比特币限制了单个节点可接收信息和主动链接其他节点的上限。对于接受信息，单个节点最多只能接收117个节点的信息，对于主动链接其他节点，单个节点只能主动联系其他8个节点 结构区块结构 block header 区块头 存储merkle tree的根hash值，可以检测出整棵树任何位置的修改 比特币协议版本 指向前一个区块区块头的指针（其实是一个哈希） 挖矿难度目标阈值target（256byte），被编码成4byte的nBits block body 区块体 存储了具体的交易列表 UTXO UTXO存储的是没花出去的交易的输出集合 矿池 一个矿主+很多的矿工 矿主负责全节点的工作，矿工负责计算hash值 分红 按劳分配，通过工作量证明 降低工作难度，矿工提交难度低的区块作为工作证明 私吞情况 不可能的，矿工的任务由矿主分配 收款地址是矿主的，无法私吞 存在恶意竞争的情况 其他矿池安排一些矿工到其他矿池工作 参与其他矿池的分红，但是当这些矿工挖到区块后会选择放弃区块 有危害，当矿池算力达到51%攻击后 可以实现分叉攻击 可以实现封锁账户 挖矿 出块时间十分钟，同时出块的可能性较小 解决恶意节点，防止女巫攻击（sybil attack） 女巫攻击：制造大量的账号进行攻击 比特币使用算力投票 最长链原则 挖矿奖励机制 每隔2016个区块要重新调整目标阈值，大约两星期 target &#x3D; target * 实际产生2016个区块的时间 &#x2F; (2016*10) target的上调和下调的上限不会超过四倍 当该区块被其他矿工挖出后，会停止当前区块，组装新的候选区块 不可惜，因为每次挖矿的概率都是一样的 确认交易机制 交易写入区块后为了防止双花攻击，可以多等6个区块产出后再确认，差不多一小时 应用层、P2P tcp通信 交易结构 记录的是当前区块中所有的交易信息 交易id、交易的hash值、版本号、大小、 所在区块hash值，交易确认信息数、交易产生时间、区块产生时间 锁定时间 locktime 一般都是0，即立即生效 输入 vin txid：之前交易的hash值，也就是币的来源 vout：这个交易的第几个输出 ScriptSig：输入脚本，签名 asm：操作 hex： 输出 vout value：交易的金额 n：这个交易的第几个输出 scriptPubKey：输出脚本 asm：操作 hex： reqSigs：需要的签名数 type：输出的类型 address：输出的地址 merkle tree 交易的结构是一颗二叉树，叶子节点是交易的数据，非叶子节点是左右孩子节点的hash 非叶子节点的hash指针有两个，分别指向左右子树 通过左右孩子可以计算得出上一个节点（父节点）的hash值 提供merkle proof，即交易到merkle tree的根hash值的路径 当一个轻节点想知道交易是否包含在对应的区块中的merkle tree时，它需要 计算当前交易的hash值，通知全节点取得另一个hash值 计算得出上一个节点的hash次，循环往复直到根节点 轻节点将计算得出的根节点hash值和当前区块的block header中的根节点hash值进行比较即可 可以证明交易存在merkle tree中，proof of membership 如果merkle tree的叶子节点是有序的话，就可以证明某个交易是否在树上 比特币的merkle tree的叶子节点是无序的 铸币交易的输出会有目标用户的hash 目标用户转账时会校验这个hash是否正确，这样可以避免伪造交易 交易合法性 早期脚本是将当前交易的输入和币的来源的输出拼接在一起验证 后出于安全因素改为分别验证 先执行输入脚本，在执行输出脚本 P2PK 输入 支付人的签名 输出 收款人公钥 检查签名 流程 将输入的签名压入栈 将输出中的公钥压入栈 验证栈中的公钥和签名是否合法 P2PKH（最常用） 输入 支付人的签名 收款人公钥 输出 DUP 复制栈顶元素 HASH160 将栈顶元素取hash值 收款人公钥的hash 检查签名 流程 将输入脚本中的支付人的签名压入栈 将输入脚本中的收款人公钥压入栈 复制栈顶元素压入栈（收款人公钥） 将栈顶元素弹出并取hash值压入栈（收款人公钥哈希） 将输出脚本的收款人公钥的hash压入栈 比较栈顶两个元素是否一致（比较两个收款人hash是否一致） 检查签名 P2SH 输入 支付人的签名 赎回脚本 收款人公钥 检查签名 输出 HASH160 将栈顶元素取hash值 赎回脚本 收款人公钥hash 流程 将输入脚本中的支付人的签名压入栈 将输入脚本中的赎回脚本压入栈 将栈顶元素弹出并取hash值压入栈 得到赎回脚本的hash，其实就是收款人公钥的hash 将输出脚本的赎回脚本压入栈 其实就是将收款人公钥的hash压入栈 验证收款人公钥的hash值是否一致 验证输入的签名和输入的赎回脚本中的签名 多重签名 需要多个人的签名才可以进行转账 p2sh实现 封装了公钥 有bug，会多压一个冗余数据入栈 分叉 产生的原因 同时发布区块 分叉攻击 比特币协议发生改变 硬分叉（hard fork） 永久的 向前不兼容 部分节点不更新协议就会出现，而且不会消除 会出现回访攻击和重放攻击 通过chain ID 解决 软分叉（soft fork） 暂时的 向前兼容的是软分叉 Taproff 可以在BTC编写高级脚本 以太坊简介 区块链2.0 出块时间10几秒 运行的是去中心化的智能合约，发布后不可修改 有账户的性质 能避免双花攻击 余额通过状态树维护，避免篡改余额 有一个随机数记录账户交易的次数 1以太 &#x3D; 10^18^Wei 账户中可存放合约代码 账户可存储信息 发布新的区块时不会包含叔父区块中的交易，会检查叔父区块的合法性（是否符合挖矿难度要求） 只有分叉后的第一个叔父节点可以得到奖励、 交易需要付燃油费gas 每5个byte需要1个gas 状态树（Modified Merkle Patricia Tree） 账户地址到账户状态的映射，键值对 key是地址 value是账户的状态，通过RLP进行序列化 账户地址160位，40个16进制的数 类似字典树，但进行了路径压缩 是唯一的 路径压缩对稀疏的数据效果好 eth的地址是2^160^ 的随机数，符合稀疏的条件 路径压缩就是把相同前缀的节点进行合并，减小树的高度 没有发生变化的节点在区块之间是共享的，有发生变化的需要新建分支 维护没有发生变化的区块，是因为需要保留历史状态 因为交易可能需要回滚，所以需要保留历史状态 因为智能合约的设计复杂，无法推断出账户之前的状态，所以需要保留账户的历史信息 大的状态树包含很多小的状态树 交易树 结构和状态树一样 记录的是交易信息 收据树 结构和状态树一样 结合布隆过滤器一起使用 每次交易 记录的是交易的收据信息，记录了交易的执行结果，收据列表的长度和交易列表的长度一致 共识协议POW 由于出块时间短，导致出现多个节点同时出块的可能性很高，所以临时性分叉很多 大型矿池更有可能成为最长合法连，马太效应 以太坊使用基于Ghost协议的共识机制 奖励 叔父区块可以获得出块奖励，每次发布新区块最多只有两个叔父区块可以获得奖励 七代以内的叔父 区块才有奖励，逐代递减1&#x2F;8 发布区块包含叔父区块可以获得1&#x2F;32奖励，包含多个就有多份奖励 挖矿算法 使用两个数据集，一个16m的cache，一个1G的dataset 这个大小是会增长的 轻节点保存cache即可，矿工节点保存dataset 步骤 通过一个种子seed通过某种运算算出一个值，然后依次经过这个运算取值存入cache数组 每隔30000个区块会重新生成seed，即对原来的seed取hash cache数组的初始大小是16M，每隔30000个区块会增大128k 生成一个更大的dataset数组 初始大小是1G，每隔30000个区块会增大8M 读取小数组第 i % cache_size ，对这个数异或 i 再取hash，记为mix 循环256次 通过函数传入mix算出下一个读取的下标 通过函数传入mix和 cache[下标 % cache_size]，得到新的mix 得到 hash(mix) 存入dataset[i] 循环这个操作直到填满dataset 根据块头和nonce值，算出一个初始的hash，映射到大数组的某个位置和他的下一个位置 全节点直接访存，轻节点通过下标间接访问 然后这两个位置的数在进行运算得出下两个位置，循环这个操作64次 最后算出的值和挖矿难度的目标阈值比对，满足则通过，不 过则改nonce 难度调整 难度为：max（131072, 父区块难度 + X * Y） + Z 最低难度：131072 X：难度调整单位，上一个区块的难度的2048分之1 Y：max（n - m，-99） n：有uncle区块为2，否则为1 m：（当前区块的时间戳 - 父区块的时间戳） &#x2F; 9，向下取整 Z：2^(区块号-3000000)&#x2F;100000-2^ 难度炸弹，挖矿初期难度炸弹影响较小，越往后难度指数增加 WETH 遵守ERC20标准的以太坊代币 和ETH一比一兑换 签名 以太坊使用的数字签名算法叫双椭圆曲线数字签名算法（ECDSA），基于双椭圆曲线“私钥-公钥”对的数字签名算法。它主要起到了三个作用 身份认证：证明签名方是私钥的持有人。 不可否认：发送方不能否认发送过这个消息。 完整性：消息在传输过程中无法被修改。 签名流程 签名者利用私钥（隐私的）对消息（公开的）创建签名（公开的）。 其他人使用消息（公开的）和签名（公开的）恢复签名者的公钥（公开的）并验证签名。 共识机制POW 工作量证明，即比拼算力 通过求得满足难度要求的Hash值即可获得记账权 耗费电力，算力集中到了矿池 POS 权益证明，即比拼钱、币龄 早期有两边下注的问题 验证者 质押抵押金可以参与验证者的选举，抵押金越高越容易成为验证者 抵押金会被锁定一段时间 如果验证者将非法的交易写入区块，则会扣除抵押金 DPOS 委托权益证明 &#x2F; 代理权益证明 角色：投票、见证人、代表 用户投票选出见证人 代表人可以提出提案，用户投票决定是否采纳 PBFT 实用拜占庭容错机制，主要应用于联盟链中 三个阶段：预准备阶段、准备阶段和确认阶段，总节点数为N个，“拜占庭节点”有f个 预准备阶段：主节点发布包含待验证记录的预准备消息，接收到预备消息后，每一个节点进入准备阶段 准备阶段：每一个节点验证其正确性，将正确记录保存下来发送给其他节点，直到某一个节点接收到2f个不同节点发送的与预准备阶段接收的记录一致的正确记录，该节点才向其他节点广播确认消息 确认阶段：直到每个诚实节点接收到2f+1个确认消息，协议才终止，各节点对记录达成一致 实现区块链的一致性，剔出多余的计算量，避免资源浪费 只有一个节点可以提出新区块，因而不会出现“分叉”问题 Layer2rollup 在以太坊Layer1上部署合约 时刻更新交易数据到Layer2网络中 将交易按批次打包交易提交到Layer1的智能合约上 乐观打包 Optimistic 引入争议时间延迟机制 使用挑战期保护数据正确性 容易实现 Arbitrum 多轮交互式欺诈证明 可组合性 零知识证明打包 安全性依赖密码学，不需要挑战期 计算能力较差 然后以太坊主网验证 NFTDAO 将治理规则以智能合约形式编码的去中心化自治组织，与公司制相对 组织资源、事项执行、资金分配 去中心化存储 ipfs 星际文件系统 跨链多链 通过两条链的智能合约实现 一般通过资产冻结和生成实现","tags":["web3"],"categories":["Web3"]},{"title":"区块链协议","path":"/2024/01/18/Note/区块链开发/基础/协议/","content":"简介 想要发行代币或者NFT，就需要实现相应的协议中规定的函数&#x2F;接口并对外暴露 ERC Ethereum Request For Comments 以太坊意见征求稿， 用以记录以太坊上应用级的各种开发标准和协议 EIP Ethereum Imporvement Proposals 以太坊改进建议, 是以太坊开发者社区提出的改进建议 EIP 包含 ERC 代币协议ERC201234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253contract ERC20 is IERC20&#123;\t//balanceOf、allowance、totalSupply为public，会自动生成对应的get方法实现IERC20中的接口\tmapping(address =&gt; uint256) public override balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance; uint256 public override totalSupply; // 代币总供给 string public name; // 名称 string public symbol; // 代号 uint8 public decimals = 18; // 小数位数 //初始化代币名称、代号 constructor(string memory name_, string memory symbol_)&#123; name = name_; symbol = symbol_; &#125; //转账 function transfer(address recipient, uint amount) external override returns(bool)&#123; balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true; &#125; //授权，被授权方spender可以支配授权方的amount数量的代币 function approve(address spender, uint amount) external override returns (bool)&#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; &#125; //授权转账 function transferFrom(address sender, address recipient, uint amount) external override returns (bool) &#123; allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true; &#125; //铸币函数 function mint(uint amount) external &#123; balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount); &#125; //销毁函数 function burn(uint amount) external &#123; balanceOf[msg.sender] -= amount; totalSupply -= amount; emit Transfer(msg.sender, address(0), amount); &#125;&#125; 代币标准，IERC20是他的接口合约 函数 代币总量 totalSupply 账户余额 balanceOf 转账 transfer 授权转账 approve 授权额度 allowance 获取授权转账 transferFrom 代币信息（可选）：名称，代号，小数位数下 事件 Transfer事件 Approval事件 使用时 需要添加铸币函数和销毁函数 需要注意权限控制和溢出问题 EIP-712- Ordinals 序数 可以给聪添加编号 Inscription 铭文 可以给带序数的聪里嵌入信息，大小在4mb以内 这个过程也成为铭刻 BRC20 本质是一个Json脚本 不允许智能合约 安全公平 优缺点 提高网络安全 提高矿工收入，保障了算力的稳定 偏离了比特币最初的目标 造成区块链膨胀，大小变大 会有垃圾信息 损害了聪的可替代性 NFT协议ERC165 检查一个智能合约是不是支持了ERC721，ERC1155的接口。 IERC165接口合约只声明了一个supportsInterface函数，输入要查询的interfaceId接口id，若合约实现了该接口id，则返回true 即对外表明自己实现了哪些接口标准 如果想知道某个合约实现了哪些接口合约，只需要将该合约的 Interface ID 传入目标合约的 supportsInterface 函数，返回为true即实现了对应的合约要求 Interface ID 是接口合约中每个函数选择器 取 keccak256 再异或(^) 取 bytes4 获得 ERC721123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247// SPDX-License-Identifier: MIT// by 0xAApragma solidity ^0.8.4;import &quot;./IERC165.sol&quot;;import &quot;./IERC721.sol&quot;;import &quot;./IERC721Receiver.sol&quot;;import &quot;./IERC721Metadata.sol&quot;;import &quot;./Address.sol&quot;;import &quot;./String.sol&quot;;contract ERC721 is IERC721, IERC721Metadata&#123; using Address for address; // 使用Address库，用isContract来判断地址是否为合约 using Strings for uint256; // 使用String库， // Token名称 string public override name; // Token代号 string public override symbol; // tokenId 到 owner address 的持有人映射 mapping(uint =&gt; address) private _owners; // address 到 持仓数量 的持仓量映射 mapping(address =&gt; uint) private _balances; // tokenID 到 授权地址 的授权映射 mapping(uint =&gt; address) private _tokenApprovals; // owner地址。到operator地址 的批量授权映射 mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals; /** * 构造函数，初始化`name` 和`symbol` . */ constructor(string memory name_, string memory symbol_) &#123; name = name_; symbol = symbol_; &#125; // 实现IERC165接口supportsInterface function supportsInterface(bytes4 interfaceId) external pure override returns (bool) &#123; return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC721Metadata).interfaceId; &#125; //查询owner地址的balance。 function balanceOf(address owner) external view override returns (uint) &#123; require(owner != address(0), &quot;owner = zero address&quot;); return _balances[owner]; &#125; //查询tokenId的owner。 function ownerOf(uint tokenId) public view override returns (address owner) &#123; owner = _owners[tokenId]; require(owner != address(0), &quot;token doesn&#x27;t exist&quot;); &#125; //查询owner地址是否将所持NFT批量授权给了operator地址。 function isApprovedForAll(address owner, address operator) external view override returns (bool)&#123; return _operatorApprovals[owner][operator]; &#125; //将持有代币全部授权给operator地址 function setApprovalForAll(address operator, bool approved) external override &#123; _operatorApprovals[msg.sender][operator] = approved; emit ApprovalForAll(msg.sender, operator, approved); &#125; //查询tokenId的授权地址。 function getApproved(uint tokenId) external view override returns (address) &#123; require(_owners[tokenId] != address(0), &quot;token doesn&#x27;t exist&quot;); return _tokenApprovals[tokenId]; &#125; //内部授权函数，授权 to 地址操作 tokenId。 function _approve(address owner, address to, uint tokenId) private &#123; _tokenApprovals[tokenId] = to; emit Approval(owner, to, tokenId); &#125; //将tokenId授权给 to 地址 function approve(address to, uint tokenId) external override &#123; address owner = _owners[tokenId]; require( msg.sender == owner || _operatorApprovals[owner][msg.sender], &quot;not owner nor approved for all&quot; ); _approve(owner, to, tokenId); &#125; // 查询 spender地址是否可以使用tokenId（他是owner或被授权地址）。 function _isApprovedOrOwner( address owner, address spender, uint tokenId ) private view returns (bool) &#123; return (spender == owner || _tokenApprovals[tokenId] == spender || _operatorApprovals[owner][spender]); &#125; //内部转账函数。将 tokenId 从 from 转账给 to function _transfer( address owner, address from, address to, uint tokenId ) private &#123; require(from == owner, &quot;not owner&quot;); require(to != address(0), &quot;transfer to the zero address&quot;); _approve(owner, address(0), tokenId); _balances[from] -= 1; _balances[to] += 1; _owners[tokenId] = to; emit Transfer(from, to, tokenId); &#125; // 实现IERC721的transferFrom，非安全转账，不建议使用。调用_transfer函数 function transferFrom( address from, address to, uint tokenId ) external override &#123; address owner = ownerOf(tokenId); require( _isApprovedOrOwner(owner, msg.sender, tokenId), &quot;not owner nor approved&quot; ); _transfer(owner, from, to, tokenId); &#125; /** * 安全转账，安全地将 tokenId 代币从 from 转移到 to，会检查合约接收者是否了解 ERC721 协议，以防止代币被永久锁定。调用了_transfer函数和_checkOnERC721Received函数。条件： */ function _safeTransfer( address owner, address from, address to, uint tokenId, bytes memory _data ) private &#123; _transfer(owner, from, to, tokenId); require(_checkOnERC721Received(from, to, tokenId, _data), &quot;not ERC721Receiver&quot;); &#125; /** * 实现IERC721的safeTransferFrom，安全转账，调用了_safeTransfer函数。 */ function safeTransferFrom( address from, address to, uint tokenId, bytes memory _data ) public override &#123; address owner = ownerOf(tokenId); require( _isApprovedOrOwner(owner, msg.sender, tokenId), &quot;not owner nor approved&quot; ); _safeTransfer(owner, from, to, tokenId, _data); &#125; // safeTransferFrom重载函数 function safeTransferFrom( address from, address to, uint tokenId ) external override &#123; safeTransferFrom(from, to, tokenId, &quot;&quot;); &#125; /** * 铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。 * 这个mint函数所有人都能调用，实际使用需要开发人员重写，加上一些条件。 * 条件: * 1. tokenId尚不存在。 * 2. to不是0地址. */ function _mint(address to, uint tokenId) internal virtual &#123; require(to != address(0), &quot;mint to zero address&quot;); require(_owners[tokenId] == address(0), &quot;token already minted&quot;); _balances[to] += 1; _owners[tokenId] = to; emit Transfer(address(0), to, tokenId); &#125; // 销毁函数，通过调整_balances和_owners变量来销毁tokenId，同时释放Transfer事件。条件：tokenId存在。 function _burn(uint tokenId) internal virtual &#123; address owner = ownerOf(tokenId); require(msg.sender == owner, &quot;not owner of token&quot;); _approve(owner, address(0), tokenId); _balances[owner] -= 1; delete _owners[tokenId]; emit Transfer(owner, address(0), tokenId); &#125; // _checkOnERC721Received：函数，用于在 to 为合约的时候调用IERC721Receiver-onERC721Received, 以防 tokenId 被不小心转入黑洞。 function _checkOnERC721Received( address from, address to, uint tokenId, bytes memory _data ) private returns (bool) &#123; if (to.isContract()) &#123; return IERC721Receiver(to).onERC721Received( msg.sender, from, tokenId, _data ) == IERC721Receiver.onERC721Received.selector; &#125; else &#123; return true; &#125; &#125; /** * 实现IERC721Metadata的tokenURI函数，查询metadata。 */ function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123; require(_owners[tokenId] != address(0), &quot;Token Not Exist&quot;); string memory baseURI = _baseURI(); return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;; &#125; /** * 计算&#123;tokenURI&#125;的BaseURI，tokenURI就是把baseURI和tokenId拼接在一起，需要开发重写。 * BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ */ function _baseURI() internal view virtual returns (string memory) &#123; return &quot;&quot;; &#125;&#125; 利用 tokenId 来表示特定的非同质化代币 函数 balanceOf：返回某地址的NFT持有量balance。 ownerOf：返回某tokenId的主人owner。 transferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。 safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId safeTransferFrom：安全转账的重载函数，参数里面包含了data approve：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。 getApproved：查询tokenId被批准给了哪个地址。 setApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。 isApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。 事件 Transfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。 Approval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。 ApprovalForAll事件：在批量授权时释放，记录批量授权的发3出地址owner，被授权地址operator和授权与否的approved。 检测目标函数是否实现 ERC721Receiver 接口，实现这则说明拥有管理NFT的能力 1234567891011121314151617function _checkOnERC721Received( address from, address to, uint tokenId, bytes memory _data) private returns (bool) &#123; if (to.isContract()) &#123; return IERC721Receiver(to).onERC721Received( msg.sender, from, tokenId, _data ) == IERC721Receiver.onERC721Received.selector; &#125; else &#123; return true; &#125;&#125; ERC11551234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;https://github.com/AmazingAng/WTFSolidity/blob/main/34_ERC721/IERC165.sol&quot;;/** * @dev ERC1155标准的接口合约，实现了EIP1155的功能 * 详见：https://eips.ethereum.org/EIPS/eip-1155[EIP]. */interface IERC1155 is IERC165 &#123; /** * @dev 单类代币转账事件 * 当`value`个`id`种类的代币被`operator`从`from`转账到`to`时释放. */ event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value); /** * @dev 批量代币转账事件 * ids和values为转账的代币种类和数量数组 */ event TransferBatch( address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values ); /** * @dev 批量授权事件 * 当`account`将所有代币授权给`operator`时释放 */ event ApprovalForAll(address indexed account, address indexed operator, bool approved); /** * @dev 当`id`种类的代币的URI发生变化时释放，`value`为新的URI */ event URI(string value, uint256 indexed id); /** * @dev 持仓查询，返回`account`拥有的`id`种类的代币的持仓量 */ function balanceOf(address account, uint256 id) external view returns (uint256); /** * @dev 批量持仓查询，`accounts`和`ids`数组的长度要想等。 */ function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory); /** * @dev 批量授权，将调用者的代币授权给`operator`地址。 * 释放&#123;ApprovalForAll&#125;事件. */ function setApprovalForAll(address operator, bool approved) external; /** * @dev 批量授权查询，如果授权地址`operator`被`account`授权，则返回`true` * 见 &#123;setApprovalForAll&#125;函数. */ function isApprovedForAll(address account, address operator) external view returns (bool); /** * @dev 安全转账，将`amount`单位`id`种类的代币从`from`转账给`to`. * 释放&#123;TransferSingle&#125;事件. * 要求: * - 如果调用者不是`from`地址而是授权地址，则需要得到`from`的授权 * - `from`地址必须有足够的持仓 * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155Received`方法，并返回相应的值 */ function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes calldata data ) external; /** * @dev 批量安全转账 * 释放&#123;TransferBatch&#125;事件 * 要求： * - `ids`和`amounts`长度相等 * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155BatchReceived`方法，并返回相应的值 */ function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data ) external;&#125; 支持一个合约包含多种代币，在gamefi运用的比较多 事件 TransferSingle事件：单类代币转账事件，在单币种转账时释放。 TransferBatch事件：批量代币转账事件，在多币种转账时释放。 ApprovalForAll事件：批量授权事件，在批量授权时释放。 URI事件：元数据地址变更事件，在uri变化时释放。 函数 balanceOf()：单币种余额查询，返回account拥有的id种类的代币的持仓量。 balanceOfBatch()：多币种余额查询，查询的地址accounts数组和代币种类ids数组的长度要相等。 setApprovalForAll()：批量授权，将调用者的代币授权给operator地址。。 isApprovedForAll()：查询批量授权信息，如果授权地址operator被account授权，则返回true。 safeTransferFrom()：安全单币转账，将amount单位id种类的代币从from地址转账给to地址。如果to地址是合约，则会验证是否实现了onERC1155Received()接收函数。 safeBatchTransferFrom()：安全多币转账，与单币转账类似，只不过转账数量amounts和代币种类ids变为数组，且长度相等。如果to地址是合约，则会验证是否实现了onERC1155BatchReceived()接收函数。 与ERC721标准类似，为了避免代币被转入黑洞合约，ERC1155要求代币接收合约继承IERC1155Receiver并实现两个接收函数： onERC1155Received()：单币转账接收函数，接受ERC1155安全转账safeTransferFrom 需要实现并返回自己的选择器0xf23a6e61*或 bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))*。 onERC1155BatchReceived()：多币转账接收函数，接受ERC1155安全多币转账safeBatchTransferFrom 需要实现并返回自己的选择器0xbc197c81*或 bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))*。 RGBAtomico权益证明协议Casper ETH中使用的权益证明协议 有一个验证者Validator 需要投入一定的以太币来充当该角色 以50个区块为一个epoch 使用两阶段提交 每轮需要2&#x2F;3的验证者通过 需要交保证金才能成为验证者 如果没有完成它的职责，则会被扣除部分保证金 如果两边投票则没收全部保证金 系统协议EIP-2535 Diamonds 是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同","tags":["web3"],"categories":["Web3"]},{"path":"/2024/01/18/Note/区块链开发/基础/开发工具/","content":"RemixHardhatFoundry 本地开发测试 Phalcon Fork 协助开发测试 从主网fork一个测试网络出来，好处是测试时和主网环境一致"},{"title":"区块链安全","path":"/2024/01/18/Note/区块链开发/基础/区块链安全/","content":"安全代码安全 运算 注意溢出问题 注意类型转换问题 合约升级 代理合约中成员变量的个数、类型、顺序要与逻辑合约中的一致 逻辑合约中如果有修改代理合约中逻辑合约地址的方法时 需要有权限控制 部署时代理合约需要通过调用初始化方法来设置为owner 函数 构造函数 &#x2F; 初始化函数需要保证只能被执行一次 注意函数的可见范围 函数入参 参数注意不要是可以被外部调用修改成恶意的参数 例如跳过检查、间接调用其他方法 call和对象调用合约 通过合约对象调用合约报错了，调用方会回滚 通过call调用函数，需要根据实际情况处理失败的情况 create和cteate2联合部署a, b, c 合约，暗中修改c合约代码并部署在原来的地址上 a合约通过create2部署b合约，b合约通过create部署c合约 然后b，c合约调用自毁函数 然后b，c合约重新部署，此时c的代码是可以和原来不一样的 因为b自毁后重新部署其nonce值会重置，所以c还是部署在原来的地址上 起到欺诈的作用 常见漏洞 51%攻击 51%算力攻击：拥有了一半的算力 51%货币攻击：拥有了一半的投票权和决定权 双花攻击 日蚀攻击 孤立节点，恶意节点通过操控该节点可以接收和联系到的节点实现 恶意节点需要有足够的带宽资源才能发动日蚀攻击 如果该恶意节点拥有40%算力，它可以将比特币网络拆分为两个分区，然后在两个分区中都发起51%攻击 如果恶意者只有网络带宽资源而没有算力，依然可以实现双花攻击 预言机攻击 矿池过度套利，过度闪电贷 链桥攻击 自治管理攻击 先跑攻击 利用更高的gas费来使交易更快的执行 权限管理漏洞 退款恶意 接受退款的合约在其receive或者fallback函数中写了恶意消耗gas的代码，使其他合约退款或转账失败 常见攻击 数学溢出 solidity8.0通过安全数学和自动检测 使用openzeppelin中的安全数学库 链上随机数攻击 链上是无法生成真正的随机数，常见的生成方法都是经过哈希算法实现 这就有被攻击的可能，通过不断的修改生成哈希的变量直到生成满足条件的随机数 解决方法：可以通过commit review解决 提交承诺：每次生成随机数前，将生成随机数的参数发布到区块链上，供其他节点验证 验证：在一定时间内，其他节点对这个承诺进行验证 广播：验证结束后，生成对应的随机数并广播，其他节点可以继续验证，防止参数被篡改 反馈：其他节点可以对这次承诺进行投票，通过则接受，反之则重新生成 重入攻击 通过fallback函数实现取款反调用操作，实现循环取币 解决方法 需要先把账户进行结算，再进行转账 使用重入锁，是一个函数修改器，用一个布尔值来防止重入 构造函数攻击 如果目标合约是通过检测bytecode是否为0来判断是否是用户时可以使用 在构造函数中写攻击方法，此时的bytecode为0，目标合约会认为是一个用户 注意事项 调用其他合约的方法时要小心被反调用 要记得写fallback函数 bytecode为0的情况 构造函数中 自毁后的合约 审计","tags":["web3"],"categories":["Web3"]},{"title":"Solidity","path":"/2024/01/18/Note/区块链开发/基础/Solidity/","content":"简介 用于智能合约开发，是面向对象的，强类型语言 单线程的，线程安全 使用时需要先声明Solidity的版本号 使用remix开发 https://remix.ethereum.org 智能合约是用来编写控制逻辑的 发布到区块链上的交易不一定都是成功执行的 为了扣除汽油费 智能合约可以获得的信息比较有限 因为每个节点的环境不同 智能合约编译后的字节码最大不超过24KB 格式12345678910111213//声明使用的solidity版本pragma solidity ^0.8.7;//合约contract A &#123; //状态变量\tstring public _string = &quot;Hello Web3!&quot;; //方法 function method1 public &#123; &#125;&#125; 关键字 关键字 作用 说明 constant 定义常量 gas费较低，不能修改 immutable 将变量定义为常量 gas费较低，需要赋值 indexed 事件中用于修饰变量，他们会保存在以太坊虚拟机日志的 topics 中 相当于检索事件的索引“键”，方便搜索，大小为固定的256比特，超过这个大小会自动计算成哈希存储 ether 以太坊代币单位 1 ether &#x3D; 10^18 wei memory 将变量存储在内存 只在函数调用期间存在，函数执行结束就会被清除，消耗gas少 Storage 变量会永久存储在区块链 函数之外声明的变量默认为storage类型，消耗gas多 calldata 将变量存储在函数之外 只能修饰输入参数，不能修改，函数间传递参数消耗gas少 public 公共的 修饰的状态变量会生成访问函数，修饰的函数可以被调用，内外部都可以调用 private 私有的 合约内部可用，不可被继承，比public节约gas external 外部的 只能通过外部读取函数，可以通过this调用但消耗gas，不可被继承 internal 内部的 合约内部可用，可以被继承 payable 付费 调用合约方法需要转账，标记的地址可以发送代币 view 可视的 可以读取状态变量，不能修改状态变量 pure 纯函数 不能读取状态变量，只能拥有局部变量，用户调用pure函数不用gas，合约调用需要支付gas virtual 可重写的 override 重写的 修饰 public 变量会重写该变量的 get 方法 returns 返回值 unchecked 不进行溢出检查 提高执行xiao’lü 值传递还是引用传递 函数外的storage状态变量赋值给函数内的storage变量时，修改函数内storage变量会影响函数外的状态变量 函数外的storage状态变量赋值给函数内的memory变量时，修改函数内memory变量不会影响函数外的状态变量 memory变量赋值给memory变量时，会影响原变量 变量赋值给storage变量，会创建独立的副本 数据变量 分为状态变量，局部变量和全局变量 状态变量：写在合约内函数外，如果没有提供修改的方法，那么它将永远的写在区块链上了 局部变量：写在函数内，调用函数时就会在虚拟机中产生 全局变量：内置变量 状态变量默认是internal 局部变量不能使用public 基本类型 数据类型 说明 备注 默认值 byte、bytes8、bytes32 固定长度，十六进制 0x00… int、uint、uint8、uint32、uint256 整型、正整数 int默认是256位的，uint256(-1)是最大值 0 bool 布尔 true &#x2F; false false string 字符串 消耗的gas多 “” 引用类型 数据类型 说明 备注 默认值 address 地址信息 十六进制 0x00地址 mapping 映射 &#x2F; hash表 不支持遍历，默认值0，key不能是结构体 type的默认值 bytes &#x2F; bytes1[] 字节数组 bytes的gas更便宜 动态：[] 静态：类型默认值 struct 结构体 创建对象不用new 成员默认值 enum 枚举 取值是取下标 第一个值 mapping 使用keccak256(key)当成offset存取value。 address 在以太坊中存储的是20字节的值，即uint160 address有成员变量，用payable修饰的地址多了 transfer 和 send 成员变量 方法 作用 备注 push 将元素插入数组尾部 动态数组才可以使用该方法 delete 将指定的元素变为默认值 delete 数组[下标]，不改变数组长度 pop 弹出数组尾部元素 数组的长度会-1 length 获取数组中元素个数 内置变量 变量名 含义 返回值 备注 msg.sender 调用者地址 address msg.value 获取payable的转账金额 msg.data 完整的调用信息calldata 前4个字节为函数选择器selector后面32个字节为输入的参数 msg.gas 剩余的gas msg.sig calldata的前4个字节 block.blockhash 获得最近256个区块的哈希值 block.coinbase 当前块矿工地址 block.diffculty 当前块难度 block.gaslimit 当前块gas限制 block.number 当前块区块号 uint block.timestamp 当前块时间戳 uint now 当前区块 gasleft 剩余的gas tx.gasprice 当前交易的gas价格 tx.origin 交易的发送者 msg.data一般包含2个部分 函数签名：函数名称 + 参数类型 &#x3D;&gt; hash 后取前四位bytes值 参数 流程控制12345678910111213141516171819202122232425262728function test() public &#123;\t//if-else\tif(条件判断)&#123; ... &#125;else if(条件判断)&#123; ... &#125;else&#123; ... &#125; //三元 条件判断 ? 返回值2 : 返回值2 //for循环 for(uint i = 0; i &lt; 10; i++)&#123; ... &#125; //while循环 while(i &lt; 10)&#123; ... &#125; //do-while循环 do&#123; ... &#125;while(i &lt; 10);&#125; 继承格式123456789101112131415contract A&#123; //需要子类重写的方法\tfunction a() virtual&#123; &#125;&#125;contract B is A&#123;\tfunction b()&#123; &#125; //重写父类方法 function a() override&#123; &#125;&#125; 修饰器也可以被继承，也可以重写 调用父合约 通过父合约名.函数名 通过super.函数名 会执行最远的父合约函数 父类构造函数需要传参的情况 可以在继承时在父类合约名后加上参数 1contract C is A(参数), B(参数)&#123;&#125; 可以在子类构造函数中传值 123contract C is A, B&#123;\tconstructor(参数1, 参数2) A(参数1) B(参数2)&#123;&#125;&#125; 多继承123456789101112contract a&#123;&#125;contract b is a&#123;&#125;contract c is a&#123;&#125;contract d is b, c&#123;&#125; 允许多继承，同名函数遵循最远继承规则 多继承时父类的顺序应该由高到低 多个父类都有的函数子类必须重写 重写多个父类都有的函数时，需要标注所有父合约的名字 override(父a，父b ...) 钻石继承 即父合约之间继承于同一个合约 使用super时每一个父合约的函数都会被执行，但顶级合约的函数只会执行一次 事件 是EVM上对日志的抽象 接口订阅和监听 存储数据，每个大概消耗2,000 gas，链上存储至少需要20,000 gas 是一种写入方法，所以不能被标记为view &#x2F; pure 事件的参数可以使用indexed标记，标记过的变量就可以在链外进行搜索查询 最多只能标记三个变量 用法 发生代币转移时 部署合约时返回合约地址 格式123456contract a &#123;\t//建立事件 event 事件名(类型 [indexed] 参数a ...) //使用 emit 激活 / 调用事件 emit 事件名&#125; 异常方法 方法 参数 作用 require 条件、异常描述 要求达到对应的条件，不会消耗gas并终止执行 assert 条件 断言，会消耗gas并继续执行 revert 直接抛出异常，不需要写条件，会消耗gas error 方法 自定义错误，可以携带信息，gas更低 自定义错误123456error thorized(类型 变量名);contract a &#123;\tfunction method() public &#123; revert thorized(变量); &#125;&#125; 节约gas费 能够在错误中定义变量，即抛出异常时可以抛出变量，报错信息详细 可以定义在合约中或者合约外 try-catch1234567try externalContract.f() [returns(类型 val)]&#123;\t// call成功的情况下 运行一些代码&#125; catch Error(string memory reason) &#123;\t// 捕获失败的 revert() 和 require()&#125; catch (bytes memory reason) &#123;\t// 捕获失败的 assert()&#125; 只有external 函数和构造函数可以使用 函数 函数默认会分配4个32字节的内存空间 函数可以重载，即同名不同参数 格式1234567891011121314151617pragma solidity ^0.8.7;contract A &#123; //构造函数 //在合约部署的时候会调用一次，是不会写到链上的 constructor()&#123; &#125;\t//普通函数\t//有返回值名的情况下函数体内可以不用写return语句，隐式返回 function 函数名 [修饰符...] [returns (类型 返回值1 [, 类型 返回值2, ...])] &#123; &#125; //fallback函数 fallback() external payable&#123;&#125; //receive函数 receive() external payable&#123;&#125;&#125; fallback 和 receive函数 都是作为兜底函数，即外部合约调用了不存在的函数时会调用这两个函数 调用时如果没传入数据会执行receive函数，前提是有定义receive函数，其他情况都是调用的fallback函数 需要payable、external关键字 receive和fallback不要写太多逻辑，因为如果是send&#x2F;transfer转账的话gas费只有2300，容易超出 内置函数 函数名 作用 参数 返回值 备注 creationCode 获取合约代码 type(合约).creationCode address 获取地址 balance 获取合约余额 transfer 转账 余额不足会报错，2300gas send 转账 bool 余额不足情况需要处理，2300gas call 转账 &#x2F; 调用合约 {[value:ETH数],[gas:gas数]}(转账金额 &#x2F; 二进制编码) bool,data 余额不足情况需要处理，支付全部gas callcode 转账 &#x2F; 调用合约 调用底层 delegatecall 转账 &#x2F; 调用合约 可以发gas，不能发eth staticall 静态调用 不会有写入操作 keccak256 将任何长度的数据转换为256位的哈希值 数据 bytes32 哈希算法 create 创建者地址，nonce 不准确 create2 预测合约部署后的地址 常数，创建者地址，盐，机器码 8.0新特性 abi.encode 压缩 bytes 会将每个参数用0填充到32字节，避免hash碰撞 abi.encodePacked 压缩 bytes 不定长的，有一定的压缩，如果参数是连续的字符串可能会出现hash碰撞 abi.decode 解码 bytes, (类型) abi.encodeWithSignature 获得二进制编码 函数(参数类型)，参数 第一个参数为函数签名 abi.encodeWithSelector 获得二进制编码 地址.函数.selector，参数 bytes ecrecover 获取消息的签名者地址 加密信息，签名 address selfdestruct 自毁合约 address &#x2F; 强制发送剩余代币 create和create2 create2创建合约时，目标智能合约的构造函数中不能有参数，create可以有参数 create函数不能创建已经创建过的地址，create2可以 因为nonce指的是交易数，之前部署过了nonce会增加 为什么会要创建已经创建过的地址呢，是因为合约自销毁后想重新部署到源地址就无法实现了 ABI函数 配合call实现底层调用 ether.js中实现合约的导入和函数调用 对不开源的合约进行反编译后，由于查不到函数名，所以可以通过abi进行调用 合约外函数 在8.0之后允许函数定义在合约外 修饰器1234567891011121314151617//权限校验modifier auth()&#123;\trequire( //检验逻辑，返回布尔类型\t);\t_;&#125;//代码复用(三明治结构)modifier rep([参数])&#123;\t//代码\t_;//被修饰函数中的代码\t//代码&#125;//对应的方法上添加修饰器即可生效function test() public auth rep([参数])&#123;\t&#125; 函数签名 &#x2F; 选择器 calldata中的前4个字节为函数选择器，是将函数经过哈希运算求得 bytes4(keccak256(&quot;函数名(参数类型)&quot;)) 有可能会发生冲突 可以使用透明代理和通用可升级代理解决 透明代理：代理合约的fallback函数限制管理员调用 通用可升级代理：将代理合约中的升级函数放在逻辑函数中 合约合约创建123456789101112131415//直接创建合约对象合约名 合约对象 = new 合约名();//间接创建合约对象address addr = new 合约名();合约名 合约对象 = 合约名(address);//工厂合约创建合约对象contract A&#123;&#125;contract AFactory&#123;\tA[] public As;\tfunction createA()&#123; As.push(new A()) &#125;&#125; 合约调用 外部用户直接调用合约 合约对象直接调用出现错误时，调用方会出现错误并回滚 外部用户间接调用合约 call 格式： 合约地址.call(abi.encodeWithSignature(&quot;函数名(参数类型1, 参数类型2...)&quot;, 参数1, 参数2...)) 调用合约出现错误时，调用方不会回滚 call通过触发fallback或receive函数发送ETH call调用会切换上下文，即进入到被调用的合约内部 不建议直接通过call来调用合约，因为主动权给了被调用的合约，有安全风险，推荐通过创建合约对象来调用 call零地址是会返回true的，需要注意 delegatecall 用法和call一致 调用合约出现错误时，调用方不会回滚 不会切换上下文，即还在调用方合约，即委托合约内部 不能使用value方法 delegatecall有安全隐患，需要保证当前合约和目标合约的状态变量类型相同，并且目标合约安全 delegatecall 调用目标合约时，调用者是调用delegatecall的源头 合约调用合约 需要有被调用合约的地址，且知道其函数信息才可以调用 需要传递代币的话就用 &#123;value: msg.value&#125; 12345678910111213141516171819contract A &#123;\tfunction testA1(address _B)&#123; B(_B).testB1() &#125; function testA2(B _B)&#123; _B.testB1() &#125; function testA3(address _B)&#123; B(_B).testB2&#123;value: msg.value&#125;() &#125;&#125;contract B &#123;\tfunction testB1()&#123; &#125; function testB2() payable&#123; &#125;&#125; 多重调用 将对合约的多次调用整合到一个交易中，再对合约进行调用 1234567891011121314151617181920212223242526272829contract TestMultiCall &#123; function test(uint _i) external pure returns (uint) &#123; return _i; &#125; function getData(uint _i) external pure returns (bytes memory) &#123; return abi.encodeWithSelector(this.test.selector, _i); &#125;&#125;//多重调用合约contract MultiCall &#123; function multiCall(address[] calldata targets, bytes[] calldata data) external view returns (bytes[] memory) &#123; require(targets.length == data.length, &quot;target length != data length&quot;); bytes[] memory results = new bytes[](data.length); for (uint i; i &lt; targets.length; i++) &#123; (bool success, bytes memory result) = targets[i].staticcall(data[i]); require(success, &quot;call failed&quot;); results[i] = result; &#125; return results; &#125;&#125; 多重委托调用 只能调用自身的合约方法，即如果调用他人的合约即无法使用 注意在合约调用中不要重复计算主币数量，或者让多重委托调用合约不能接受主币 代理合约 为了解决合约的更新问题，因为链上代码不可变和数据迁移的费用昂贵 委托调用不会改变逻辑合约中的值，改变的是代理合约的值，即使用逻辑合约的逻辑 代理模式将合约数据和逻辑分开，分别保存在不同合约中 代理合约Proxy 存储所有相关的变量、逻辑合约的地址 需要有一个修改代理合约地址的方法 代理合约也需要定义和逻辑合约完全一样的变量（类型 &#x2F; 顺序 &#x2F; 名称），在这些变量之后可以定义独有的变量 逻辑合约Logic 存储所有的函数，通过delegatecall执行 需要有一个实现迁移数据的方法 不用写构造函数，用一个初始化函数替代 抽象合约 合约用abstract 修饰，合约中至少有一个没有被实现的函数，该函数需要标注virtual 接口合约 不清楚目标合约的代码的具体信息，但知道其函数名称参数返回值等等，就可以通过接口合约调用 不能有状态变量、构造函数 只能继承接口合约，所有函数都得标注 external 类似模拟了一个目标合约 12345678910111213141516//目标合约contract TargetContract&#123;\t//具体细节不明\tfunction A()&#123; //详细代码 &#125;&#125;//接口合约interface ITargetContract&#123;\tfunction A()&#123;&#125;;&#125;contract Test&#123;\tfunction test(address _TargetContract)&#123; ITargetContract(_TargetContract).A(); &#125;&#125; 库合约 提取复用性强的代码作为库合约以便复用 格式 123library a&#123;\t//函数&#125; 特点 不能存在状态变量 不能够继承或被继承 不能接收以太币 不可以被销毁 一般会将函数定义为 internal 使用 使用 using 库合约 for 类型 使该类型可以直接调用库合约方法 使用 库合约名.函数 常用库合约 String：将uint256转换为String Address：判断某个地址是否为合约地址 Create2：更安全的使用Create2 EVM opcode Arrays：跟数组相关的库函数 重入锁 防止函数被重复调用 使用函数修改器实现 时间锁 保护管理员权限，将操作排进队列中，经过一段时间后执行 代币锁 可以把合约中的代币锁仓一段时间，受益人在锁仓期满后才可以取走代币 异常处理 合约执行具有原子性，发生异常时消耗的汽油费不会退回 常见错误情况 汽油费不够 出现异常 内联汇编简介 解决solidity现有方法中无法实现的一些操作 使用内联汇编自由度更高，性能更强，节约gas费 格式为使用 assembly{} 代码块 批量操作适合使用内联汇编 因为EVM时基于栈的虚拟机，想要难道栈顶之外的数据比较困难，所以要使用内联汇编 可以获取合约的代码，并加载到bytes变量中 可以判断一个地址是合约地址还是用户地址 函数操作需要结合地址和数据 格式12345678910111213//汇编代码块assembly&#123;\t//通过let关键字来定义变量，作用域只在当前大括号中\tlet a := 1;\t//for循环\tfor&#123;let i := 0&#125; lt(i, x) &#123;i := add(i ,1)&#125;&#123; //循环体\t&#125;\t//if\tif slt(x, 0)&#123; //。。。 &#125;&#125; 方法 算术和逻辑操作： add：将栈上的两个元素相加。 sub：从栈上的第二个元素中减去第一个元素。 mul：将栈上的两个元素相乘。 div：将栈上的第二个元素除以第一个元素（整数除法）。 sdiv：带符号的整数除法。 mod：取模运算。 smod：带符号的取模运算。 addmod：(x + y) mod z，加法后取模。 mulmod：(x * y) mod z，乘法后取模。 exp：指数运算。 signextend：符号扩展。 比较和位操作： lt、gt、slt、sgt、eq：比较栈上的两个元素，分别对应小于、大于、带符号小于、带符号大于、等于。 iszero：如果栈顶元素为0，则返回1，否则返回0。 and、or、xor、not：位运算。 shiftleft、shiftright：位移操作。 内存和存储操作： mstore、mstore8：将值存储到内存中。 mload：从内存中加载z值 sstore：将值存储到合约存储中。 push、pop：栈操作，用于将值压入栈或从栈中弹出。 控制流： jump、jumpi：跳转到指定位置。 return：结束执行并返回结果。 revert：停止执行。 selfdestruct（原名为suicide）：销毁合约并发送资金。 栈操作： dup：复制栈顶元素。 swap：交换栈上的两个元素。 日志和事件： log0、log1、log2、log3、log4：生成日志事件，用于外部监听和分析。 系统操作： blockhash：获取指定区块的哈希。 coinbase：获取当前区块的矿工地址。 timestamp：获取当前区块的时间戳。 number：获取当前区块号。 difficulty：获取当前区块的难度。 gaslimit：获取当前区块的燃气上限。 origin：获取交易的发起者地址。 caller：获取当前函数的调用者地址。 callvalue：获取当前交易的金额（以wei为单位）。 calldataload、calldatasize、calldatacopy：访问输入数据。 codesize、codecopy：访问合约代码。 gasprice：获取当前交易的燃气价格。 extcodesize、extcodecopy：访问外部合约的代码。 returndatasize、returndatacopy：访问返回值数据。 8.0特性安全数学 SafeMath 提高安全的数学运算 自动检测溢出 Create2 加盐部署，可以获得合约部署出的合约地址 在内联汇编中才可以使用 1234567891011121314151617//使用solidity实现//_salt作为参数传入Contract A = new A&#123;salt: byte32(_salt)&#125;();//获取部署合约的地址function getAddress(address addr, uint _salt)public view returns(address)&#123;\tbytes memory bytecode = getCode(addr);\tbytes32 hash = keccak256(abi.encodePacked( //固定的1字节字符串 + he&#x27;yu地址 + 盐 + 待部署合约代码哈希 bytes1(0xff), address(this), _salt, keccak256(bytecode)\t));\treturn address(uin160(uint(hash)));&#125;//获取bytecodefunction getBytecode(address _owner) public pure returns (bytes memory) &#123;\tbytes memory bytecode = type(合约).creationCode;\treturn abi.encodePacked(bytecode, abi.encode(_owner));&#125; 123456789101112131415161718192021222324252627//使用内联汇编实现//获取地址中的代码function getCode(address _addr) public view returns (bytes memory)&#123;\tassembly&#123; //获取代码长度 let size := extcodesize(_addr) //分配一块足够大的内存空间 let codePtr := mload(0x40) //初始化为20，预留空间给代码长度和代码本身 mstore(codePtr, 0x20); let codeEnd := add(codePtr, 0x20) //把size存入该内存空间 mstore(add(codePtr, 0x10), size) // 获取代码并保存 extcodecopy(_addr, codePtr, size) // 更新代码结束位置 mstore(codeEnd, mload(codeEnd)) // 返回代码 return(codePtr, size) &#125;&#125;function deploy(bytes32 salt, address addr) public view returns (address pair)&#123;\tbytes memory bytecode = getCode(addr);\tassembly&#123; pair := create2(0, add(bytecode, 32), mload(bytecode), salt) &#125;&#125; 案例插入排序1234567891011function insertSort(uint[] memory a) public pure returns (uint[] memory) &#123; for(uint i = 1; i &lt; a.length; ++i)&#123; uint tmp = a[i]; uint j; for(j = i; j &gt; 0 &amp;&amp; a[j - 1] &gt; tmp; --j)&#123; a[j] = a[j-1]; &#125; a[j] = tmp; &#125; return a;&#125; 签名验证123456789101112131415161718192021222324252627282930313233343536contract Verify&#123; function verify(address _signer, string memory _message, bytes memory _sig) external pure returns(bool)&#123; //1. 将消息进行哈希 bytes32 msgHash = getMsgHash(_message); //2. 将哈希消息拼接上一段字符串进行二次哈希 bytes32 ethMsgHash = getEthMsgHash(msgHash); //3. 验证签名和签名者是否一致 return recover(ethMsgHash, _sig) == _signer; &#125; //哈希 function getMsgHash(string memory _message) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked(_message)); &#125; //二次hash function getEthMsgHash(bytes32 _message) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message: 32&quot;, _message )); &#125; //取得加密消息中的签名用户地址 function recover(bytes32 _msg, bytes memory _sig) public pure returns(address)&#123; (bytes32 r, bytes32 s, uint8 v) = _split(_sig); return ecrecover(_msg, v, r, s); &#125; //分割签名取出r, s, v function _split(bytes memory _sig) internal pure returns (bytes32 r, bytes32 s, uint8 v)&#123; //验证参数是否是65位的字符串 require(_sig.length == 65, &quot;invalid signature length!&quot;) //sig = r + s + v assembly&#123; r := mload(add(_sig, 32)) s := mload(add(_sig, 64)) v := byte(0, mload(add(_sig, 96))) &#125; &#125;&#125; 权限控制12345678910111213141516171819202122232425262728293031323334353637383940contract AccessControl&#123;\tevent GrantRole(bytes32 indexed role, address indexed account);\tevent RevokeRole(bytes32 indexed role, address indexed account);\t//角色映射集合\tmapping(bytes32 =&gt; mapping(address =&gt; bool)) public roles; //角色\tbytes32 private constant ADMIN = keccak256(abi.encodePacked(&quot;ADMIN&quot;));\tbytes32 private constant USER = keccak256(abi.encodePacked(&quot;USER&quot;)); //函数修饰器\tmodifier OnlyRole(bytes32 _role)&#123; require(roles[_role][msg.sender], &quot;Not Authorized!&quot;); _; &#125; //给合约部署者管理员权限 constructor()&#123; _grantRole(ADMIN, msg.sender); &#125; //升级角色-内部调用\tfunction _grantRole(bytes32 _role, address _account) internal &#123; roles[_role][_account] = true; emit GrantRole(_role, _account);\t&#125;\t//升级角色\tfunction grantRole(bytes32 _role, address _account) external OnlyRole(ADMIN)&#123; _grantRole(_role, _account);\t&#125; //撤销角色-内部调用\tfunction _revokeRole(bytes32 _role, address _account) internal &#123; roles[_role][_account] = false; emit RevokeRole(_role, _account);\t&#125;\t//撤销角色\tfunction revokeRole(bytes32 _role, address _account) external OnlyRole(ADMIN)&#123; _revokeRole(_role, _account);\t&#125;&#125; 多签钱包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108contract MultiSigWallet &#123; event Deposit(address indexed sender, uint amount);//收款事件 event Submit(uint indexed txId);//提交交易事件 event Approve(address indexed owner, uint indexed txId);//批准交易事件 event Revoke(address indexed owner，uint indexed txId);//撤销批准事件 event Execute(uint indexed txId);//交易执行事件 //拥有者列表 address[] public owners; //拥有者地址映射 mapping(address =&gt; bool) public isOwner; //交易确认数 uint public required; //交易结构 struct Transaction &#123; address to; uint value; bytes data; bool executed; &#125; //交易记录 Transaction[] public transactions; //同意交易的拥有者 mapping(uint =&gt; mapping(address =&gt; bool)) public approved; //设置持有者和交易确认数 constructor(address[] memory _owners, uint _required)&#123; require(_owners.length &gt; 0，&quot;owners required&quot;); require( _required &gt; 0 &amp;&amp; _required &lt;= owners.length, &quot;invalid required number of owners&quot; ); for (uint i; i &lt; owners.length; i++) &#123; address owner = _owners[il; require(owner != address(0)，&quot;invalidowner&quot;); require(!isOwner[owner]，&quot;owner is not unique&quot;); isOwner[owner] = true; owners.push(owner); &#125; required = required; &#125; //接受主币 receive() external payable&#123; emit Deposit(msg.sender, msg.value); &#125; modifier onlyOwner()&#123; require(isOwner[msg.sender], &quot;Not Owner!&quot;); _; &#125; modifier txExists(uint _txId)&#123; require(_txId &lt; transactions.length, &quot;Tx does not exist!&quot;); _; &#125; modifier notApproved(uint _txId)&#123; require(!approved[_txId][msg.sender], &quot;Tx already approved!&quot;); _; &#125; modifier notExecuted(uint _txId)&#123; require(!transactions[_txId].executed, &quot;Tx already executed!&quot;); _; &#125; //提交交易 function submit(address _to, uint _value, bytes calldata _data) external onlyOwner&#123; transactions.push(Transaction(&#123; to: to, value: value, data: data, executed: false &#125;)); emit Submit(transactions.length - 1); &#125; //批准交易 function approve(uint txId) external onlyOwner txExists( txId) notApproved( txId) notExecuted( txId) &#123; approved[ txId][msg.sender] = true; emit Approve(msg.sender, txId);\t&#125; //获取某个交易的批准数量 function _getApprovalCount(uint _txId) private view returns (uint count)&#123; for(uint i; i &lt; owners.length; i++) &#123; if (approved[_txId][owners[i]]) &#123; count += 1; &#125; &#125; &#125; //执行交易 function execute(uint txId) external txExists( txId) notExecuted( txId)&#123; require(_getApprovalCount(_txId) &gt;= required, &quot;approvals &lt; required&quot;); Transaction storage transaction = transactions[_txId]; transaction.executed = true; (bool success，) = transaction.to.call&#123;value: transaction.value&#125;(transaction.data); require(success，&quot;tx failed&quot;); emit Execute(_txId); &#125; //撤销批准 function revoke(uint _txId) external onlyOwner txExists( txId) notExecuted(_txId)&#123; require(approved[_txId][msg.sender],&quot;tx not approved&quot;); approved[_txId][msg.sender] = false; emit Revoke(msg.sender，_txId); &#125;&#125; 荷兰拍卖 1个NFT部署一个合约 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//随着时间价格越来越低//使用NFT标准ERC721contract DutchAuction is ERC721&#123;\tuint private constant DURATION = 7 days; //拍卖周期 IERC721 public immutable nft; //NFT对象 uint public immutable nftId; //NFT的ID address payable public immutable seller; //NFT售卖者 uint public immutable startingPrice; //起拍价 uint public immutable startAt; //竞拍时间 uint public immutable expiresAt; //结束时间 uint public immutable discountRate; //折损率 //通过构造函数给变量赋值 constructor(uint _startingPrice, uint _discountRate, address _nft, uint _nftId )&#123; seller = payable(msg.sender); startingPrice = _startingPrice; discountRate = _discountRate; startAt = block.timestamp; expiresAt = block.timestamp + DURATION; require( _startingPrice &gt;= _discountRate * DURATION, &quot;starting price &lt; discount&quot; ); nft = IERC721(_nft); nftId = _nftId; &#125; //获得NFT价格 function getPrice() public view returns (uint) &#123; uint timeElapsed = block.timestamp - startAt; uint discount = discountRate * timeElapsed; return startingPrice - discount; &#125; //购买NFT function buy() external payable &#123; require(block.timestamp &lt; expiresAt，&quot;auction expired&quot;); uint price = getPrice(); require(msg.value &gt;= price，&quot;ETH &lt; price&quot;); ntf.transferFrom(seller, msg.sender, nftId); //因为价格一直在变动，所以可能需要退差价 uint refund = msg.value - price; if (refund &gt; 0) &#123; payable(msg.sender).transfer(refund); &#125; selfdestruct(seller);\t&#125;&#125; 多个NFT部署一个合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;https://github.com/AmazingAng/WTFSolidity/blob/main/34_ERC721/ERC721.sol&quot;;contract DutchAuction is Ownable, ERC721 &#123; uint256 public constant COLLECTOIN_SIZE = 10000; // NFT总数 uint256 public constant AUCTION_START_PRICE = 1 ether; // 起拍价(最高价) uint256 public constant AUCTION_END_PRICE = 0.1 ether; // 结束价(最低价/地板价) uint256 public constant AUCTION_TIME = 10 minutes; // 拍卖时间，为了测试方便设为10分钟 uint256 public constant AUCTION_DROP_INTERVAL = 1 minutes; // 每过多久时间，价格衰减一次 uint256 public constant AUCTION_DROP_PER_STEP = (AUCTION_START_PRICE - AUCTION_END_PRICE) / (AUCTION_TIME / AUCTION_DROP_INTERVAL); // 每次价格衰减步长 uint256 public auctionStartTime; // 拍卖开始时间戳 string private _baseTokenURI; // metadata URI uint256[] private _allTokens; // 记录所有存在的tokenId constructor() ERC721(&quot;name&quot;,&quot;symbol&quot;) &#123; auctionStartTime = block.timestamp; &#125; //设置拍卖时间开始时间 function setAuctionStartTime(uint32 timestamp) external onlyOwner &#123; auctionStartTime = timestamp; &#125; // 获取拍卖实时价格 function getAuctionPrice() public view returns (uint256) &#123; if (block.timestamp &lt; auctionStartTime) &#123; return AUCTION_START_PRICE; &#125;else if (block.timestamp - auctionStartTime &gt;= AUCTION_TIME) &#123; return AUCTION_END_PRICE; &#125; else &#123; uint256 steps = (block.timestamp - auctionStartTime) / AUCTION_DROP_INTERVAL; return AUCTION_START_PRICE - (steps * AUCTION_DROP_PER_STEP); &#125; &#125; // 拍卖mint函数，quantity数量 // TODO 需要调整 function auctionMint(uint256 quantity) external payable&#123; // 建立local变量，减少gas花费 uint256 _saleStartTime = uint256(auctionStartTime); // 检查是否设置起拍时间，拍卖是否开始 require( _saleStartTime != 0 &amp;&amp; block.timestamp &gt;= _saleStartTime, &quot;sale has not started yet&quot; ); // 检查是否超过NFT上限 require( totalSupply() + quantity &lt;= COLLECTOIN_SIZE, &quot;not enough remaining reserved for auction to support desired mint amount&quot; ); // 计算mint成本 uint256 totalCost = getAuctionPrice() * quantity; // 检查用户是否支付足够ETH require(msg.value &gt;= totalCost, &quot;Need to send more ETH.&quot;); // Mint NFT for(uint256 i = 0; i &lt; quantity; i++) &#123; uint256 mintIndex = totalSupply(); _mint(msg.sender, mintIndex); _addTokenToAllTokensEnumeration(mintIndex); &#125; // 多余ETH退款 // TODO 加锁 if (msg.value &gt; totalCost) &#123; payable(msg.sender).transfer(msg.value - totalCost); &#125; &#125;&#125; 英式拍卖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768contract EnglishAuction &#123;\tevent Start();\tevent Bid(address indexed sender, uint amount);\tevent Withdraw(address indexed bidder, uint amount);\tIERC721 public immutable nft;\tuint public immutable nftId; address payable public immutable seller; uint32 public endAt; bool public started; bool public ended; address public highestBidder; uint public highestBid; mapping(address =&gt; uint) public bids; constructor(address _nft,uint _nftId,uint _startingBid)&#123; nft = IERC721(_nft); nftId = _nftId; seller = payable(msg.sender); highestBid = _startingBid; &#125; //开始拍卖 function start() external &#123; require(msg.sender == seller,&quot;not seller&quot;); require(!started,&quot;started&quot; ) ; started = true; endAt = uint32(block.timestamp + 60); nft,transferFrom(seller， address(this)， nftId); emit Start(); &#125; //竞拍 function bid() external payable &#123; require(started,&quot;not started&quot;); require(block.timestamp &lt; endAt，&quot;ended&quot;); require(msg.value &gt; highestBid, &quot;value &lt; highest bid&quot;); if (highestBidder != address(0)) &#123; bids[highestBidder] += highestBid; &#125; highestBid = msg.value; highestBidder = msg.sender; emit Bid(msg.sender， msg.value); &#125; //取回上一次竞拍的出价 function withdraw() external &#123; uint bal = bids[msg.sender]; bids[msg.sender] = 0; payable(msg.sender).transfer(bal); emit Withdraw(msg.sender，bal); &#125; //结束竞拍 function end() external &#123; require(started, &quot;not started&quot;); require(block.timestamp &gt;= endAt, &quot;not ended&quot;); require(!ended, &quot;ended&quot;); ended = true; if (highestBidder != address(0)) &#123; nft.safeTransferFrom(address(this), highestBidder, nftId); seller.transfer(highestBid); &#125; else &#123; nft.safeTransferFrom(address(this), seller, nftId); &#125; emit End(highestBidder, highestBid); &#125;&#125; 众筹合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112contract CrowdFund &#123; event Launch( uint id, address indexed creator, uint goal, uint32 startAt, uint32 endAt ); event Cancel(uint id); event Pledge(uint indexed id, address indexed caller, uint amount); event Unpledge(uint indexed id, address indexed caller, uint amount); event Claim(uint id); event Refund(uint id, address indexed caller, uint amount);\t//众筹结构体 struct Campaign &#123; address creator;\t//发起人 uint goal; //目标 uint pledged; //已经获得的众筹数量 uint32 startAt; //开始时间 uint32 endAt; //结束时间 bool claimed; //是否领取 &#125;\t//众筹使用的代币 IERC20 public immutable token; //众筹数 uint public count; //记录众筹 mapping(uint =&gt; Campaign) public campaigns; //记录某一次众筹参与用户和数额 mapping(uint =&gt; mapping(address =&gt; uint)) public pledgedAmount; constructor(address _token) &#123; token = IERC20(_token); &#125;\t//创建一个众筹 function launch(uint _goal, uint32 _startAt, uint32 _endAt) external &#123; require(_startAt &gt;= block.timestamp, &quot;start at &lt; now&quot;); require(_endAt &gt;= _startAt, &quot;end at &lt; start at&quot;); require(_endAt &lt;= block.timestamp + 90 days, &quot;end at &gt; max duration&quot;); count += 1; campaigns[count] = Campaign(&#123; creator: msg.sender, goal: _goal, pledged: 0, startAt: _startAt, endAt: _endAt, claimed: false &#125;); emit Launch(count, msg.sender, _goal, _startAt, _endAt); &#125;\t//取消一个众筹 function cancel(uint _id) external &#123; Campaign memory campaign = campaigns[_id]; require(campaign.creator == msg.sender, &quot;not creator&quot;); require(block.timestamp &lt; campaign.startAt, &quot;started&quot;); delete campaigns[_id]; emit Cancel(_id); &#125;\t//参与众筹 function pledge(uint _id, uint _amount) external &#123; Campaign storage campaign = campaigns[_id]; require(block.timestamp &gt;= campaign.startAt, &quot;not started&quot;); require(block.timestamp &lt;= campaign.endAt, &quot;ended&quot;); campaign.pledged += _amount; pledgedAmount[_id][msg.sender] += _amount; token.transferFrom(msg.sender, address(this), _amount); emit Pledge(_id, msg.sender, _amount); &#125;\t//退出众筹 function unpledge(uint _id, uint _amount) external &#123; Campaign storage campaign = campaigns[_id]; require(block.timestamp &lt;= campaign.endAt, &quot;ended&quot;); campaign.pledged -= _amount; pledgedAmount[_id][msg.sender] -= _amount; token.transfer(msg.sender, _amount); emit Unpledge(_id, msg.sender, _amount); &#125;\t//众筹成功取出筹款 function claim(uint _id) external &#123; Campaign storage campaign = campaigns[_id]; require(campaign.creator == msg.sender, &quot;not creator&quot;); require(block.timestamp &gt; campaign.endAt, &quot;not ended&quot;); require(campaign.pledged &gt;= campaign.goal, &quot;pledged &lt; goal&quot;); require(!campaign.claimed, &quot;claimed&quot;); campaign.claimed = true; token.transfer(campaign.creator, campaign.pledged); emit Claim(_id); &#125;\t//众筹失败退回筹款 function refund(uint _id) external &#123; Campaign memory campaign = campaigns[_id]; require(block.timestamp &gt; campaign.endAt, &quot;not ended&quot;); require(campaign.pledged &lt; campaign.goal, &quot;pledged &gt;= goal&quot;); uint bal = pledgedAmount[_id][msg.sender]; pledgedAmount[_id][msg.sender] = 0; token.transfer(msg.sender, bal); emit Refund(_id, msg.sender, bal); &#125;&#125; 代币水龙头123456789101112131415161718192021222324252627contract Faucet &#123;\tuint256 public amountAllowed = 100; // 每次领 100 单位代币\taddress public tokenContract; // token合约地址\tmapping(address =&gt; bool) public requestedAddress; // 记录领取过代币的地址 // SendToken事件 event SendToken(address indexed Receiver, uint256 indexed Amount); // 部署时设定ERC2代币合约 constructor(address _tokenContract) &#123; tokenContract = _tokenContract; // set token contract &#125; // 用户领取代币函数 function requestTokens() external &#123; // 每个地址只能领一次 require(requestedAddress[msg.sender] == false, &quot;Can&#x27;t Request Multiple Times!&quot;); IERC20 token = IERC20(tokenContract); // 创建IERC20合约对象 require(token.balanceOf(address(this)) &gt;= amountAllowed, &quot;Faucet Empty!&quot;); // 水龙头空了 token.transfer(msg.sender, amountAllowed); // 发送token requestedAddress[msg.sender] = true; // 记录领取地址 emit SendToken(msg.sender, amountAllowed); // 释放SendToken事件 &#125;&#125; 空投123456789101112131415161718192021222324252627282930313233343536373839404142434445contract Airdrop &#123;\t// 数组求和函数 function getSum(uint256[] calldata _arr) public pure returns(uint sum) &#123; for(uint i = 0; i &lt; _arr.length; i++) sum = sum + _arr[i]; &#125; /// @notice 向多个地址转账ERC20代币，使用前需要先授权 function multiTransferToken( address _token, //转账的ERC20代币地址 address[] calldata _addresses,\t//空投地址数组 uint256[] calldata _amounts //代币数量数组（每个地址的空投数量） ) external &#123; require(_addresses.length == _amounts.length, &quot;Lengths of Addresses and Amounts NOT EQUAL&quot;); IERC20 token = IERC20(_token); // 声明IERC合约变量 uint _amountSum = getSum(_amounts); // 计算空投代币总量 // 检查：授权代币数量 &gt;= 空投代币总量 require(token.allowance(msg.sender, address(this)) &gt;= _amountSum, &quot;Need Approve ERC20 token&quot;); // for循环，利用transferFrom函数发送空投 for (uint8 i; i &lt; _addresses.length; i++) &#123; token.transferFrom(msg.sender, _addresses[i], _amounts[i]); &#125; &#125; /// 向多个地址转账ETH function multiTransferETH( address payable[] calldata _addresses, uint256[] calldata _amounts ) public payable &#123; require(_addresses.length == _amounts.length, &quot;Lengths of Addresses and Amounts NOT EQUAL&quot;); uint _amountSum = getSum(_amounts); // 计算空投ETH总量 // 检查转入ETH等于空投总量 require(msg.value == _amountSum, &quot;Transfer amount error&quot;); // for循环，利用transfer函数发送ETH for (uint256 i = 0; i &lt; _addresses.length; i++) &#123; _addresses[i].transfer(_amounts[i]); &#125; &#125;&#125; 白名单 通过MerkleTree发放 1234567891011121314151617181920212223242526272829303132333435contract MerkleTree is ERC721 &#123; bytes32 immutable public root; // Merkle树的根 mapping(address =&gt; bool) public mintedAddress; // 记录已经mint的地址 // 构造函数，初始化NFT合集的名称、代号、Merkle树的根 constructor(string memory name, string memory symbol, bytes32 merkleroot) ERC721(name, symbol) &#123; root = merkleroot; &#125; // 利用Merkle树验证地址并完成mint function mint(address account, uint256 tokenId, bytes32[] calldata proof) external &#123; require(_verify(_leaf(account), proof), &quot;Invalid merkle proof&quot;); // Merkle检验通过 require(!mintedAddress[account], &quot;Already minted!&quot;); // 地址没有mint过 _mint(account, tokenId); // mint mintedAddress[account] = true; // 记录mint过的地址 &#125; // 计算Merkle树叶子的哈希值 function _leaf(address account) internal pure returns (bytes32) &#123; return keccak256(abi.encodePacked(account)); &#125; // Merkle树验证，调用MerkleProof库的verify()函数 function _verify(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) &#123; return MerkleProof.verify(proof, root, leaf); &#125;&#125; 通过签名发放 12345678910111213141516171819202122232425262728293031323334353637383940contract SignatureNFT is ERC721 &#123; address immutable public signer; // 签名地址 mapping(address =&gt; bool) public mintedAddress; // 记录已经mint的地址 // 构造函数，初始化NFT合集的名称、代号、签名地址 constructor(string memory _name, string memory _symbol, address _signer) ERC721(_name, _symbol) &#123; signer = _signer; &#125; // 利用ECDSA验证签名并mint function mint(address _account, uint256 _tokenId, bytes memory _signature) external &#123; // 将_account和_tokenId打包消息 bytes32 _msgHash = getMessageHash(_account, _tokenId); // 计算以太坊签名消息 bytes32 _ethSignedMessageHash = ECDSA.toEthSignedMessageHash(_msgHash); // ECDSA检验通过 require(verify(_ethSignedMessageHash, _signature), &quot;Invalid signature&quot;); // 地址没有mint过 require(!mintedAddress[_account], &quot;Already minted!&quot;); // mint _mint(_account, _tokenId); // 记录mint过的地址 mintedAddress[_account] = true; &#125; function getMessageHash(address _account, uint256 _tokenId) public pure returns(bytes32)&#123; return keccak256(abi.encodePacked(_account, _tokenId)); &#125; // ECDSA验证，调用ECDSA库的verify()函数 function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool) &#123; return ECDSA.verify(_msgHash, _signature, signer); &#125;&#125; 交易所123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//contract NFTSwap is IERC721Receiver&#123; event List(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 price); event Purchase(address indexed buyer, address indexed nftAddr, uint256 indexed tokenId, uint256 price); event Revoke(address indexed seller, address indexed nftAddr, uint256 indexed tokenId); event Update(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 newPrice); fallback() external payable&#123;&#125; // 定义order结构体 struct Order&#123; address owner; uint256 price; &#125; // NFT地址 - NFT id - Order映射 mapping(address =&gt; mapping(uint256 =&gt; Order)) public nftList; // 实现&#123;IERC721Receiver&#125;的onERC721Received，能够接收ERC721代币 function onERC721Received( address operator, address from, uint tokenId, bytes calldata data ) external override returns (bytes4)&#123; return IERC721Receiver.onERC721Received.selector; &#125; // 挂单: 卖家上架NFT，合约地址为_nftAddr，tokenId为_tokenId，价格_price为以太坊（单位是wei） function list(address _nftAddr, uint256 _tokenId, uint256 _price) public&#123; IERC721 _nft = IERC721(_nftAddr); // 声明IERC721接口合约变量 require(_nft.getApproved(_tokenId) == address(this), &quot;Need Approval&quot;); // 合约得到授权 require(_price &gt; 0); // 价格大于0 Order storage _order = nftList[_nftAddr][_tokenId]; //设置NF持有人和价格 _order.owner = msg.sender; _order.price = _price; // 将NFT转账到合约 _nft.safeTransferFrom(msg.sender, address(this), _tokenId); // 释放List事件 emit List(msg.sender, _nftAddr, _tokenId, _price); &#125; // 撤单： 卖家取消挂单 function revoke(address _nftAddr, uint256 _tokenId) public &#123; Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order require(_order.owner == msg.sender, &quot;Not Owner&quot;); // 必须由持有人发起 // 声明IERC721接口合约变量 IERC721 _nft = IERC721(_nftAddr); require(_nft.ownerOf(_tokenId) == address(this), &quot;Invalid Order&quot;); // NFT在合约中 // 将NFT转给卖家 _nft.safeTransferFrom(address(this), msg.sender, _tokenId); delete nftList[_nftAddr][_tokenId]; // 删除order // 释放Revoke事件 emit Revoke(msg.sender, _nftAddr, _tokenId); &#125; // 调整价格: 卖家调整挂单价格 function update(address _nftAddr, uint256 _tokenId, uint256 _newPrice) public &#123; require(_newPrice &gt; 0, &quot;Invalid Price&quot;); // NFT价格大于0 Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order require(_order.owner == msg.sender, &quot;Not Owner&quot;); // 必须由持有人发起 // 声明IERC721接口合约变量 IERC721 _nft = IERC721(_nftAddr); require(_nft.ownerOf(_tokenId) == address(this), &quot;Invalid Order&quot;); // NFT在合约中 // 调整NFT价格 _order.price = _newPrice; // 释放Update事件 emit Update(msg.sender, _nftAddr, _tokenId, _newPrice); &#125; // 购买: 买家购买NFT，合约为_nftAddr，tokenId为_tokenId，调用函数时要附带ETH function purchase(address _nftAddr, uint256 _tokenId) payable public &#123; Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order require(_order.price &gt; 0, &quot;Invalid Price&quot;); // NFT价格大于0 require(msg.value &gt;= _order.price, &quot;Increase price&quot;); // 购买价格大于标价 // 声明IERC721接口合约变量 IERC721 _nft = IERC721(_nftAddr); require(_nft.ownerOf(_tokenId) == address(this), &quot;Invalid Order&quot;); // NFT在合约中 // 将NFT转给买家 _nft.safeTransferFrom(address(this), msg.sender, _tokenId); // 将ETH转给卖家，多余ETH给买家退款 payable(_order.owner).transfer(_order.price); payable(msg.sender).transfer(msg.value-_order.price); delete nftList[_nftAddr][_tokenId]; // 删除order // 释放Purchase事件 emit Purchase(msg.sender, _nftAddr, _tokenId, msg.value); &#125;&#125; 分账123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// SPDX-License-Identifier: MITpragma solidity ^0.8.4;/** * 分账合约 * @dev 这个合约会把收到的ETH按事先定好的份额分给几个账户。收到ETH会存在分账合约中，需要每个受益人调用release()函数来领取。 */contract PaymentSplit&#123; // 事件 event PayeeAdded(address account, uint256 shares); // 增加受益人事件 event PaymentReleased(address to, uint256 amount); // 受益人提款事件 event PaymentReceived(address from, uint256 amount); // 合约收款事件 uint256 public totalShares; // 总份额 uint256 public totalReleased; // 总支付 mapping(address =&gt; uint256) public shares; // 每个受益人的份额 mapping(address =&gt; uint256) public released; // 支付给每个受益人的金额 address[] public payees; // 受益人数组 /** * @dev 初始化受益人数组_payees和分账份额数组_shares * 数组长度不能为0，两个数组长度要相等。_shares中元素要大于0，_payees中地址不能为0地址且不能有重复地址 */ constructor(address[] memory _payees, uint256[] memory _shares) payable &#123; // 检查_payees和_shares数组长度相同，且不为0 require(_payees.length == _shares.length, &quot;PaymentSplitter: payees and shares length mismatch&quot;); require(_payees.length &gt; 0, &quot;PaymentSplitter: no payees&quot;); // 调用_addPayee，更新受益人地址payees、受益人份额shares和总份额totalShares for (uint256 i = 0; i &lt; _payees.length; i++) &#123; _addPayee(_payees[i], _shares[i]); &#125; &#125; /** * @dev 回调函数，收到ETH释放PaymentReceived事件 */ receive() external payable virtual &#123; emit PaymentReceived(msg.sender, msg.value); &#125; /** * @dev 为有效受益人地址_account分帐，相应的ETH直接发送到受益人地址。任何人都可以触发这个函数，但钱会打给account地址。 * 调用了releasable()函数。 */ function release(address payable _account) public virtual &#123; // account必须是有效受益人 require(shares[_account] &gt; 0, &quot;PaymentSplitter: account has no shares&quot;); // 计算account应得的eth uint256 payment = releasable(_account); // 应得的eth不能为0 require(payment != 0, &quot;PaymentSplitter: account is not due payment&quot;); // 更新总支付totalReleased和支付给每个受益人的金额released totalReleased += payment; released[_account] += payment; // 转账 _account.transfer(payment); emit PaymentReleased(_account, payment); &#125; /** * @dev 计算一个账户能够领取的eth。 * 调用了pendingPayment()函数。 */ function releasable(address _account) public view returns (uint256) &#123; // 计算分账合约总收入totalReceived uint256 totalReceived = address(this).balance + totalReleased; // 调用_pendingPayment计算account应得的ETH return pendingPayment(_account, totalReceived, released[_account]); &#125; /** * @dev 根据受益人地址`_account`, 分账合约总收入`_totalReceived`和该地址已领取的钱`_alreadyReleased`，计算该受益人现在应分的`ETH`。 */ function pendingPayment( address _account, uint256 _totalReceived, uint256 _alreadyReleased ) public view returns (uint256) &#123; // account应得的ETH = 总应得ETH - 已领到的ETH return (_totalReceived * shares[_account]) / totalShares - _alreadyReleased; &#125; /** * @dev 新增受益人_account以及对应的份额_accountShares。只能在构造器中被调用，不能修改。 */ function _addPayee(address _account, uint256 _accountShares) private &#123; // 检查_account不为0地址 require(_account != address(0), &quot;PaymentSplitter: account is the zero address&quot;); // 检查_accountShares不为0 require(_accountShares &gt; 0, &quot;PaymentSplitter: shares are 0&quot;); // 检查_account不重复 require(shares[_account] == 0, &quot;PaymentSplitter: account already has shares&quot;); // 更新payees，shares和totalShares payees.push(_account); shares[_account] = _accountShares; totalShares += _accountShares; // 释放增加受益人事件 emit PayeeAdded(_account, _accountShares); &#125; &#125; 线性释放代币1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556contract TokenVesting &#123; // 事件 event ERC20Released(address indexed token, uint256 amount); // 提币事件 // 状态变量 mapping(address =&gt; uint256) public erc20Released; // 代币地址-&gt;释放数量的映射，记录已经释放的代币 address public immutable beneficiary; // 受益人地址 uint256 public immutable start; // 起始时间戳 uint256 public immutable duration; // 归属期 /** * @dev 初始化受益人地址，释放周期(秒), 起始时间戳(当前区块链时间戳) */ constructor( address beneficiaryAddress, uint256 durationSeconds ) &#123; require(beneficiaryAddress != address(0), &quot;VestingWallet: beneficiary is zero address&quot;); beneficiary = beneficiaryAddress; start = block.timestamp; duration = durationSeconds; &#125; /** * @dev 受益人提取已释放的代币。 * 调用vestedAmount()函数计算可提取的代币数量，然后transfer给受益人。 * 释放 &#123;ERC20Released&#125; 事件. */ function release(address token) public &#123; // 调用vestedAmount()函数计算可提取的代币数量 uint256 releasable = vestedAmount(token, uint256(block.timestamp)) - erc20Released[token]; // 更新已释放代币数量 erc20Released[token] += releasable; // 转代币给受益人 emit ERC20Released(token, releasable); IERC20(token).transfer(beneficiary, releasable); &#125; /** * @dev 根据线性释放公式，计算已经释放的数量。开发者可以通过修改这个函数，自定义释放方式。 * @param token: 代币地址 * @param timestamp: 查询的时间戳 */ function vestedAmount(address token, uint256 timestamp) public view returns (uint256) &#123; // 合约里总共收到了多少代币（当前余额 + 已经提取） uint256 totalAllocation = IERC20(token).balanceOf(address(this)) + erc20Released[token]; // 根据线性释放公式，计算已经释放的数量 if (timestamp &lt; start) &#123; return 0; &#125; else if (timestamp &gt; start + duration) &#123; return totalAllocation; &#125; else &#123; return (totalAllocation * (timestamp - start)) / duration; &#125; &#125;&#125; 常用库 openzeelping MerkleProof 验证交易合法xing 运维编译 Gas优化 使用calldata 如果频繁修改状态变量的话，可以将修改记录后再一次性修改 循环判断条件使用 &amp;&amp; 拼接 用++替换+&#x3D;1 提前将变量提取出来，避免重复计算 当函数代码太多时可以将一些代码用单独的大括号划分出来，避免堆栈太深导致gas超额 部署 将代码完成后编译成bytecode，存在data域 发起一个转账交易到0x0地址，from地址为当前合约 转账金额为0 支付汽油费 合约的代码放在data域中 测试 估算gas费 remix在部署后执行函数调用会估算gas费 使用hardhat-gas-reporter插件生成gas报告","tags":["solidity"],"categories":["Web3"]},{"path":"/2024/01/18/Note/区块链开发/学习路线/","content":"区块链知识 【北京大学肖臻老师《区块链技术与应用》公开课】 https://www.bilibili.com/video/BV1Vt411X7JF/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【Web3新人公开课】 https://www.bilibili.com/video/BV1nt4y1N7xJ/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【Chainlink 预言机】 https://www.bilibili.com/video/BV1ed4y1N7Uv/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【Defi】 https://www.bilibili.com/video/BV1va41127DM/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【零知识证明】 https://www.bilibili.com/video/BV1wo4y1b7Ps/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 源码 比特币源码 【白皮书】https://zhuanlan.zhihu.com/p/649874047 【向经典致敬-15周年比特币白皮书中文版全文】https://zhuanlan.zhihu.com/p/664308886?utm_id=0 以太坊源码 【文档】https://ethereum.org/zh/developers/docs/intro-to-ethereum uniswap源码 【源码解读】https://www.bilibili.com/video/BV1hY4y1D7aD/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【白皮书】https://learnblockchain.cn/article/3055 usdt源码 Compound源码 Solidity 【油管-崔棉大师-solidity】https://www.youtube.com/watch?v=XlJwBTIps_I&amp;list=PLV16oVzL15MS-Zw8a3eEOADwbHhm8GrMp&amp;index=1 【智能合约内联汇编】 https://www.bilibili.com/video/BV1jK4y1X75h/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【WTF 文档】https://www.wtf.academy/ 【【2023最新版】学习 Solidity、区块链和智能合约开发：Chainlink融合AI的高效开发方法（中英字幕完整版）】 https://www.bilibili.com/video/BV1gz4y1i79f/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 前端 【react】 https://www.bilibili.com/video/BV1Tt4y1772f/?p=157&amp;share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【web3.js】 【ether.js】 项目 【油管NFT项目】https://youtu.be/S3jJtGYI18E?si=udwmWUGlwELwlUWN 【崔棉大师uniswap】https://youtu.be/38mVbslZpS4?si=anTRDzHpb8L1v-kA 【百度网盘项目】https://pan.baidu.com/disk/main?from=1026962h#/index?category=all&amp;path=%2FGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2F%E5%8C%BA%E5%9D%97%E9%93%BE&amp;fromNav=%2FGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2F%E5%8C%BA%E5%9D%97%E9%93%BE 资料 补充知识 【区块链安全实战修炼营】 https://www.bilibili.com/video/BV14u4y1H7ik/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【Rust】 https://www.bilibili.com/video/BV1hp4y1k7SV/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【【公开课】Solana区块链开发人员训练营：教你使用Rust + JavaScript 开发区块链】 https://www.bilibili.com/video/BV1da411G7Dj/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【Golang】 https://www.bilibili.com/video/BV1gf4y1r79E/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae 【Go相关书籍】https://zhuanlan.zhihu.com/p/613227155 【崔棉大师直播课】https://youtu.be/JLB5iZj9XGM?si=c4hdCskFMq1fDbMF 【【麻省理工】区块链与金钱】 https://www.bilibili.com/video/BV19q4y1B7RZ/?share_source=copy_web&amp;vd_source=8385103b7fab7d5a444c0ff2de51f0ae"},{"path":"/2024/01/18/Note/区块链开发/零知识证明/","content":"简介 不告知识细节但是能证明知识的正确性合理性，而且验证者不会得知知识细节 验证者向证明者提问，证明者不能提供有意义的信息 只需要关注验证的时间，不关心相关知识的证明时间 通过协议来证明证明者的理论 通过同态加密实现 盲签 A提供货币序列号，银行在不知道该序列号的情况下返回token，减少A的存款 A用序列号和token与B进行交易 B拿序列号和token给银行验证，银行验证通过，增加B的存款 零币和零钞 零币系统中存在基础币和零币，通过基础币和零币之间的来换转换，消除旧地址和新地址的关联性 零钞系统使用ZK-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工信息，区块链上不显示交易地址和金额，交易通过零知识证明进行 NP-Proof 例子 证明N是2个大质数的乘积 zk-snark 非交互性，证明者向验证者发送一次信息，两者无需交互 验证速度快，存储空间小 应用 Zcash 保护交易的具体信息，只要说明币的来源 是第一个广泛使用zk-snark的应用 Filecoin 规模最大 提供复制证明和时空证明 复制证明：初次完成存储交易，验证存储提供者存储了数据 时空证明：随着时间推移，证明存储提供者依然持续存储原始数据 应用ZkSync 基于zk-snarks 提供链上存储和链下存储 StarkWare 基于zk-stark 透明、扩展、抗量子攻击 Polygon 多种layer2扩容方案的聚合器 POS"},{"title":"DeFi","path":"/2024/01/18/Note/区块链开发/DeFi/","content":"简介 去中心化的金融交易所 中心化金融CeFi：受相关部门监管，严格遵守规定，客户没有隐私，信息不透明，客户权限有限 去中心化金融DeFi：资产由客户自己掌控，无监管，信任、低门槛、高效、高隐私性、可组合、可交互、透明、自动化、可编程、开发简单 可以链上借贷，闪电贷，超额抵押，快速套利（价格差） 提供稳定币，通过链下抵押资产、链上抵押资产、算法实现（波动较大）实现 架构身份DID身份 链上数据：转账、DeFi交互、NFT交易&#x2F;持有等一切链上行为 链下数据：Web2身份、POP、SBT 信息聚合协议：对链上原始数据、各种凭证数据的加工聚合 身份管理工具：钱包、域名 项目 Galxe：链上凭证基础平台 ENS：域名绑定，提供.eth后缀域名注册服务 SPACEID：域名绑定，提供.bnb后缀的域名注册服务，迭代速度和落地速度更快。链接Web2，建立个人品牌 Compound： Uniswap 提供代币质押兑换，需要付手续费 发行代币不用经过审查，只需要满足其代币标准和流通性标准即可 代币置换规则（恒定乘积做市商） 规则：A币 * B币 &#x3D; 常数 例子： 假设 1A &#x3D; 1000B，池子中有 10A，10000B，则常数为100,000 当用户想出售一个A换B时，池子中 A &#x3D; 10 + 1 &#x3D; 11 B &#x3D; 100,000 &#x2F; 11 ≈ 9090 即置换出 10000 - 9090 &#x3D; 910B 常数 &#x3D; 11 * 9090 &#x3D; 99,990 置换比例不是 1：1000的比例，是因为例子中币数量太少，导致兑换比例差距过大 大池子中这个比例就会很接近 1：1000的比例 V3和V2的区别 流动性提供方式：在Uniswap V2中，流动性提供者需要预先将资产锁定在合约中，这使得他们无法在合约之外使用这些资产。而在Uniswap V3中，流动性提供者可以通过智能合约将资产自由地借出或归还，而不需要锁定它们。这使得流动性提供者的操作更加灵活。 交易逻辑：Uniswap V3和V2的交易逻辑也有很大的不同。在V2中，交易是直接在AMM池中进行的，而V3则引入了一个新的交易类型——单币交易。这意味着在V3中，用户可以单独对某一个币进行交易，而不需要考虑AMM池中的其他币种。 费用结构：在费用结构上，V3也进行了优化。它引入了两种新的费用类型：交易费和滑点费。交易费是针对每笔交易收取的费用，而滑点费则是针对交易对价格波动收取的费用。这种费用结构可以更好地激励流动性提供者提供更好的交易体验。 虚拟流动性：为了提高资金利用率，但是只能在特定的价格区间做市，需要用户自己设置需要做市的价格区间 v2公式 x * y &#x3D; k（x是代币A的数量，y是代币B的数量，k是流动性代币的数量） y &#x3D; p * x（p是价格） p * x^2^ &#x3D; k x &#x3D; $\\sqrt{k &#x2F; p}$，y &#x3D; $\\sqrt{k * p}$ v3公式： （x + x_virtual) * （y + y_virtual）&#x3D; k x_virtual &#x3D; $\\sqrt{k &#x2F; p(最高价)}$ ，y_virtual &#x3D; $\\sqrt{k * p(最低价)}$","tags":["defi"],"categories":["Web3"]},{"path":"/2024/01/18/Note/区块链开发/fabric/","content":"简介 开源的企业级分布式超级账本 高度模块化、可配置，组件可插拔 支持多语言实现智能合约 环境搭建"},{"path":"/2024/01/18/Note/区块链开发/ChainLink/","content":"简介 为了解决链上智能合约无法获取区块链以外的数据的问题 可以获取随机数，比较安全 Data Feed"},{"title":"面试题","path":"/2024/01/18/Note/力扣/面试/","content":"字符串转整形12345678910111213141516171819202122232425262728293031323334public static int str2int(String s) &#123; // 判空 if (s == null || s.length() == 0) &#123; throw new IllegalArgumentException(&quot;Invalid input&quot;); &#125; // 定义结果变量 int result = 0; // 定义符号变量 int sign = 1; // 定义起始索引 int start = 0; // 如果字符串以负号开头，更新符号变量和起始索引 if (s.charAt(0) == &#x27;-&#x27;) &#123; sign = -1; start = 1; &#125; // 遍历字符串中的每个字符 for (int i = start; i &lt; s.length(); i++) &#123; // 获取当前字符 char c = s.charAt(i); // 判断是否是有效的数字字符 if (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; throw new IllegalArgumentException(&quot;Invalid input&quot;); &#125; // 将字符转换为整数值 int digit = c - &#x27;0&#x27;; // 根据位置计算权值 int power = (int) Math.pow(10, s.length() - i - 1); // 将数字乘以权值并累加到结果中 result += digit * power; &#125; // 返回结果乘以符号 return result * sign;&#125; 字符串A包括字符串B所有字符的最短子串 双指针+哈希表&#x2F;数组 滑动窗口+哈希表&#x2F;数组","tags":["数据结构和算法"],"categories":["力扣"]},{"title":"前置知识","path":"/2024/01/18/Note/力扣/基础知识/","content":"数据结构数组数组实现队列12345678/* 1.定义两个变量 front 和 rear - front 是队列第一个元素的前一位 - rear 是最后一个元素的位置 2.front == real 表示队列为空 3.real = maxSize - 1 表示队列已满 4.(rear + maxSize - front) % maxSize 队列中有效数据个数*/ 数组实现环形队列1234567/* - 需要两个变量 front 和 rear - front 是队列第一个元素 - rear 是最后一个元素的下一个位置 - front == real 表示队列为空 - (rear+1) % maxSize == front 表示队列已满*/ 链表跳表字符串KMP12345678910111213141516171819202122232425262728293031323334public int strStr(String haystack, String needle) &#123; int[] next = getNext(needle); int s1 = 0; int s2 = 0; while(s1 &lt; haystack.length() &amp;&amp; s2 &lt; needle.length())&#123; if(haystack.charAt(s1) == needle.charAt(s2))&#123; s1++; s2++; &#125;else if(next[s2] == -1)&#123; s1++; &#125;else&#123; s2 = next[s2]; &#125; &#125; return s2 == needle.length() ? s1-s2 : -1;&#125;public int[] getNext(String str)&#123; if(str.length() == 1) return new int[]&#123;-1&#125;; int[] res = new int[str.length()]; res[0] = -1; res[1] = 0; int i = 2; int cn = 0; while(i &lt; res.length)&#123; if(str.charAt(i - 1) == str.charAt(cn))&#123; res[i++] = ++cn; &#125;else if(cn &gt; 0)&#123; cn = res[cn]; &#125;else&#123; res[i++] = 0; &#125; &#125; return res; &#125; Manacher1234567891011121314151617181920212223242526272829303132333435363738//将字符串变为例如：#a#a#a# 的样子public static char[] manacherString(String str)&#123; char[] charArr = str.toCharArray(); char[] res = new char[str.length() * 2 + 1]; int index = 0; for(int i = 0; i != res.length; i++)&#123; res[i] = (i &amp; 1) == 0 ? &#x27;#&#x27; : charArr[index++]; &#125; return res;&#125;public static int maxLcpsLength(String s)&#123; if(s == null || s.length() == 0) return 0; //s变成 #s#s#s# char[] str = manacherString(s); //回文半径数组 int[] pArr = new int[str.length]; int R = -1; //回文右边界再往右一个位置 int C = -1; //中心 int max = Integer.MIN_VALUE; for(int i = 0; i != str.length; i++)&#123; //不用验的区域 pArr[i] = R &gt; i ? Math.min(pArr[2 * C - i], R - i) : 1; //从不用验的区域往外验 while(i + pArr[i] &lt; str.length &amp;&amp; i - pArr[i] &gt; -1)&#123; if(str[i + pArr[i]] == str[i - pArr[i]])&#123; pArr[i]++; &#125;else&#123; break; &#125; &#125; if(i + pArr[i] &gt; R)&#123; R = i + pArr[i]; C = i; &#125; max = Math.max(max, pArr[i]); &#125; return max - 1;&#125; 确定有限状态自动机 是一类计算模型，它包含一系列状态，可以同时具有多个状态 初始状态：一开始都是初始状态 接收状态：自动机处于某个[接受状态]，则判定该字符串[被接受]，反之[被拒绝] 当自动机处于接收状态时，然后依据[转移规则]，接送一个字符并转移到下一个状态，如果成功转移则说明改字符[被接受]，反之[被拒绝] 自动机可以看作是一种暴力枚举，它穷尽了每一种可能 自动机在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础 栈单调栈12345678/* - 找距离当前位置最近大的 - 栈内元素保证从大到小，数据依次进入栈 - 当前元素比栈内元素大时，依次弹出栈内元素 - 当前元素（右边最近大的） &gt; 栈内元素 &lt; 栈内元素上一位（左边最近大的） - 当所有元素遍历完了栈内还有元素时所有元素依次出栈 - 无 &gt; 栈内元素 &lt; 栈内元素上一位（左边最近大的） */ 二叉树遍历12345678910111213141516171819202122232425262728293031323334353637383940//前中后序遍历static List&lt;Integer&gt; result = new Arraylist&lt;&gt;();public void Iterater(TreeNode node)&#123; if(node == null ) return; //前序 result.add(node.val); if(node.left != null) Iterater(node.left); if(node.right != null) Iterater(node.right); //中序 if(node.left != null) Iterater(node.left); result.add(node.val); if(node.right != null) Iterater(node.right); //后序 if(node.left != null) Iterater(node.left); if(node.right != null) Iterater(node.right); result.add(node.val);&#125;//层序遍历public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.pop(); if (node != null) &#123; //根据前中后序变换位置即可 //前序：右左中 中序：右中左 后序：中右左 st.push(node);// 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点 if (node.left!=null) st.push(node.left); // 添加左节点 &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 node = st.pop(); // 重新取出栈中元素 result.add(node.val); // 加入到结果集 &#125; &#125; return result;&#125; 平衡二叉树搜索树哈夫曼树字典树（前缀树）B-tree12345/* 以一个5阶B树为例 - 一个节点最多有4个key，5个分支 - 当插入一个节点使当前节点大于4时，该节点会把当前节点的中间值向上分裂*/ B+tree12345678910/* - 所有数据都保存在叶子节点，叶子节点之间形成单向链表 - mysql中的B+tree叶子节点之间是双向环形链表 - 非叶子节点作为索引，不存储数据 - 以一个5阶B+树为例 - 一个节点最多有4个key，5个分支 - 当插入一个节点使当前节点大于4时，该节点会把当前节点的中间值向上分裂 - 分裂后叶子节点会保留分裂出去的节点值*/ 红黑树1234567/* - 每条路径上的黑色节点数要一致（黑色平衡） - 根节点是黑色的 - 新增的节点都是红色的 - 叶子节点都是null节点且为黑色 - 不存在连续的红色*/ 线索二叉树123456789/*Morris遍历 - 记录当前节点（cur） - 有左孩子 - 左孩子的最右孩子指向null，改指向当前节点，cur = cur.left - 左孩子的最右孩子指向当前节点，改指向null，cur = cur.right - 无左孩子，cur = cur.right - 时间复杂度：O(n)，空间复杂度：O(1)*/ 哈希表布隆过滤器12345/* - 用一个bitmap存放，多个hash算法计算 - 作用是检索一个元素是否在一个集合中 - 存在误判，误判率和数组大小和hash算法数有关*/ 图邻接表 点到能到的点的信息 邻接矩阵 每个点到其它点的距离 遍历BFS（宽度优先遍历）123public static void bfs(Node node)&#123; &#125; DFS（深度优先遍历）123public static void dfs(Node node)&#123; &#125; 并查集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//封装class Element&lt;V&gt;&#123; public V value; public Element(V value)&#123;this.value = value;&#125;&#125;//创建并查集class UnionFindSet&lt;V&gt;&#123; public HashMap&lt;V, Element&lt;V&gt;&gt; elementMap; public HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap; public HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap; //初始化操作 public UnionFindSet(List&lt;V&gt; list)&#123; elementMap = new HashMap&lt;&gt;(); fatherMap = new HashMap&lt;&gt;(); sizeMap = new HashMap&lt;&gt;(); for(V value : list)&#123; Element&lt;V&gt; element = new Element&lt;V&gt;(value); elementMap.put(value, element); fatherMap.put(element, element); sizeMap.put(element, 1); &#125; &#125; //防止找到父元素路径太长，每次查找都让路径上的元素直接z private Element&lt;V&gt; findHead(Element&lt;V&gt; element)&#123; Stack&lt;Element&lt;V&gt;&gt; path = new Stack&lt;&gt;(); while(element != fatherMap.get(elementMap))&#123; path.push(element); element = fatherMap.get(element); &#125; while(!path.isEmpty())&#123; fatherMap.put(path.pop(), element); &#125; return element; &#125; public boolean isSameSet(V a, V b)&#123; if(elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b))&#123; return findHead(elementMap.get(a)) == findHead(elementMap.get(b)); &#125; return false; &#125; public void union(V a, V b)&#123; if(elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b))&#123; Element&lt;V&gt; af = findHead(elementMap.get(a)); Element&lt;V&gt; bf = findHead(elementMap.get(b)); if(af != bf)&#123; Element&lt;V&gt; big = sizeMap.get(af) &gt;= sizeMap.get(af) ? af : bf; Element&lt;V&gt; small = big == af ? bf : af; fatherMap.put(small, big); sizeMap.put(big, sizeMap.get(af) + sizeMap.get(bf)); sizeMap.remove(small); &#125; &#125; &#125;&#125; 最短路径迪杰斯特拉算法12345678graph TD; 1--10--&gt;2; 2--50--&gt;3; 1--100--&gt;5; 1--30--&gt;4; 3--10--&gt;5; 4--20--&gt;3; 4--60--&gt;5; 迭代 S u dist[2] dist[3] dist[4] dist[5] 初始 {1} - 10 +∞ 30 100 1 {1，2} 2 10 60 30 100 2 {1，2，4} 4 10 50 30 90 3 {1，2，4，3} 3 10 50 30 60 4 {1，2，4，3，5} 5 10 50 30 60 123456789101112131415161718192021222324252627282930313233343536373839/* - 属于贪心算法 - 动态维护一个数组，记录到各个点的最短路径*/public static int[] dijkastra(int[][] graph, int startPointIndex) &#123; //集合s表示，已经求出最短路径的点的集合 boolean[] s = new boolean[graph.length]; //初始化s集合，只有起始点为true for (int i = 0; i &lt; graph.length; i++) &#123; s[i] = (i == startPointIndex); &#125; //最短路径集合 int[] dis = new int[graph.length]; //初始化，起始点到其他点的距离 for (int i = 0; i &lt; graph.length; i++) &#123; dis[i] = graph[startPointIndex][i]; &#125; //求到每个点的最短路径 for (int i = 0; i &lt; graph.length; i++) &#123; int tmpdis = max; int tmpindex = 0; for (int j = 0; j &lt; graph.length; j++) &#123; //不在s集合(未求出该点的最短路径) if (!s[j] &amp;&amp; dis[j] &lt; tmpdis) &#123; tmpdis = dis[j]; tmpindex = j; &#125; &#125; //dis中距离最短的点加入到s集合中 s[tmpindex] = true; //更新起点到其他点距离 for (int j = 0; j &lt; graph.length; j++) &#123; if (dis[j] &gt; dis[tmpindex] + graph[tmpindex][j]) &#123; dis[j] = dis[tmpindex] + graph[tmpindex][j]; &#125; &#125; &#125; return dis;//返回起点到每个点的最短路径长度&#125; 弗洛伊德算法（Floyd）123456789101112131415161718192021222324252627282930313233343536373839/* - 属于动态规划 - 直接算出距离 - 路径负权值也可以计算，但是要求图中不能有负环（）*/private int[][] floyd(Graph graph)&#123; int[][] dis = new int[graph.vertexNum][graph.vertexNum]; for (int i = 0; i &lt; graph.vertexNum; i++) &#123; for (int j = 0; j &lt; graph.vertexNum; j++) &#123; if (graph.graphMatrix[i][j] == 0)&#123; //是邻边将dis数组填充为权值最大值的2倍 dis[i][j] = Math.min(graph.maxWeight&lt;&lt;1, Integer.MAX_VALUE); &#125; else &#123; dis[i][j] = graph.graphMatrix[i][j]; &#125; if (i == j ) dis[i][j] = 0; &#125; &#125; for (int k = 0; k &lt; graph.vertexNum; k++) &#123;//中间顶点 for (int i = 0; i &lt; graph.vertexNum; i++) &#123;//i顶点 for (int j = 0; j &lt; graph.vertexNum; j++) &#123;//j 顶点 dis[i][j] = Math.min(dis[i][j], dis[i][k]+dis[k][j]); &#125; &#125; &#125; return dis;&#125; 最小生成树克鲁斯卡尔算法普利姆算法算法思想排序 冒泡排序插入排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*\t常规实现 - 从第一个元素开始，后一个数和前面的数比较找到合适的位置插入 - 类似打扑克时，抽起来的牌从左往右找合适的位置 - 在处理样本小且基本有序时效率最高*/public static void InsertSort(int[] arr)&#123; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0 ; j--) &#123; if(arr[j]&lt;arr[j-1]) swap(arr,j,j-1); &#125; &#125;&#125;/*\t二分插入\t- 就是在插入排序前用二分查找找最佳位置插入*/public static void midInsertSort(int[] arr)&#123; for(int i = 1;i &lt; arr.length;i++)&#123; //如果当前位置比前一位小 if(arr[i] &lt; arr[i-1])&#123; //保存当前位置的值 int temp = arr[i]; int left = 0; int right = i-1; int mid = 0; //二分查找，在 0 ~ i-1 范围寻找插入的位置 while(left &lt;= right)&#123; //在left到i-1位置上的中间值mid mid = left+(right-left)/2; //如果i位置上的值 等于 mid值，返回mid if(temp == arr[mid])&#123; left = mid; break; &#125; //以下都是缩小边界，直到找到合适的插入位置 else if(temp &lt; arr[mid])&#123; right = mid -1; &#125;else&#123; left = mid + 1; &#125; &#125; //如果二分查找在left 到 i-1 位置上都没有找到合适的插入位置 //即说明 i 的位置已经是合适的位置，不用进行插入操作 //插入排序（优化插入过程） for(int j = i-1;j &gt;= left;j--)&#123; arr[j+1]=arr[j]; &#125; arr[left] = temp; &#125; &#125;&#125;/*\t优化\t- 不用每次都要交换位置，整体后挪再插入*/public static void Optimization(int[] arr)&#123; for (int i = 1; i &lt; arr.length; i++) &#123; //tem保存i位置上的值 int tmp = arr[i]; //j用于保留插入的位置 int j; for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp;j--) arr[j] = arr[j-1]; arr[j] = tmp; &#125;&#125; 选择排序12345678910111213141516171819/*\t常规实现\t- 找最值的位置，和未排序的第一个位置交换\t- 基本不用，不稳定*/public static void SelectionSort(int[] arrays)&#123; for (int i = 0; i &lt; arrays.length-1; i++) &#123; int minPos = i; for (int j = i + 1; j &lt; arrays.length; j++) &#123; minPos = arrays[j] &lt; arrays[minPos] ? j : minPos; &#125; swap(arrays,i,minPos); &#125;&#125;/*\t优化\t- 同时找最大值和最小值\t- 在数组两端排序，时间减半，但时间复杂度还是O(N^2^)*/ 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/*\t快速排序是常规排序中速度最快的，快速排序最好的时间复杂度是 O(nLogn)，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来,所以快速排序通常比其他 Ο(nLogn) 算法更快，算法的思想也是比较简单直观的，就是给要排序的元素找合适的位置，把比这个元素大的放右边，小的放左边，就找到了该元素的位置，运用到了分治的思想，快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排，但它的平摊期望时间是 O(nLogn)，且 O(nLogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nLogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。*///普通递归处理public static void Sort(int[] arr, int left, int right) &#123; if (left &gt;= right) return; //将排序后的元素确定了的位置作为下一轮排序的边界 int pivot = move(arr, left, right); Sort(arr,left,pivot-1); Sort(arr,pivot+1,right);&#125;//基础实现public static int BasicSort(int[] arr, int leftBound, int rightBound) &#123; // 设定基准值（pivot） int pivot = leftBound; //小于基准值的区域的左指针 int left = pivot + 1; for (int i = left; i &lt;= rightBound; i++) &#123; //i位置的值小于基准值则移动到左边（left） if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, left); left++; &#125; &#125; swap(arr, pivot, left - 1); return left - 1;&#125;//双路快排public static int TwoRoadSort(int[] arr, int leftBound, int rightBound) &#123; //选数组最右作为基准值 int pivot = arr[rightBound]; int left = leftBound; int right = rightBound - 1; while (left &lt;= right) &#123; while (left &lt;= right &amp;&amp; arr[left] &lt;= pivot) left++; while (left &lt;= right &amp;&amp; arr[right] &gt; pivot) right--; if (left &lt; right) swap(arr, left, right); &#125; swap(arr, left, rightBound); return left;&#125;//三路快排public static int ThreeRoadSort(int[] arr, int leftBound, int rightBound) &#123; //使用了三数取中，放在数组最左作为基准值 int pivot = ThreeNumSelect(arr, leftBound, rightBound); //left指针用于记录小于基准值的区域 int left = leftBound //right指针用于记录大于基准值的区域 int right = rightBound; //mid指针用于记录等于基准值的区域，同时也是遍历的指针 int mid = left + 1; while(mid &lt;= right)&#123; if(arr[mid] &lt; pivot)&#123; //小于基准值的就放在小于区，即left+1的位置，然后left++； swap(arr,mid,left+1); left++; mid++; &#125;else if (arr[mid] &gt; pivot)&#123; //大于基准值的就放在right的位置上，right-- //此时mid位置上的不确定其大小，需要在下次循环时判断 swap(arr,mid,right); right--; &#125;else&#123; //等于基准值的则放在mid区，mid++即可 mid++; &#125; &#125; //最后交换基准和left的位置，当前left的值是小于基准值的 swap(arr,leftBound,left); //返回基准值的位置，作为递归调用的边界值 return left;&#125;/* 优化：主要通过优化基准的选择来达到算法的优化，处理降序数组时优化明显，1.采用三数选中，比如数组A = &#123;6，1，3，4，6，7，9 &#125;，取三数分别是：6，4，9 将他们排序后取6作为基准。2.当待排序的数列分割到一定大小时使用插入排序，插入排序在处理样本小且基本有序的数组时效率最高。3.使用尾递归，减少栈的深度，可以处理更多的数据。4.使用位运算优化交换过程*///三数取中public static void ThreeNumSelect(int[] arr, int low, int high) &#123; int mid = low + (high - low) / 2; //标记是否发生交换 int flag = 0; // 下面两步保证了arr[high]是最大的 if (arr[mid] &gt; arr[high]) &#123; swap(arr, mid, high); &#125; if (arr[low] &gt; arr[high]) &#123; swap(arr, low, high); &#125; // 将arr[low]和arr[mid]比较，让较小的在arr[low]的位置 if (arr[low] &gt; arr[mid]) &#123; flag = 1; swap(arr, mid, low); &#125; //数组中间值有发生交换位置的时候才执行 //将中间值移到数组d一位 if (flag == 1) swap(arr, mid, high);&#125;//优化插入if (left - right + 1 &lt; 10) &#123; InsertSort(arr); return;&#125;//尾递归while(left &lt; right) &#123; pivot = move(arr, left, right); Sort(arr, left, pivot - 1); left = pivot + 1;&#125;//位运算优化交换过程public static void swap(int[] arrays, int i, int j) &#123; //由于位运算如果操作同一块内存区域会将此区域变为0 if (i==j) return; arrays[i] = arrays[i] ^ arrays[j]; arrays[j] = arrays[i] ^ arrays[j]; arrays[i] = arrays[i] ^ arrays[j];&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445/*\t归并排序，顾名思义就是递归+合并，这是常见的一种实现，他还有一种基于循环的实现方式,归并排序重要的是他的合并，将数组分成两份，排序左右后合并,合并用双指针，比较俩边大小依次写入辅助数组,Java中的对象排序就是用的归并排序，对象排序要求稳定*///基础实现public static void Sort(int[] arr,int left,int right)&#123; if(left == right) return; int mid = left + (right - left)/2; //拆分数组 Sort(arr,left,mid); Sort(arr,mid+1,right); //归并数组 //优化：数组左右已经有序了就不用进行合并了 if(arr[mid] &lt; arr[mid+1]) return; merge(arr,left,mid+1,right);&#125;//合并的过程就是两个数组一一比较元素，小的放进临时数组public static void merge(int[] arr, int left, int right, int bound)&#123; //左半边数组的边界 int mid = right - 1; //创建一个辅助数组，作为形参传进来会更好 int[] tmp = new int[bound-left+1]; int i = left,j = right,k = 0; //比较元素大小 while(i&lt;=mid &amp;&amp; j &lt;= bound)&#123; if(arr[i] &lt;= arr[j])&#123; tmp[k++] = arr[i++]; &#125;else&#123; tmp[k++] = arr[j++]; &#125; &#125; //循环结束后左半边数组还有剩余元素，依次存入临时数组 while(i&lt;= mid) tmp[k++] = arr[i++]; //循环结束后右半边数组还有剩余元素，依次存入临时数组 while(j&lt;= bound) tmp[k++] = arr[j++]; //将排序结束后的临时数组复制到原数组 for (int l = 0; l &lt; tmp.length; l++) arr[left++] = tmp[l];&#125;//优化//1.当待排序的数列组分割到一定大小时使用插入排序if (left - right + 1 &lt; 10) &#123; InsertSort(arr); return;&#125;//2.待排序的数组左右已经有序了就不用进行合并了if(a[mid] &lt; a[mid+]) return; 基数排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*\t我们都知道，大部分的排序算法都是数与数之间做比较，而基数排序可以算是一种桶排序的推广，它不是基于元素之间的比较，而是利用数组下标，统计数组元素各个进位数出现的次数\t例如： 数组 A = &#123;312，006，211，125，032，020，203，523&#125; 数组 B 要先记录元素个位数各个数组出现的次数 第一次 B = &#123;1, 1, 2, 2, 0, 1, 1, 0, 0, 0&#125; 个位数 第二次 B = &#123;2, 2, 3, 1, 0, 0, 0, 0, 0, 0&#125; 十位数 第三次 B = &#123;3, 1, 2, 1, 0, 1, 0, 0, 0, 0&#125; 百位数 累加数组： 第一次 B = &#123;1, 2, 4, 6, 6, 7, 8, 8, 8, 8&#125; 个位数 第二次 B = &#123;2, 4, 7, 8, 8, 8, 8, 8, 8, 8&#125; 十位数 第三次 B = &#123;3, 4, 6, 7, 7, 8, 8, 8, 8, 8&#125; 百位数 累加数组的值代表对应下标的元素在数组中的位置\t基数排序适合元素范围比较均匀的数组,本质上是一种多关键字排序，属于分配式排序,属于稳定的算法,有低位优先和高位优先,低位优先是先排个位数,高位优先是先排最高位，是一种分治思想，用递归来做*///低位优先//maxlen用getMaxLen方法求得public static void Sort(int[] arr, int maxLen) &#123; //桶 int[] bucket = new int[10]; int[] result = new int[arr.length]; for (int i = 0; i &lt; maxLen; i++) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; int num = (int) (arr[j] / Math.pow(10, i)) % 10; //得出各个位数的数有几个 bucket[num]++; &#125; //累加数组 for (int k = 1; k &lt; bucket.length; k++) &#123; if (bucket[k] == 0) &#123; int left = k - 1; int right = k + 1; int Time = 0; while (bucket[left] == 0) &#123; left--; &#125; while(right&lt;bucket.length &amp;&amp; bucket[right] == 0)&#123; Time++; right++; &#125; if (right &lt; bucket.length) &#123; bucket[right] = bucket[right] + bucket[left]; &#125; k = k + Time; continue; &#125; bucket[k] = bucket[k - 1] + bucket[k]; &#125; //复制结果 for (int l = arr.length-1; l &gt;= 0; l--) &#123; int num = (int) (arr[l] / Math.pow(10, i)) % 10; result[bucket[num]-1] = arr[l]; bucket[num]--; &#125; Arrays.fill(bucket,0); for (int j = 0; j &lt; arr.length; j++) &#123; arr[j] = result[j]; &#125; &#125;&#125; //计算数组中元素最大位数public static int getMaxLen(int[] arr) &#123; int maxLen = 0; for (int i = 0; i &lt; arr.length; i++) &#123; String str = String.valueOf(arr[i]); if (str.length() &gt; maxLen) maxLen = str.length(); &#125; return maxLen;&#125; 计数排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/*\t我们都知道，大部分的排序算法都是数与数之间做比较，而计数排序可以算是一种桶排序的推广，它不是基于元素之间的比较，而是利用数组下标，统计对应下标的数字出现的次数\t例如： 数组 A = &#123;0，0，1，1，2，2，3，3&#125; 对应的数组 B = &#123;2，2，2，2&#125; ，因为每个数都出现了两次\t我们想将A从大到小排列，只需要将B 逆序遍历即可，B[3] 输出 2次，B[2] 输出两次，依次类推，即可得到 A的降序排列,计数排序适合量大但是范围小的数组，比如一个公司中员工的年龄，高考成绩排名等等,计数排序的时间复杂度：O(N+K)，空间复杂度：O(N+K)*///基础实现public static void Sort(int[] arr)&#123; //找出最大值和最小值,解决空间浪费 int min = 0,max = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&lt;min) min = arr[i]; if(arr[i]&gt;max) max = arr[i]; &#125; //算出每个数字出现的次数 int[] bulk = new int[max-min+1]; for (int i = 0; i &lt; arr.length; i++) &#123; bulk[arr[i]-min]++; &#125; //将统计好的数组赋值给原数组 int i = 0,k = 0; while(i&lt;bulk.length)&#123; if(bulk[i] &gt; 0 )&#123; arr[k++] = i; bulk[i]--; &#125; if(bulk[i] &lt;= 0) i++; &#125;&#125;/*\t优化： 常规写法会有一个问题，就是在对象排序时是不稳定的，下面是它的优化版本，但是优化版本执行速度会慢一丢丢，但是稳定了，实现稳\t定的方式是用一个累加数组，将辅助数组（即存放元素出现次数的那个数组）中的值累加起来\t例如： 辅助数组B：&#123;2，3，4，5&#125; 累加数组C：&#123;2，5，9，13&#125; 结果数组R：&#123;0，0，1，1，1，2，2，2，2，3，3，3，3，3&#125;\t累加数组的含义就是其下标在结果数组中最后出现的位置*/public static int[] Optimization(int[] arr)&#123; int[] result = new int[arr.length]; //算出最大最小值 int max = arr[0], min = arr[0]; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&gt;max) max = arr[i]; if(arr[i]&lt;min) min = arr[i]; &#125; //算出每个数字出现的次数 int[] bulk = new int[max-min+1]; for (int i = 0; i &lt; arr.length; i++) &#123; bulk[arr[i]-min]++; &#125; //算出累加数组，即每个数出现的最后一个下标 for (int i = 1; i &lt; bulk.length; i++) &#123; //如果当前下标对应的值为0 //则需要把他左边最近一次出现的值和右边最近出现的值相加 //并把指针指向右边最近出现值的位置 if(bulk[i] == 0)&#123; int left = i - 1; int right = i + 1; //用于记录右移的几次 int Time = 0; //这段左移可以删除，实际上没有执行到 //但是为了看的比较直观建议留着 while(bulk[left] == 0)&#123; left--; &#125; //右移找最近出现的值的下标 while(bulk[right] == 0)&#123; //右移一次就加一 Time++; right++; &#125; bulk[right] = bulk[right] + bulk[left]; //把下标移到右边最近出现的值，然后跳出本轮循环 i = i+Time; continue; &#125; //当前的值等于自己的值加前一个的值 bulk[i] = bulk[i-1] + bulk[i]; &#125; //结果复制到一个新数组再返回 for (int i = arr.length-1; i &gt;= 0; i--) &#123; result[ bulk[ arr[i]-min ]-1 ] = arr[i]; bulk[ arr[i]-min ]--; &#125; return result;&#125; 希尔排序123456789101112131415161718192021222324252627282930313233343536/*\t希尔排序又称为缩小增量排序，是对插入排序进行了改进,插入排序如果刚好要插入的位置较远，移动和比较的次数比较大,希尔排序在这上面进行了优化,在间隔大的时候移动的次数少，间隔小移动的距离近,具体实现就是把数组按gap分割，把gap上的数排序，再缩小gap再排序，直到gap=1,gap的取值一般选用 gap = 3n+1 较好*///基础实现public static void sort(int[] arr)&#123; int h = 1; while(h&lt;=arr.length/3)&#123; h = 3*h + 1; &#125; for (int gap = h; gap &gt; 0 ; gap = (gap-1)/3) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; gap-1 ; j-=gap) &#123; if(arr[j]&lt;arr[j-gap]) swap(arr,j,j-gap); &#125; &#125; &#125;&#125;//优化//把内部的插入排序优化public static void Optimization(int[] arr)&#123; int h =0; while(h&lt;=arr.length/3)&#123; h = 3 * h + 1; &#125; for (int gap = h; gap &gt; 0 ; gap=(gap-1)/3) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j; for ( j = i; j &gt; gap-1 &amp;&amp; arr[j - gap] &gt; tmp;j=j-gap)&#123; arr[j] = arr[j-gap]; &#125; arr[j] = tmp; &#125; &#125;&#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*\t堆结构是一颗完全二叉树，堆排序的规则是每个节点的值都要大于或等于它的左右孩子节点，称为大顶堆，反之则称为小顶堆,java中的优先级队列就是小根堆结构 (PriorityQueue&lt;T&gt;),将数组看出一个堆结构，使用堆排序，以下算法实现都是基于大顶堆,具体实现就是保证每一颗子树都是大顶堆，分治思想,把数组的最后一位和0位置上的值交换，然后自上而下排成大顶堆\t以 i 节点为例 左孩子节点下标：2 * i + 1 右孩子节点下标：2 * i + 2 父亲节点下标：(i-1)/2 大顶堆的条件是 arr[i] &gt;= arr[2 * i + 1] &gt;= arr[2 * i + 2]*///基础实现public static void heapSort(int[] arr)&#123; if(arr == null || arr.length &lt; 2) return; //排序成大顶堆 for (int i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr,i); &#125; //要处理的区域 int heapSize = arr.length; //交换第一个元素和最后一个元素，区域自减 swap(arr,0,--heapSize); while(heapSize &gt; 0)&#123; heapify(arr,0,heapSize); swap(arr,0, --heapSize); &#125;&#125;//排序大顶堆public static void heapInsert(int[] arr, int index)&#123; while(arr[index] &gt; arr[(index-1)/2])&#123; swap(arr,index,(index-1)/2); index = (index-1)/2; &#125;&#125;//保证每个子树都是大顶堆public static void heapify(int[] arr, int index, int heapSize)&#123; //左孩子的下标 int left = 2 * index + 1; //存在孩子时 while(left &lt; heapSize)&#123; int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; largest = arr[largest] &gt; arr[index] ? largest : index; if(largest == index) break; swap(arr,largest,index); index = largest; left = 2 * index + 1; &#125;&#125;/*\t拓展 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。 请选择一个合适的排序算法针对这个数据进行排序\t假设 k=7 先把0~k-1的元素变成一个小根堆 把0位置上的数取出，加入k位置的元素，变成小根堆，然后取出1位置上的数，加入k+1位置的元素变成小根堆，循环执行 最后数组就排好序了，k越小时间复杂度越小*/ 桶排序递归&#x2F;回溯 本质上是一种穷举，性能不高，可以通过剪枝的方式优化性能 贪心算法动态规划 Dynamic Programming，简称DP，本质上就是一个数组，表示每一步的情况 每一个状态一定是由上一个状态推导出来的，即 dp[n] 与 dp[n - 1] 有关系 主要用于解决 重叠子问题 找最优 步骤 确定dp数组 一维还是二维，下标的含义 确定递推公式 即找到当前状态和上一个状态的关系 初始化dp数组 确定遍历的顺序 举例推导","tags":["数据结构和算法"],"categories":["力扣"]},{"path":"/2024/01/18/Note/力扣/AI相关/","content":"最大矩形1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*\t题目： 给定一个仅包含 0 和 1 、 大小为 rows x cols 的二维二进制矩阵， 找出只包含 1 的最大矩形，并返回其面积\t思路： - 前缀和 + 单调栈 - 从上往下计算i到0层中列不为0的*///pythonclass Solution(object): def maximalRectangle(self, mat): n, m, ans = len(mat), len(mat[0]), 0 psum = [[0] * (m + 10) for _ in range(n + 10)] for i in range(1, n + 1): for j in range(1, m + 1): psum[i][j] = 0 if mat[i - 1][j - 1] == &#x27;0&#x27; else psum[i - 1][j] + 1 stk = [0] * (m + 10) he, ta = 0, 0 for i in range(1, n + 1): cur = psum[i] l, r = [0] * (m + 10), [m + 1] * (m + 10) he = ta = 0 for j in range(1, m + 1): while he &lt; ta and cur[stk[ta - 1]] &gt; cur[j]: ta -= 1 r[stk[ta]] = j stk[ta] = j ta += 1 he = ta = 0 for j in range(m, 0, -1): while he &lt; ta and cur[stk[ta - 1]] &gt; cur[j]: ta -= 1 l[stk[ta]] = j stk[ta] = j ta += 1 for j in range(1, m + 1): ans = max(ans, cur[j] * (r[j] - l[j] - 1)) return ans//javaclass Solution &#123; public int maximalRectangle(char[][] mat) &#123; int n = mat.length, m = mat[0].length, ans = 0; int[][] sum = new int[n + 10][m + 10]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; sum[i][j] = mat[i - 1][j - 1] == &#x27;0&#x27; ? 0 : sum[i - 1][j] + 1; &#125; &#125; int[] l = new int[m + 10], r = new int[m + 10]; for (int i = 1; i &lt;= n; i++) &#123; int[] cur = sum[i]; Arrays.fill(l, 0); Arrays.fill(r, m + 1); Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;(); for (int j = 1; j &lt;= m; j++) &#123; while (!d.isEmpty() &amp;&amp; cur[d.peekLast()] &gt; cur[j]) r[d.pollLast()] = j; d.addLast(j); &#125; d.clear(); for (int j = m; j &gt;= 1; j--) &#123; while (!d.isEmpty() &amp;&amp; cur[d.peekLast()] &gt; cur[j]) l[d.pollLast()] = j; d.addLast(j); &#125; for (int j = 1; j &lt;= m; j++) ans = Math.max(ans, cur[j] * (r[j] - l[j] - 1)); &#125; return ans; &#125;&#125;"},{"title":"力扣题","path":"/2024/01/18/Note/力扣/3/","content":"题目 备注 提示 解决次数 使数组中所有元素都等于零 2373 矩阵中的局部最大值 n x n，求每个3 x 3中最大值 暴力解 1 模板题目​ 思路- 实现1 数组中出现次数超过一半的数题目思路 因为这个数字出现次数超过数组长度的一半，所以目标数字的个数 减去其他数字的个数总和 一定是大于等于1的，当我们遇到目标值时+1，否则-1，当count为0时重新设置目标值，最后记录的位置一定是目标数字 实现123456789101112131415public static int solution(int[] arr)&#123; int count=0; int aws=0; for(int i=0;i&lt;arr.length;i++)&#123; if(count==0)&#123; aws=arr[i]; &#125; if(arr[i]==aws)&#123; count++; &#125; else &#123; count--; &#125; &#125; return aws;&#125; 使数组中所有元素都等于零题目​\t非负整数数组nums，选出一个正整数 x，x &lt;&#x3D; nums中最小的非零元素，然后 nums 中每个大于0的元素减去x，然后使所有元素都等于0， ​\t求最少操作次数 思路 与最大最小值有关，每次减去最小值，最 实现1 2373 矩阵中的局部最大值题目​\t给一个n x n 的矩阵，求每个 3 x 3 区域中的最大值，保存到一个新数组后返回 思路 暴力解 实现1234567891011121314public int[][] largestLocal(int[][] grid) &#123; int n = grid.length; int[][] res = new int[n - 2][n - 2]; for (int i = 0; i &lt; n - 2; i++) &#123; for (int j = 0; j &lt; n - 2; j++) &#123; for (int x = i; x &lt; i + 3; x++) &#123; for (int y = j; y &lt; j + 3; y++) &#123; res[i][j] = Math.max(res[i][j], grid[x][y]); &#125; &#125; &#125; &#125; return res;&#125; 石子游戏Ⅰ​\t偶数堆石子，排成一行 piles[i]，数组元素个数偶数，石子总数是奇数的，拿的多的赢 ​\t这种情况先手是必赢的 思路一 动态规划 实现12345678910111213public boolean stoneGame(int[] piles) &#123; int length = piles.length; int[] dp = new int[length]; for (int i = 0; i &lt; length; i++) &#123; dp[i] = piles[i]; &#125; for (int i = length - 2; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; length; j++) &#123; dp[j] = Math.max(piles[i] - dp[j], piles[j] - dp[j - 1]); &#125; &#125; return dp[length - 1] &gt; 0;&#125; Ⅱ​\t一堆石子（无奇偶限制），排成一行 piles[i]，数组元素个数偶数，石子总数是奇数的，拿的多的赢 思路 记忆化搜索 实现11234567891011121314151617public int stoneGameII(int[] piles) &#123; int len = piles.length, sum = 0; int[][] dp = new int[len][len + 1]; for (int i = len - 1; i &gt;= 0; i--) &#123; sum += piles[i]; for (int M = 1; M &lt;= len; M++) &#123; if (i + 2 * M &gt;= len) &#123; dp[i][M] = sum; &#125; else &#123; for (int x = 1; x &lt;= 2 * M; x++) &#123; dp[i][M] = Math.max(dp[i][M], sum - dp[i + x][Math.max(M, x)]); &#125; &#125; &#125; &#125; return dp[0][1];&#125; 实现2123456789101112131415161718192021222324252627282930class Solution &#123; public int stoneGameII(int[] piles) &#123; int[] prefixSum = new int[piles.length + 1]; for (int i = 0; i &lt; piles.length; i++) &#123; prefixSum[i + 1] = prefixSum[i] + piles[i]; &#125; Map&lt;Integer, Integer&gt; memo = new HashMap&lt;Integer, Integer&gt;(); return (prefixSum[piles.length] + dp(memo, piles, prefixSum, 0, 1)) / 2; &#125; public int dp(Map&lt;Integer, Integer&gt; memo, int[] piles, int[] prefixSum, int i, int m) &#123; if (i == piles.length) &#123; return 0; &#125; int key = i * 201 + m; if (!memo.containsKey(key)) &#123; int maxVal = Integer.MIN_VALUE; for (int x = 1; x &lt;= 2 * m; x++) &#123; if (i + x &gt; piles.length) &#123; break; &#125; maxVal = Math.max(maxVal, prefixSum[i + x] - prefixSum[i] - dp(memo, piles, prefixSum, i + x, Math.max(m, x))); &#125; memo.put(key, maxVal); &#125; return memo.get(key); &#125;&#125; 寻找两个正序数组的中位数 暴力解：合并两数组 双指针：对比两个数组值小的移动直到中位数位置 第k小数 k是中位数的位置 比较两数组k&#x2F;2位置上的值，排除值小的一方左侧的所有值 k &#x3D; k - 排除的值的个数，然后再比较k&#x2F;2位置上的值 直到k &#x3D; 1，即找到中位数 二分查找 通过两数组大小找到中位数位置 m+(n-m+1)&#x2F;2 在第一个数组上找分割线的位置，先假设在第一个数组的中间位置i 用中位数减去i得到第二个数组分割线位置 判断是否满足nums1[i-1]&lt;&#x3D;nums[j]或者nums2[j-1]&lt;&#x3D;nums1[i] 通过缩小区间查找 找到满足条件的i和j 得到分割线两边的值 判断两数组相加长度奇偶返回值 奇 返回左半边最大值 偶 返回左半边最大值和右半边最小值 解密方法 fi*&#x3D;*fi−1,其中 s[i]=0 fi*&#x3D;fi−2,其中 s[i−1]=0 并且 10⋅s[i−1]+s[i]≤26 边界条件：f0&#x3D;1 平方数之和 费马平方和公式 官解 123456for (long a = 0; a * a &lt;= c; a++) &#123; double b = Math.sqrt(c - a * a); if (b == (int) b) return true;&#125;return false; 三维形体的表面积 妙解 统计所有的立方体数量 统计有多少个面被其他面盖住，那么就在所有的立方体的表面积上减去被盖住的面数×2（因为盖住一个面会损失2个面）； 统计当前格子中因为堆叠而盖住了几个面 看看上一行同一列盖住了多少个面 看看同一行前一列盖住了几个面 控制CPU占用率曲线 画直线 利用Runtime对象的availableProcessors()方法获取CPU核心数量 使用Executors工厂类的newFixedThreadPool(线程数)方法创建ExecutorService线程池对象 newFixedThreadPool创建的是一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待 循环核心数的次数，使用线程池对象的execute()创建线程 使线程执行空语句一段时间，睡眠俩倍的时间 12while ((System.currentTimeMillis() - startTime) &lt;= busyTime) ; //执行空语句就是让cpu忙起来 最后关闭线程池 pool.shutdown(); 画曲线 位运算解决数组中出现奇次的数 出现奇数次数的数只有一个 把数组的每一个元素进行异或操作，最后的数就是奇次出现的数 出现奇数次数的数只有两个 把数组的每一个元素进行异或操作，最后的数是 a ^ b 把数组的每一个元素的某一位进行异或操作，最后的数是 a or b a这一位上是一b这一位上是0 (a ^ b) ^ (a or b) 的结果就是 a 除去字符串中重复的字母力扣链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*\t题目：\t- 给你一个字符串s，去除字符串中重复的字母\t- 需保证返回结果的字典序最小\t思路：\t- 利用栈来做，ASCII码小的在栈底\t- 创建一个数组保存字母最后出现的下标\t- 创建一个boolean数组判断当前字母是否在栈中\t- 用StringBuilder接收该栈元素*/ private static String removeDuplicateLetters(String s) &#123; //将字符串s转换为字符数组 char[] charArray = s.toCharArray(); //创建整型数组保存字母最后出现的下标 int[] lastIndex = new int[26]; int length = s.length(); //记录每个字母最后出现的位置的下标 for (int i = 0; i &lt;length; i++) &#123; lastIndex[charArray[i]-&#x27;a&#x27;] = i; &#125; //stack文档建议使用Deque来代替栈的使用 Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); //还需要一个boolean数组来判断当前字母是否在栈中 boolean[] vis = new boolean[26]; //遍历一遍输入字符 for (int i = 0; i &lt; length; i++) &#123; //如果当前遍历到的字符在栈中已经存在,就丢弃 if(vis[charArray[i]-&#x27;a&#x27;])&#123; continue; &#125; //栈顶字符ASCII码大于当前字符， /并且当前字符不是最后一次出现的字符时移除栈顶元素 while(!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; charArray[i] &amp;&amp; lastIndex[stack.peekLast()-&#x27;a&#x27;] &gt; i)&#123; Character top = stack.removeLast(); vis[top - &#x27;a&#x27;] = false; &#125; //当当前字符是最后一次出现且栈中没用该字符 stack.addLast(charArray[i]); vis[charArray[i]-&#x27;a&#x27;] = true; &#125; //用StringBuilder接收该栈元素 StringBuilder si = new StringBuilder(); for (Character c : stack) &#123; si.append(c); &#125; return si.toString(); &#125; 寻找旋转排序数组中的最小值最近的请求次数我能赢吗查找常用字符执行操作后字典序最小的字符串和为 k 的子数组从尾到头打印链表复杂链表的复制数组中重复的数字链表对折筹钱岛屿问题岛屿数量力扣 123456789101112131415161718192021222324//深度优先搜索public int numIslands(char[][] grid) &#123; if(grid == null || grid[0] == null) return 0; int N = grid.length; int M = grid[0].length; int res = 0; for(int i = 0; i &lt; N; ++i)&#123; for(int j = 0; j &lt; M; ++j)&#123; if(grid[i][j] == &#x27;1&#x27;)&#123; res++; infect(grid, i, j, N, M); &#125; &#125; &#125; return res;&#125;public void infect(char[][] grid, int i, int j, int N, int M)&#123; if(i &lt; 0 || i &gt;= N || j &lt; 0 || j &gt;= M || grid[i][j] != &#x27;1&#x27;)return; grid[i][j] = 2; infect(grid, i + 1, j, N, M); infect(grid, i - 1, j, N, M); infect(grid, i, j + 1, N, M); infect(grid, i, j - 1, N, M);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//并查集class UnionFind &#123; int count; int[] parent; int[] rank; public UnionFind(char[][] grid) &#123; count = 0; int m = grid.length; int n = grid[0].length; parent = new int[m * n]; rank = new int[m * n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; parent[i * n + j] = i * n + j; ++count; &#125; rank[i * n + j] = 0; &#125; &#125; &#125; public int find(int i) &#123; if (parent[i] != i) parent[i] = find(parent[i]); return parent[i]; &#125; public void union(int x, int y) &#123; int rootx = find(x); int rooty = find(y); if (rootx != rooty) &#123; if (rank[rootx] &gt; rank[rooty]) &#123; parent[rooty] = rootx; &#125; else if (rank[rootx] &lt; rank[rooty]) &#123; parent[rootx] = rooty; &#125; else &#123; parent[rooty] = rootx; rank[rootx] += 1; &#125; --count; &#125; &#125; public int getCount() &#123; return count; &#125;&#125;//调用并查集解决public int numIslands(char[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; int nr = grid.length; int nc = grid[0].length; int num_islands = 0; UnionFind uf = new UnionFind(grid); for (int r = 0; r &lt; nr; ++r) &#123; for (int c = 0; c &lt; nc; ++c) &#123; if (grid[r][c] == &#x27;1&#x27;) &#123; grid[r][c] = &#x27;0&#x27;; if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == &#x27;1&#x27;) &#123; uf.union(r * nc + c, (r-1) * nc + c); &#125; if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == &#x27;1&#x27;) &#123; uf.union(r * nc + c, (r+1) * nc + c); &#125; if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == &#x27;1&#x27;) &#123; uf.union(r * nc + c, r * nc + c - 1); &#125; if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == &#x27;1&#x27;) &#123; uf.union(r * nc + c, r * nc + c + 1); &#125; &#125; &#125; &#125; return uf.getCount();&#125; 岛屿的最大面积力扣 1234567891011121314151617181920212223242526public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; for(int i = 0; i &lt; grid.length; i++)&#123; for(int j = 0; j &lt; grid[0].length; j++)&#123; if(grid[i][j] == 1)&#123; int a = area(grid,i,j); res = Math.max(res, a); &#125; &#125; &#125; return res;&#125;public int area(int[][] grid, int row, int col)&#123; if(row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &lt; grid[0].length &amp;&amp; grid[row][col] == 1)&#123; grid[row][col] = 0; return 1+area(grid, row+1, col) +area(grid, row-1, col) +area(grid, row, col+1) +area(grid, row, col-1); &#125; return 0;&#125; 最大人工岛力扣 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static int largestIsland(int[][] grid) &#123; int areaFactor = 2; int res = 1; int row = grid.length; int col = grid[0].length; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; row; ++i)&#123; for(int j = 0; j &lt; col; ++j)&#123; if(grid[i][j] == 1)&#123; res = area(grid, i, j,areaFactor); map.put(areaFactor++, res); &#125; &#125; &#125; Set&lt;Integer&gt; change = null; for(int i = 0; i &lt; row; ++i)&#123; for(int j = 0; j &lt; col; ++j)&#123; if(grid[i][j] == 0)&#123; change = change(grid, i, j); &#125; if(change != null)&#123; int tmp = 1; for (Integer integer : change) &#123; tmp += map.get(integer); &#125; res = Math.max(tmp,res); change.clear(); &#125; &#125; &#125; return res;&#125;public static int area(int[][] grid, int row, int col,int areaFactor)&#123; if(row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &lt; grid[0].length &amp;&amp; grid[row][col] == 1)&#123; grid[row][col] = areaFactor; return 1+area(grid, row+1, col, areaFactor) +area(grid, row-1, col, areaFactor) +area(grid, row, col+1, areaFactor) +area(grid, row, col-1, areaFactor); &#125; return 0;&#125;public static Set&lt;Integer&gt; change(int[][] grid, int i, int j) &#123; int row = grid.length; int col = grid[0].length; Set&lt;Integer&gt; result = new HashSet&lt;&gt;(); if(i + 1 &lt; row &amp;&amp; grid[i+1][j] != 0) result.add(grid[i+1][j]); if(i - 1 &gt;= 0 &amp;&amp; grid[i-1][j] != 0) result.add(grid[i-1][j]); if(j + 1 &lt; col &amp;&amp; grid[i][j+1] != 0) result.add(grid[i][j+1]); if(j - 1 &gt;= 0 &amp;&amp; grid[i][j-1] != 0) result.add(grid[i][j-1]); return result;&#125; 岛屿的周长力扣 12345678910111213141516171819202122//暴力解public int islandPerimeter(int[][] grid) &#123; int res = 0; int row = grid.length; int col = grid[0].length; for(int i = 0; i &lt; row; ++i)&#123; for(int j = 0; j &lt; col; ++j)&#123; if(grid[i][j] == 1)&#123; res += 4; if(i + 1 &lt; row &amp;&amp; grid[i + 1][j] == 1) res--; if(i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == 1) res--; if(j + 1 &lt; col &amp;&amp; grid[i][j + 1] == 1) res--; if(j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == 1) res--; &#125; &#125; &#125; return res;&#125; LRU缓存力扣 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/*\t方法一：\t- 继承LinkedHashMap类，重写removeEldestE()方法*/class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123; private int capacity; public LRUCache(int capacity) &#123; super(capacity, 0.75F, true); this.capacity = capacity; &#125; public int get(int key) &#123; return super.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; super.put(key, value); &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123; return size() &gt; capacity; &#125;&#125;/*\t方法二：哈希表 + 双向链表\t- 使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样 - 在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。*/public class LRUCache &#123; //自定义结点 class DLinkedNode &#123; int key; int value; DLinkedNode prev; DLinkedNode next; public DLinkedNode() &#123;&#125; public DLinkedNode(int k, int v) &#123;key = k; value = v;&#125; &#125; private Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;Integer, DLinkedNode&gt;(); private int size; private int capacity; private DLinkedNode head, tail; //带参构造函数 public LRUCache(int capacity) &#123; this.size = 0; this.capacity = capacity; head = new DLinkedNode(); tail = new DLinkedNode(); //虚拟的头尾相连 head.next = tail; tail.prev = head; &#125; //得到队列中的元素，并将其加到队头 public int get(int key) &#123; DLinkedNode node = cache.get(key); if (node == null) &#123; return -1; &#125; moveToHead(node); return node.value; &#125; //将元素放入队列中 public void put(int key, int value) &#123; DLinkedNode node = cache.get(key); if (node == null) &#123; // 如果 key 不存在，创建一个新的节点 DLinkedNode newNode = new DLinkedNode(key, value); // 添加进哈希表 cache.put(key, newNode); // 添加至双向链表的头部 addToHead(newNode); ++size; if (size &gt; capacity) &#123; // 如果超出容量，删除双向链表的尾部节点 DLinkedNode tail = removeTail(); // 删除哈希表中对应的项 cache.remove(tail.key); --size; &#125; &#125; else &#123; // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部 node.value = value; moveToHead(node); &#125; &#125; //添加到头部 private void addToHead(DLinkedNode node) &#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &#125; //删除元素 private void removeNode(DLinkedNode node) &#123; node.prev.next = node.next; node.next.prev = node.prev; &#125; //移动到头部 private void moveToHead(DLinkedNode node) &#123; removeNode(node); addToHead(node); &#125; //s private DLinkedNode removeTail() &#123; DLinkedNode res = tail.prev; removeNode(res); return res; &#125;&#125; 约瑟夫问题 数组 把选中的数移动的数组末尾 链表 正则表达式匹配力扣 1234567891011121314151617181920212223242526272829303132333435363738394041/*\t- 要求p可以匹配s*/public boolean isMatch(String s, String p) &#123; char[] cs = s.toCharArray(); char[] cp = p.toCharArray(); // dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配 boolean[][] dp = new boolean[cs.length + 1][cp.length + 1]; // 初期值 // s为空，p为空，能匹配上 dp[0][0] = true; // p为空，s不为空，必为false(boolean数组默认值为false，无需处理) // s为空，p不为空，由于*可以匹配0个字符，所以有可能为true for (int j = 1; j &lt;= cp.length; j++) &#123; if (cp[j - 1] == &#x27;*&#x27;) &#123; dp[0][j] = dp[0][j - 2]; &#125; &#125; // 填格子 for (int i = 1; i &lt;= cs.length; i++) &#123; for (int j = 1; j &lt;= cp.length; j++) &#123; // 文本串和模式串末位字符能匹配上 if (cs[i - 1] == cp[j - 1] || cp[j - 1] == &#x27;.&#x27;) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else if (cp[j - 1] == &#x27;*&#x27;) &#123; // 模式串末位是* // 模式串*的前一个字符能够跟文本串的末位匹配上 if (cs[i - 1] == cp[j - 2] || cp[j - 2] == &#x27;.&#x27;) &#123; dp[i][j] = dp[i][j - 2] // *匹配0次的情况 || dp[i - 1][j]; // *匹配1次或多次的情况 &#125; else &#123; // 模式串*的前一个字符不能够跟文本串的末位匹配 dp[i][j] = dp[i][j - 2]; // *只能匹配0次 &#125; &#125; &#125; &#125; return dp[cs.length][cp.length];&#125; 装最多水的容器1234567891011121314/*\t- 给定一个数组，求其柱状图显示下能容纳的最多的水\t- 从外到内zhao\t- 本质是去掉不可能成为最大值的状态*/public int maxArea(int[] height) &#123; int i = 0, j = height.length - 1, res = 0; while(i &lt; j) &#123; res = height[i] &lt; height[j] ? Math.max(res, (j - i) * height[i++]): Math.max(res, (j - i) * height[j--]); &#125; return res;&#125; 删除k个数字后的最小值123456789101112131415161718192021/*\t*/publi void method(String num, int k)&#123; int newLength = num.length() - k; char[] stack; int top = 0; for(int i = 0; i , newLength; i++)&#123; char c = num.charAt(i); while(top &gt; 0 &amp;&amp; stack[top - 1] &gt; c &amp;&amp; k &gt; 0)&#123; top--; k--; &#125; stack[top++]; &#125; int offset = 0; while(offset &lt; newLength &amp;&amp; stack[offset] == &#x27;0&#x27;)&#123; offset++; &#125; return offset == newLength ? &quot;0&quot; : new String(stack, offset, newLength - offset);&#125; 柱状图中最大的矩形题目​\t给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 思路 单调栈 + 枚举高度 l[i] 代表位置 iii 左边最近一个比其小的位置 r[i] 代表位置 iii 右边最近一个比其小的位置 实现123456789101112131415161718192021222324252627282930class Solution &#123; public int largestRectangleArea(int[] hs) &#123; int n = hs.length; int[] l = new int[n], r = new int[n]; Arrays.fill(l, -1); Arrays.fill(r, n); Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; while (!d.isEmpty() &amp;&amp; hs[d.peekLast()] &gt; hs[i])&#123; r[d.pollLast()] = i; &#125; d.addLast(i); &#125; d.clear(); for (int i = n - 1; i &gt;= 0; i--) &#123; while (!d.isEmpty() &amp;&amp; hs[d.peekLast()] &gt; hs[i])&#123; l[d.pollLast()] = i; &#125; d.addLast(i); &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; int t = hs[i]; int a = l[i]; int b = r[i]; ans = Math.max(ans, (b - a - 1) * t); &#125; return ans; &#125;&#125;","tags":["数据结构和算法","力扣题"],"categories":["算法题"]},{"title":"左神","path":"/2024/01/18/Note/力扣/5/","content":"题目 提示 备注 两个链表的公共部分 排序，双指针，小的走，一样的输出 调整链表 Ⅰ：存数组，排序Ⅱ：拆成三个小链表，小等大 按一个基准，变成有序的 二叉树的后继节点 分X有右树和无右树讨论 找节点中序遍历中的后继节点 折纸问题 二叉树的后继节点题目思路 X有右树 后继为右树最左节点 X无右树 后继为第一个有左孩子的祖先 X是最有的节点，则后继为null 实现123456789101112131415161718192021222324public static Node getSuccessorNode(Node node)&#123; if(node == null) return node; if(node.right != null) &#123; //有右树 return getLeftMost(node.right); &#125;else&#123; //无右树 Node parent = node.parent; //找祖先，判断是否是其左孩子 while(parent != null &amp;&amp; parent.left != node)&#123; node = parent; parent = node.parent; &#125; return parent; &#125;&#125;//找最左节点public static Node getLeftMost(Node node)&#123; if(node == null) return node; while(node.left != null)&#123; node = node.left; &#125; return node;&#125; 折纸问题题目 将一张纸条，从上到下对折，会出现折痕，折痕分为凹凸折痕 求对折n次，从上到下打印每一个凹凸折痕 思路- 实现1234567//i是当前对折数，N是总对折数，down 是凹凸public static void print(int i, int N, boolean down)&#123; if(i &gt; N) return; print(i + 1, N, true); System.out.print(down ? &quot;凹&quot; : &quot;凸&quot;); print(i + 1, N, false);&#125; 平均值接近中位值题目 给定一个数组，里面的元素范围在0~s 请给每一个元素加上k 使得数组的平均值接近 s&#x2F;2 思路 思路一 k的范围是 -s &lt; k &lt; s 记录最好的差值 二分查找 优化- 排序数组- 求累加和数组- 能优化+k的过程 - 找+k后区间小于0或大于s的分界线 整体提升三倍性能 实现1234567891011121314151617181920212223242526272829303132333435363738#暴力解public static int method(int[] arr, int s)&#123; int left = -s; int right = s; int half = s/2; int abs = Integer.MAX_VALUE; int ans = Integer.MIN_VALUE; while(left &lt;= right)&#123; int mid = (left + right) / 2; int avg = avg(arr, s, mid); //先判断是否需要修改abs和ans int cha = avg - half; if(Math.abs(cha) &lt; abs || (Math.abs(cha) == abs &amp;&amp; mid &lt; ans))&#123; abs = cha; ans = mid; &#125; if(avg &gt;= half)&#123; r = k - 1; &#125;else&#123; l = k + 1; &#125; &#125; return ans;&#125;public static int avg(int[] arr, int s, int mid)&#123; int sum = 0; for(int num : arr)&#123; int v = num + mid; if(v &lt;= 0)&#123; sum += 0; &#125;else if(v &gt; s)&#123; sum += s; &#125;else&#123; sum += v; &#125; &#125; return sum / arr.length;&#125;","tags":["数据结构和算法","左神"],"categories":["算法题"]},{"title":"剑指offer","path":"/2024/01/18/Note/力扣/4/","content":"简单难度 题目 提示 备注 次数 回文链表 栈、快慢指针+栈、快慢指针+反转链表、递归、数组 1 反转链表 单双链表、反转一部分 1 024 反转链表单向链表1234567891011public ListNode reverseList(ListNode head) &#123; ListNode cur = head; ListNode pre = null; while(cur != null)&#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre;&#125; 双向链表1234567891011public void convert(Node head)&#123; Node cur = head; Node pre = head.pre; while(cur != null)&#123; Node next = cur.next; cur.next = pre; pre = cur; cur = next; &#125;&#125; 反转一部分12345678910111213141516public ListNode reverseBetween(ListNode head, int left, int right) &#123; ListNode dummyNode = new ListNode(-1); dummyNode.next = head; ListNode pre = dummyNode; for (int i = 0; i &lt; left - 1; i++) &#123; pre = pre.next; &#125; ListNode cur = pre.next; for (int i = 0; i &lt; right - left; i++) &#123; ListNode next = cur.next; cur.next = next.next; next.next = pre.next; pre.next = next; &#125; return dummyNode.next;&#125; 027 回文链表快慢指针 + 反转链表(前半部分)1234567891011121314151617181920public boolean isPalindrome(ListNode head) &#123;\tListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; ListNode next = slow.next; slow.next = head; head = slow; slow = next; &#125; if(fast != null)&#123; slow = slow.next; &#125; while (slow != null) &#123; if (slow.val != head.val) return false; slow = slow.next; head = head.next; &#125; return true;&#125; 递归1234567891011121314151617private ListNode frontPointer;private boolean recursivelyCheck(ListNode currentNode) &#123; if (currentNode != null) &#123; if (!recursivelyCheck(currentNode.next)) &#123; return false; &#125; if (currentNode.val != frontPointer.val) &#123; return false; &#125; frontPointer = frontPointer.next; &#125; return true;&#125;public boolean isPalindrome(ListNode head) &#123; frontPointer = head; return recursivelyCheck(head);&#125; 中等难度 题目 提示 备注 解决次数 二维数组中的查找 逆时针旋转看，二叉搜索树 找到二维数组中的值 1 重建二叉树 递归 给前中序，复原树 1 矩阵中的路径 回溯 + 剪枝，注意重复走的问题 二维数组中，拼单词 1 剪绳子问题 Ⅰ：动态规划 Ⅱ：结果很大需要考虑溢出问题 1 0 数值的整数次方 Ⅰ：x的n次幂 Ⅱ：n很大，以数组的形式给出 1 1 表示数值的字符 正则 判断字符串的内容是否是小数或数字 1 链表中环的入口节点 快慢指针，相遇时快指针回头然后一起走 重排链表 分两条链处理，前-中，后-中 a-b-c-d 变为 a-d-c-b 1 买卖股票问题 i-天数 k-次数 0没股票 1有股票 1.dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] &#x3D; Math.max(dp[i-1][1], -prices[i]); 2.dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1]+prices[i]); dp[i][1] &#x3D; Math.max(dp[i-1][1], dp[i-1][0]-prices[i]); 3 and 4.需要先给每个k赋初值 dp[i][k][0] &#x3D; Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] &#x3D; Math.max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]); 5.需要先给前两天赋初值 dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1]+prices[i]); dp[i][1] &#x3D; Math.max(dp[i-1][1], dp[i-2][0]-prices[i]); 6.dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1]+prices[i] - fee); dp[i][1] &#x3D; Math.max(dp[i-1][1], dp[i-1][0]-prices[i]); 一次交易 无限制 两次 k次 有冷冻期 有手续费 链表排序 归并排序 复制带随机指针的链表 Ⅰ：使用哈希表 Ⅱ：拼接在原链表后，a-a-b-b 除了next还有一个random指针 1 04 二维数组中的查找题目​\t在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 思路一 将矩阵逆时针旋转45°，会得到一个类似二叉搜索树 然后在左下角和右上角选择大的一个作为根节点 比根大就往右走，比根小就往左走 实现12345678910public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; int i = matrix.length - 1, j = 0; while(i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) &#123; if(matrix[i][j] &gt; target) i--; else if(matrix[i][j] &lt; target) j++; else return true; &#125; return false;&#125; 07 重建二叉树题目​\t输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 思路一 递归实现 preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7] 实现12345678910111213141516int[] preorder;HashMap&lt;Integer, Integer&gt; dic = new HashMap&lt;&gt;();public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; for(int i = 0; i &lt; inorder.length; i++) dic.put(inorder[i], i); return recur(0, 0, inorder.length - 1);&#125;TreeNode recur(int root, int left, int right) &#123; if(left &gt; right) return null; // 递归终止 TreeNode node = new TreeNode(preorder[root]); // 建立根节点 int i = dic.get(preorder[root]); // 划分根节点、左子树、右子树 node.left = recur(root + 1, left, i - 1); // 开启左子树递归 node.right = recur(root + i - left + 1, i + 1, right); // 开启右子树递归 return node; // 回溯返回根节点&#125; 12 矩阵中的路径题目​\t给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false ​\t单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用 思路 深度优先遍历DFS + 剪枝 需要考虑到重复走的情况，走过的字符标记为空字符十分巧妙，且在该次递归后还原，不影响其他递归。 实现12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; char[] words = word.toCharArray(); for(int i = 0; i &lt; board.length; i++) &#123; for(int j = 0; j &lt; board[0].length; j++) &#123; if(dfs(board, words, i, j, 0)) return true; &#125; &#125; return false;&#125;boolean dfs(char[][] board, char[] word, int i, int j, int k) &#123; if(i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word[k]) return false; //走到这里说明对应上了，下面判断是否长度一致 if(k == word.length - 1) return true; //优化，下次走到就不会在判断了，即标记为已走过 board[i][j] = &#x27;\\0&#x27;; //DFS 上下左右 boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1); //还原之前标记的元素，因为之后可能还会访问到（不同路径） board[i][j] = word[k]; return res;&#125; 14 剪绳子题目一​\t给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 思路 一般来说这种题肯定涉及数学，用公式会是最快的解法 动态规划 自己的实现1234567891011121314151617181920212223public int cuttingRope(int n) &#123; //最多分不会超过一半 int[] dp = new int[n/2]; //先从分成两部分开始讨论 int j = 2; //dp数组，默认一开始就是1 * n - 1 dp[0] = n - 1; for (int i = 1; i &lt; n / 2; i++, j++) &#123; //分为j份的第一份 int i1 = n / j; //其余剩下的再分，然后份数-1 dp[i] = Math.max(dp[i-1], i1 * cut((n - i1), j - 1)); &#125; return dp[n/2-1];&#125;//递归分剩下的每一份public int cut(int n, int part)&#123; if(part &lt;= 1)&#123; return n; &#125; int i = n / part; return i * cut(n - i, --part);&#125; 答案1234567public int cuttingRope(int n) &#123; if(n &lt;= 3) return n - 1; int a = n / 3, b = n % 3; if(b == 0) return (int)Math.pow(3, a); if(b == 1) return (int)Math.pow(3, a - 1) * 4; return (int)Math.pow(3, a) * 2;&#125; 题目二​\t在题目一的基础上，n的取值范围变大，所以需要考虑结果溢出的问题 123456789101112public int cuttingRope(int n) &#123; if(n &lt;= 3) return n - 1; int b = n % 3, p = 1000000007; long rem = 1, x = 3; for(int a = n / 3 - 1; a &gt; 0; a /= 2) &#123; if(a % 2 == 1) rem = (rem * x) % p; x = (x * x) % p; &#125; if(b == 0) return (int)(rem * 3 % p); if(b == 1) return (int)(rem * 4 % p); return (int)(rem * 6 % p); &#125; 16 数值的整数次方题目一​\t求X的n次幂 思路一 快速幂+递归实现 时间复杂度：O(LogN) 空间复杂度：O(LogN) 实现12345678910111213141516public double myPow(double x, long n) &#123; //n&lt;0则转换成正数，然后x取倒 return n &lt; 0 ? 1.0 / method(x,-n) : method(x,n);&#125;public static double method(double x, long n)&#123; //递归终止条件 if(n == 0) return 1.0; double t = method(x,n/2); //n是奇数时 if(n % 2 == 1)&#123; return t * t * x; //n是偶数时 &#125;else&#123; return t * t; &#125;&#125; 思路二 快速幂+迭代 时间复杂度：O(LogN) 空间复杂度：O(1) 实现12345678910111213141516171819202122public double myPow(double x, long n) &#123; //n&lt;0则转换成正数，然后x取倒 return n &lt; 0 ? 1.0 / method(x,-n) : method(x,n);&#125;public static double method(double x, long N)&#123; double ans = 1.0; // 贡献的初始值为 x double x_contribute = x; // 在对 N 进行二进制拆分的同时计算答案 while (N &gt; 0) &#123; if (N % 2 == 1) &#123; // 如果 N 二进制表示的最低位为1，那么需要计入贡献 ans *= x_contribute; &#125; // 将贡献不断地平方 x_contribute *= x_contribute; // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可 //除2相当于右移一位 N /= 2; &#125; return ans;&#125; 思路三实现1234567891011//更好理解public double pow(double x, long n) &#123;\tdouble res = 1.0; for(int i = n; i != 0; i /= 2)&#123; if(i % 2 != 0)&#123; res *= x; &#125; x *= x; &#125; return n &lt; 0 ? 1 / res : res;&#125; 题目二​\t超级次方，求 a^[b1,b2,b3] 思路 a^123^ &#x3D; ((a^1^)^10^ * a^2^)^10^ * a^3^ 实现1234567891011121314151617181920public static final int mod = 1337public int superPow(int a, int[] b) &#123; a %= mod; int res = pow(a, b[0]); for(int i = 1; i &lt; b.length; i++)&#123; res = pow(res, 10) * pow(a, b[i]) % mod; &#125; return res;&#125;public int pow(int x, int n)&#123; if(n == 0) return 1; int res = 1; for(int i = n; i != 0; i /= 2)&#123; if(i % 2 != 0)&#123; res =res * x % mod; &#125; x =x * x % mod; &#125; return res;&#125; 20 表示数值的字符题目​\t实现一个函数用来判断字符串是否表示数值（包括整数和小数） 思路一 正则 实现123public boolean isNumber(String s) &#123; return s.trim().matches(&quot;[+-]?((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+))([eE][+-]?\\\\d+)?&quot;);&#125; 思路二 确定有限自动机 实现12345678910111213141516171819202122232425public boolean isNumber(String s) &#123; Map[] states = &#123; new HashMap&lt;&gt;() &#123;&#123; put(&#x27; &#x27;, 0); put(&#x27;s&#x27;, 1); put(&#x27;d&#x27;, 2); put(&#x27;.&#x27;, 4); &#125;&#125;, // 0. new HashMap&lt;&gt;() &#123;&#123; put(&#x27;d&#x27;, 2); put(&#x27;.&#x27;, 4); &#125;&#125;, // 1. new HashMap&lt;&gt;() &#123;&#123; put(&#x27;d&#x27;, 2); put(&#x27;.&#x27;, 3); put(&#x27;e&#x27;, 5); put(&#x27; &#x27;, 8); &#125;&#125;, // 2. new HashMap&lt;&gt;() &#123;&#123; put(&#x27;d&#x27;, 3); put(&#x27;e&#x27;, 5); put(&#x27; &#x27;, 8); &#125;&#125;, // 3. new HashMap&lt;&gt;() &#123;&#123; put(&#x27;d&#x27;, 3); &#125;&#125;, // 4. new HashMap&lt;&gt;() &#123;&#123; put(&#x27;s&#x27;, 6); put(&#x27;d&#x27;, 7); &#125;&#125;, // 5. new HashMap&lt;&gt;() &#123;&#123; put(&#x27;d&#x27;, 7); &#125;&#125;, // 6. new HashMap&lt;&gt;() &#123;&#123; put(&#x27;d&#x27;, 7); put(&#x27; &#x27;, 8); &#125;&#125;, // 7. new HashMap&lt;&gt;() &#123;&#123; put(&#x27; &#x27;, 8); &#125;&#125; // 8. &#125;; int p = 0; char t; for(char c : s.toCharArray()) &#123; if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) t = &#x27;d&#x27;; else if(c == &#x27;+&#x27; || c == &#x27;-&#x27;) t = &#x27;s&#x27;; else if(c == &#x27;e&#x27; || c == &#x27;E&#x27;) t = &#x27;e&#x27;; else if(c == &#x27;.&#x27; || c == &#x27; &#x27;) t = c; else t = &#x27;?&#x27;; if(!states[p].containsKey(t)) return false; p = (int)states[p].get(t); &#125; return p == 2 || p == 3 || p == 7 || p == 8;&#125; 22 链表中环的入口节点题目思路一 快慢指针,快走2，慢走1 相等时其中一个回到头节点 快慢一起走1，相等时j是结果 实现12345678910111213141516public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (true) &#123; if (fast == null || fast.next == null) return null; fast = fast.next.next; slow = slow.next; if (fast == slow) break; &#125; fast = head; while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return fast;&#125; 26 重排链表题目​\ta-b-c-d-e-f-g 变为 a-g-b-f-c-e-d 思路 拆成两条链表处理，一条从前到中点，一条从后到中点，然后拼接即可 实现1234567891011121314151617181920212223242526272829public void reorderList(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; &#125; //中点 ListNode cur = slow.next; slow.next = null; ListNode pre = null; //反转链表作为新的链表 while(cur != null)&#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; //拼接两条链表 cur = head; while(cur != null &amp;&amp; pre != null)&#123; ListNode curNext = cur.next; ListNode preNext = pre.next; cur.next = pre; pre.next = curNext; cur = curNext; pre = preNext; &#125;&#125; 31 栈的压入、弹出序列题目 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 思路 模拟过程，可以使用额外的一个栈来实现，也可以直接使用参数提供的数组 实现123456789101112public boolean validateStackSequences(int[] pushed, int[] popped) &#123; int i = 0, j = 0; for (int e : pushed) &#123; pushed[i] = e; while (i &gt;= 0 &amp;&amp; pushed[i] == popped[j]) &#123; j++; i--; &#125; i++; &#125; return i == 0;&#125; 32 打印二叉树从上到下打印 层序遍历即可，使用队列 59 队列的最大值题目 模拟一个队列的操作，进栈、出栈、取最大值 思路 可以维护两个队列，一个维护正常队列，另一个维护队列中的最大值 63 买卖股票问题一次交易次数力扣 1234567891011121314151617181920212223242526272829303132//方法一public int maxProfit(int[] prices) &#123; int[][] dp = new int[prices.length][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); &#125; return dp[prices.length-1][0];&#125;//方法二public int maxProfit(int[] prices) &#123; int[] dp = new int[2]; dp[0] = 0; dp[1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; dp[0] = Math.max(dp[0], dp[1] + prices[i]); dp[1] = Math.max(dp[1], -prices[i]); &#125; return dp[0];&#125;//方法三public int maxProfit(int[] prices) &#123; int sell = 0; int buy = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; sell = Math.max(sell, buy + prices[i]); buy = Math.max(buy, -prices[i]); &#125; return sell;&#125; 没有交易次数限制力扣 1234567891011121314151617181920212223242526272829303132//方法一public int maxProfit(int[] prices) &#123; int[][] dp = new int[prices.length][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]); &#125; return dp[prices.length-1][0];&#125;//方法二public int maxProfit(int[] prices) &#123; int[] dp = new int[2]; dp[0] = 0; dp[1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; dp[0] = Math.max(dp[0], dp[1]+prices[i]); dp[1] = Math.max(dp[1], dp[0]-prices[i]); &#125; return dp[0];&#125;//方法三public int maxProfit(int[] prices) &#123; int sell = 0; int buy = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; sell = Math.max(sell, buy+prices[i]); buy = Math.max(buy, sell-prices[i]); &#125; return sell;&#125; 只能交易两次力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243//方法一public int maxProfit(int[] prices) &#123; int[][][] dp = new int[prices.length][3][2]; dp[0][2][0] = 0; dp[0][2][1] = -prices[0]; dp[0][1][0] = 0; dp[0][1][1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; for(int k = 2; k &gt; 0; k--)&#123; dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); //k-1 意思是买卖一次交易次数就要减一 dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125; &#125; return dp[prices.length-1][2][0];&#125;//方法二public int maxProfit(int[] prices) &#123; int[][] dp = new int[3][2]; dp[2][0] = 0; dp[2][1] = -prices[0]; dp[1][0] = 0; dp[1][1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; for(int k = 2; k &gt; 0; k--)&#123; dp[k][0] = Math.max(dp[k][0], dp[k][1] + prices[i]); dp[k][1] = Math.max(dp[k][1], dp[k-1][0] - prices[i]); &#125; &#125; return dp[2][0];&#125;//方法三public int maxProfit(int[] prices) &#123; int sellOne = 0, sellTwo = 0; int buyOne = -prices[0], buyTwo = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; sellTwo = Math.max(sellTwo, buyTwo + prices[i]); buyTwo = Math.max(buyTwo, sellOne - prices[i]); sellOne = Math.max(sellOne, buyOne + prices[i]); buyOne = Math.max(buyOne, -prices[i]); &#125; return sellTwo;&#125; 可以交易k次力扣 123456789101112131415161718192021222324252627282930313233343536/*\t思路：\t- 交易几次就在每轮循环中多循环k次*///方法一public int maxProfit(int k, int[] prices) &#123; if(prices.length == 0) return 0; int[][][] dp = new int[prices.length][k+1][2]; for(int i = k; i &gt; 0; i--)&#123; dp[0][i][0] = 0; dp[0][i][1] = -prices[0]; &#125; for(int i = 1; i &lt; prices.length; ++i)&#123; for(int j = k; j &gt; 0; j--)&#123; dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]); dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]); &#125; &#125; return dp[prices.length-1][k][0];&#125;//方法二public int maxProfit(int k, int[] prices) &#123; if(prices.length == 0) return 0; int[][] dp = new int[k+1][2]; for(int i = k; i &gt; 0; i--)&#123; dp[i][0] = 0; dp[i][1] = -prices[0]; &#125; for(int i = 1; i &lt; prices.length; ++i)&#123; for(int j = k; j &gt; 0; j--)&#123; dp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i]); dp[j][1] = Math.max(dp[j][1], dp[j-1][0] - prices[i]); &#125; &#125; return dp[k][0];&#125; 有冷冻期 力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//方法一public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt; 2) &#123; return 0; &#125; int[][] dp = new int[prices.length][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; dp[1][0] = Math.max(dp[0][0], dp[0][1]+prices[1]); dp[1][1] = Math.max(dp[0][1], dp[0][0]-prices[1]); for(int i = 2; i &lt; prices.length; ++i)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0]-prices[i]); &#125; return dp[prices.length-1][0];&#125;//方法二public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt; 2) &#123; return 0; &#125; int[] dp = new int[2]; dp[0] = 0; dp[1] = -prices[0]; int freeze = 0; for(int i = 1; i &lt; prices.length; ++i)&#123; int tmp = dp[0]; dp[0] = Math.max(dp[0], dp[1]+prices[i]); dp[1] = Math.max(dp[1], freeze - prices[i]); freeze = tmp; &#125; return dp[0];&#125;//方法三//freeze保存的是sell前一天的值，相当于dp[i-2][0];public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt; 2) &#123; return 0; &#125; int sell = 0; int buy = -prices[0]; int freeze = 0; for(int i = 1; i &lt; prices.length; ++i)&#123; int tmp = sell; sell = Math.max(sell, buy+prices[i]); buy = Math.max(buy, freeze - prices[i]); freeze = tmp; &#125; return sell;&#125; 有手续费力扣 1234567891011121314151617181920212223242526272829303132//方法一public int maxProfit(int[] prices, int fee) &#123; int[][] dp = new int[prices.length][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i] - fee); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]); &#125; return dp[prices.length-1][0];&#125;//方法二public int maxProfit(int[] prices, int fee) &#123; int[] dp = new int[2]; dp[0] = 0; dp[1] = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; dp[0] = Math.max(dp[0], dp[1]+prices[i] - fee); dp[1] = Math.max(dp[1], dp[0]-prices[i]); &#125; return dp[0];&#125;//方法三public int maxProfit(int[] prices, int fee) &#123; int sell = 0; int buy = -prices[0]; for(int i = 1; i &lt; prices.length; ++i)&#123; sell = Math.max(sell, buy+prices[i] - fee); buy = Math.max(buy, sell-prices[i]); &#125; return sell;&#125; 67 把字符串转换成整数思路 自动机 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int strToInt(String str) &#123; Automaton automaton = new Automaton(); int length = str.length(); for (int i = 0; i &lt; length; ++i) &#123; automaton.get(str.charAt(i)); &#125; return (int) (automaton.sign * automaton.ans); &#125;&#125;class Automaton&#123; //属性 int sign = 1; long ans = 0; String state = &quot;start&quot;; private Map&lt;String, String[]&gt; table = new HashMap&lt;String, String[]&gt;() &#123;&#123; put(&quot;start&quot;, new String[]&#123;&quot;start&quot;, &quot;signed&quot;, &quot;in_number&quot;, &quot;end&quot;&#125;); put(&quot;signed&quot;, new String[]&#123;&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;&#125;); put(&quot;in_number&quot;, new String[]&#123;&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;&#125;); put(&quot;end&quot;, new String[]&#123;&quot;end&quot;, &quot;end&quot;, &quot;end&quot;, &quot;end&quot;&#125;); &#125;&#125;; //提供方法 public void get(char c) &#123; state = table.get(state)[get_col(c)]; if (&quot;in_number&quot;.equals(state)) &#123; ans = ans * 10 + c - &#x27;0&#x27;; ans = sign == 1 ? Math.min(ans, (long) Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE); &#125; else if (&quot;signed&quot;.equals(state)) &#123; sign = c == &#x27;+&#x27; ? 1 : -1; &#125; &#125; //确定要转移的状态 private int get_col(char c) &#123; if (c == &#x27; &#x27;) &#123; return 0; &#125; if (c == &#x27;+&#x27; || c == &#x27;-&#x27;) &#123; return 1; &#125; if (Character.isDigit(c)) &#123; return 2; &#125; return 3; &#125;&#125; 77 链表排序题目 给链表排序 思路 归并排序 实现123456789101112131415161718192021222324252627282930313233343536public ListNode sortList(ListNode head) &#123; if(head == null || head.next == null) return head; // 第一步：将链表拆成两半 ListNode fast = head, slow = head, prev = head; while(fast != null &amp;&amp; fast.next != null) &#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; // 第二步：将两部分的链表分别排序 ListNode l1 = sortList(head); ListNode l2 = sortList(slow); // 第三步：合并两个有序链表 return merge(l1,l2);&#125;private ListNode merge(ListNode l1, ListNode l2) &#123; ListNode p = new ListNode(), l = p; while(l1 != null &amp;&amp; l2 != null) &#123; if(l1.val &lt; l2.val) &#123; p.next = l1; l1 = l1.next; &#125; else &#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if(l1 != null) &#123; p.next = l1; &#125; if(l2 != null) &#123; p.next = l2; &#125; return l.next;&#125; 138 复制带随机指针的链表题目思路一 HashMap 思路二 将复制的节点直接连到原节点的后边 实现123456789101112131415161718192021222324252627282930313233public Node copyRandomList(Node head) &#123; if(head==null) &#123; return null; &#125; Node p = head; //第一步，在每个原节点后面创建一个新节点 //1-&gt;1&#x27;-&gt;2-&gt;2&#x27;-&gt;3-&gt;3&#x27; while(p!=null) &#123; Node newNode = new Node(p.val); newNode.next = p.next; p.next = newNode; p = newNode.next; &#125; p = head; //第二步，设置新节点的随机节点 while(p!=null) &#123; if(p.random!=null) &#123; p.next.random = p.random.next; &#125; p = p.next.next; &#125; Node dummy = new Node(-1); p = head; Node cur = dummy; //第三步，将两个链表分离 while(p!=null) &#123; cur.next = p.next; cur = cur.next; p.next = cur.next; p = p.next; &#125; return dummy.next;&#125; 困难难度048 二叉树的序列化和反序列化题目 二叉树 - 字符串， 字符串 - 二叉树 思路 前中后序遍历、层序遍历都行 序列化：遍历时有值则拼接 值+”_”，为空则拼接 #_ 反序列化：分隔字符串为数组，按遍历方式拼接ji’ke 实现59 滑动窗口的最大值题目 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值 思路 优先级队列，即堆的思想，但是需要维护的数据较多 单调栈 实现123456789101112131415161718192021222324public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; k; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); &#125; int[] ans = new int[n - k + 1]; ans[0] = nums[deque.peekFirst()]; for (int i = k; i &lt; n; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); while (deque.peekFirst() &lt;= i - k) &#123; deque.pollFirst(); &#125; ans[i - k + 1] = nums[deque.peekFirst()]; &#125; return ans;&#125;","tags":["数据结构和算法","剑指offer"],"categories":["算法题"]},{"title":"代码随想录","path":"/2024/01/18/Note/力扣/1/","content":"题目 提示 备注 二分查找 找最左最右 while循环中的if判断目标值不能等于 有找最左最右值的 移除元素 从左到右遍历数组，满足目标值则于最右交换 原地删除，返回删除后长度 有序数组的平方 双指针分别指向首尾，比较后放进结果数组 有负有序数组，平方后排序 长度最小的子数组 双指针，右指针从0往右走，sum+&#x3D;right的值，当sum&gt;&#x3D;target时，记录right-left的值，然后sum-left的值，left++ 子数组大于等于目标值的长度 螺旋矩阵II 模拟过程，定义left，right，top，bottom n x n 的正方形 移除链表元素 创建头节点，node.next &#x3D; head; res &#x3D; node; 操作res即可 删除链表中值为val的节点 设计链表 模拟过程 两两交换链表中的节点 创建一个虚拟头结点，tmp.next &#x3D; head; A -&gt; B -&gt; C -&gt; DB -&gt; A -&gt; D -&gt; C 删除链表的倒数第N个节点 建立头结点temp指向head，创建快慢指针指向temp，创建pre记录slow的前一位，fast先走n步，slow再和fast一起走，直到fast为null，然后pre.next &#x3D; pre.next.next 给定一个链表，删除其倒数第k个节点 链表相交 一：算两链表差值二；一起走，到头跳到另一条链表 两链表会有一段合并的 有效的字母异位词 用一个数组保存每一个字母出现的次数 判断两个字符串的字母和出现次数是否一致 两个数组的交集 用两个set，一个填充后另一个过滤 快乐数 判断是否有重复的元素，有重复即发生了循环，用set存放每次的结果， 给一个数，循环每一位的平方相加，最后等于1即是快乐数 两数之和 使用哈希表解决，将数值的值和下标封装到map中，值 ：下标 的形式 找数组中和为target的两个数的下标 四数相加 双重for循环将 a + b : 出现的次数 加入map中，双重for统计 c + b &#x3D; - (a + b) 的次数 给四个数组，找 a + b + c + d &#x3D; 0，返回满足的次数 三数之和 &#x2F; 四数之和 取一个为基准，然后就类似两数之和了，进行一些剪枝操作a为基准，b &#x3D; a + 1, c 是最后一位，但b &lt; c 时循环找 给一个数组，找a + b + c &#x3D; 0 反转字符串 双指针指首尾，交换值 abc -&gt; cba 反转字符串Ⅱ 模拟过程，可用异或优化 给定一个字符串s和整数k，到2k位置就反转前k个字符 替换空格 ⅠStringBuilder实现Ⅱ 创建一个新数据将’ ‘填充为’ ‘,然后与旧数组的值对比 字符串中的空字符替换 翻转字符串里的单词 Ⅰ转换为单词数组，从尾向头遍历Ⅱ api 左旋转字符串 实现Strstr() KMP算法，求s2的next数组（next数组记录的是s2每个位置之前的序列头尾相等的个数），在s1中匹配s2时，不相等时s2跳到next对应的位置 给定s1，s2，求s2在s1的开始下标 重复的字符串 二叉树层序遍历 用队列存储节点，一个集合存放每一层的节点，一点存放总的节点 自顶向下，自底向上Z型遍历 翻转二叉树 递归+后序遍历 对称二叉树 把树看出左右两棵树，判断左孩子是否等于右孩子 判断树是否是轴对称 二叉树的深度 递归 &#x2F; 层序遍历 最大最小深度 完全二叉树节点个数 计算左右子树，一直找左孩子就是树的高度 平衡二叉树 递归判断左右高度差 二叉树的所有路径 遍历 相同的树 遍历 判断两棵树是否一样 左叶子之和 找树左下角的值 路径总和 构造二叉树 中序、后序前序、中序 最大二叉树 合并二叉树 二叉搜索树中的搜索 二叉搜索树的最小绝对差 验证二叉搜索树 二叉树中的众数 二叉树的最近公共祖先 Ⅰ：使用map和set，map记录父节点，set记录路径Ⅱ：递归查找左右子树是否有目标节点 找到两个节点的汇聚节点 二叉搜索树的最近公共祖先 二叉搜索树中的插入操作 删除二叉搜索树中的节点 修剪二叉搜索树 将有序数组转换为二叉搜索树 把二叉搜索树转换为累加树 用栈实现队列 一个输入栈一个输出栈 用队列实现栈 链表实现 有效的括号 左括号入栈，然后出栈判断，最后栈空为有效 判断字符串左右括号是否有效 删除字符串中的所有相邻重复项 逆波兰表达式求值 滑动窗口的最大值 前k个高频元素 组合问题 写一个dfs方法深度遍历，用一个results放全部结果，用result存放单次的结果 当result的大小满足条件就加入results中for循环时添加元素，回溯时删除result的最后一位 回溯 + 剪枝 组合总和问题 电话号码组合问题 分割回文串 复原ip地址 子集问题 递增子序列 全排列问题 重新安排行程 N皇后 不能同行同列同对角 解数独 分发饼干 摆动序列 最大子序和 一个全局最大sum一个尝试的count，加进去大就保留 找最大的连续的子数组 跳跃游戏问题 Ⅰ： 从前往后：每到一步获取能到的最远的一步Ⅱ： 从后往前：最后一位跳到他能到的最远的位置，步数加一 从前往后: 每走一步都判断能到的最远距离，判断当前是否到达最远位置 从数组第一位跳到最后一位Ⅰ 能否到达最后一位Ⅱ 最少次数到达 K次取反后最大化的数组和 加油站 分发糖果 用一个left数组记录第一位与其后一位是否呈递增关系，用一个right数组记录最后一位与其前一位是否呈递增关系，取left和right大的为糖果数（站一圈需要找到局部最小值填充数组两边，用线性的方式计算然后-1） 小孩站一排，发糖果，分高的多得，求最少总糖果数（扩展为站一圈） 柠檬水找零 统计5元和10元的数量，小于0则false，判断三种情况，支付20的时候需要判断是否有10元，没10元用三张5元， 一杯柠檬水5元，客户可给5，10，20，正确找零 根据身高重建队列 [a, b]，先将区间按a从大到小排列，然后插入指定b的位置 [a, b] a是身高，b是当前身高之前的人数，从小到大排列 用最少数量的箭引爆气球 假设n个气球需要n支箭，有区间重合就减一支箭 气球在x轴上排列，相当于一个个区间，类似于将他们合并为最少数量的区间 无重叠区间 先排序，遍历数组，记录前一个区间的右边界，每次判断当前区间左边界是否大于上一个区间的右边界，小于则结果+1 给定一些区间，查找重复区间的个数 划分字母区间 last数组记录每个字母最后出现的位置，当循环位置到达最后出现位置是计算结果 将字符串s划分，每个片段中的值在另一个片段不存在 合并区间 比较[ i ][ 0 ] 和 [ i - 1 ][ 1 ] 的大小，最后记得添加最后一个区间到结果中 合并重复的区间，[1,3] [2,6]&#x3D;[1,6] 单调递增的数字 将n转为char数组，从倒数第二和倒数第一开始比较，后大于前则减一，记录这一位的位置，从这位开始都变9就是答案 找到一个小于等于N的数，其每个位置是单调递增的 监控二叉树 0 表示无覆盖 ，1 表示有摄像头，2 表示有覆盖，左右孩子都为2返回0，左右其中一个0返回1，监控数+1，覆盖的返回2 每个节点可监视其父对象、自身及其直接子对象，求需要监控个数 斐波那契 dp[n] &#x3D; d[n-1] * dp[n-2] 爬楼梯 Ⅰ：dp[n] &#x3D; d[n-1] * dp[n-2] 或 三个变量Ⅱ：算最小代价从，dp[i] &#x3D; Math.min(dp[i - 2], dp[i - 1]) + cost[i] Ⅰ：一次跳1或2，爬法Ⅱ：层台阶都有代价 不同路径 Ⅰ：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];Ⅱ：当前位置不能走则设为0即可 Ⅰ：左上走到右下Ⅱ：有些路不能走 整数拆分 不同的二叉搜索树 分割等和子集 最后一块石头的重量 目标和 给一个nums和target，元素之间可以加减，算能达到target的组合个数 一和零 零钱问题 Ⅰ：双重for dp[rest] &#x3D; Math.min(dp[rest], dp[rest - coins[index]] +1) Ⅱ：双重for dp[j] +&#x3D; dp[j - coins[i]] Ⅰ：花费最少的硬币数Ⅱ：组合的个数 组合总和Ⅳ 完全平方数 单词拆分 最长递增子序列 双重for 判断之前位是否有小于当前位置值的，有则+1，最大值即是结果每走一格就要刷新整个dp数组 给一个数组，找最长递增子序列，不用连续 最长连续递增序列 dp判断当前值是否大于前一位，是+1，否等于1，返回dp最大值即可 找最长连续递增子序列 最长公共子序列 二维数组保存相等个数，如果当前位置相等，则等于dp[i-1][j-1] + 1，不相等则左边和上边取大值 找两个字符串公共子序列长度 不相交的线 最大子序和 贪心：count当前最大值，sum全局最大值，count &lt; 0 时令其等于0动规：dp[0] &#x3D; nums[0] , ans &#x3D; dp[0]，循环dp[i] &#x3D; Math.max(dp[i-1] + nums[i], nums[i]); 给你一个整数数组 nums ，找出一个具有最大和的连续子数组，返回其最大和 判断子序列 不同的子序列 两个字符串的删除操作 编辑距离 回文子串 求正反相同的字符串个数 最长回文子序列 返回长度 打家劫舍 Ⅰ Math.max(dp[i - 1], dp[i - 2] + nums[i])Ⅱ 拆成0 - n-2 和 1 - n-1Ⅲ 给一个数组，求最大sumⅠ不能抢相邻的Ⅱ 围成一圈Ⅲ 树形 买卖股票问题 i-天数 k-次数 0没股票 1有股票1.dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] &#x3D; Math.max(dp[i-1][1], -prices[i]);2.dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1]+prices[i]); dp[i][1] &#x3D; Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);3 and 4.需要先给每个k赋初值 dp[i][k][0] &#x3D; Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] &#x3D; Math.max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]);5.需要先给前两天赋初值 dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1]+prices[i]); dp[i][1] &#x3D; Math.max(dp[i-1][1], dp[i-2][0]-prices[i]); 6.dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1]+prices[i] - fee); dp[i][1] &#x3D; Math.max(dp[i-1][1], dp[i-1][0]-prices[i]); 一次交易无限制两次k次有冷冻期有手续费 每日温度 下标入栈，遇到大于下标对应值的，计算差值 给定一个温度数组，找比当前温度高的，计算间隔 下一个最大的数 Ⅰ：数组二从后往前遍历入栈，当前数如果大于栈顶元素则出栈，用map存储当前元素和栈顶元素Ⅱ：for循环size的两倍并将 i%size入栈，while循环栈不为空并且 nums[i % size] &gt; nums[st.peek()]，然后result[st.peek()] &#x3D; nums[i % size] Ⅰ：给两个数组，在数组二中找比数组一x大的数，一是二的子集Ⅱ：给一个循环数组，返回每个位置下个更大的数 接雨水 双指针 给一个数组表示高度，除头尾元素，之间高度差为储水量，求总储水量 柱状图中最大的矩形 数组二分查找二分查找1234567891011121314151617//找中间值public int search(int[] nums, int target) &#123; //定义左右边界 int low = 0, high = nums.length - 1; while (low &lt;= high) &#123; //防止整型溢出 int mid = (high - low) / 2 + low; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &gt; target) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return -1;&#125; 查找最左边出现的目标值12345678910111213141516public int search(int[] nums, int target) &#123; int low = 0, high = nums.length - 1; while (low &lt;= high) &#123; int mid = (high - low) / 2 + low; if (nums[mid] &gt; target) &#123; high = mid - 1; &#125; else if (nums[mid] &lt; target) &#123; low = mid + 1; &#125; else&#123; high = mid; &#125; //low等于目标值时就是最左边满足条件的值 if(arr[low]==target) return low; &#125; return -1;&#125; 查找最右边出现的目标值1234567891011121314151617public static int searchRight(int[] nums, int target) &#123; int low = 0, high = nums.length - 1; while (low &lt;= high) &#123; int mid = (high - low) / 2 + low; if (nums[mid] &gt; target) &#123; high = mid - 1; &#125; else if (nums[mid] &lt; target) &#123; low = mid + 1; &#125;else&#123; low = mid + 1; &#125; //high等于目标值时就是最左边满足条件的值 if(nums[high]==target) return high; &#125; return -1;&#125; 移除元素力扣题目链接 12345678910111213141516171819202122/*\t题目：\t- 原地移除数组中等于val的元素\t- 返回新数组的长度\t思路：\t- 定义两个指针，分别指向数组两端，\t- 遇到等于val的元素将它和数组中最后的元素交换*/public int removeElement(int[] nums, int val) &#123; int left = 0; //为了保证left能取到最后一个 int right = nums.length; while (left &lt; right) &#123; if (nums[left] == val) &#123; nums[left] = nums[right - 1]; right--; &#125; else &#123; left++; &#125; &#125; return left;&#125; 有序数组的平方力扣题目链接 12345678910111213141516171819202122/*\t题目：\t- 一个升序排序的数组arr，返回每个数字的平方\t- 组成新的数组，也是升序的\t思路：\t- 定义两个指针，分别指向数组两端，*/public int[] sortedSquares(int[] arr) &#123; int left = 0, right = arr.length-1; int[] resultArr = new int[arr.length]; int resultIndex = resultArr.length-1; while (left &lt;= right)&#123; if(arr[left]*arr[left] &gt; arr[right] * arr[right]) &#123; resultArr[resultIndex--] = arr[left] * arr[left]; left++; &#125;else&#123; resultArr[resultIndex--] = arr[right] * arr[right]; right--; &#125; &#125; return resultArr;&#125; 长度最小的子数组力扣链接 1234567891011121314151617181920212223/*\t题目： 给定一个含有 n 个正整数的数组和一个正整数 target 找出该数组中满其 和 ≥ target 的长度最小的连续子数组并返回其长度 如果不存在符合条件的 子数组，返回 0\t思路： 滑动窗口*/public static int minSubArrayLen(int target, int[] arr) &#123; int left = 0, right = 0, sum = 0, min = 0; while(right &lt; arr.length)&#123; sum += arr[right++]; while(sum &gt;= target)&#123; if(min == 0)&#123; min = right - left; &#125;else &#123; min = Math.min(min, right - left); &#125; sum -= arr[left++]; &#125; &#125; return min;&#125; 螺旋矩阵II力扣题目链接 12345678910111213141516171819202122232425262728293031323334353637/*\t题目：\t- 给定一个n，生成一个包含1到n^2的所有元素的矩阵\t- 1 2 3 - 假设n=3\t=》\t8 9 4\t- 7 6 5\t思路：\t- 一圈一圈的模拟这个过程 */public static int[][] generateMatrix(int n) &#123; int num = 1; int[][] arr = new int[n][n]; //分别指的是四条边 int left = 0, right = n - 1, top = 0, bottom = n - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right - 1; ++i) &#123; arr[top][i] = num++; &#125; for (int i = top; i &lt;= bottom - 1; ++i) &#123; arr[i][right] = num++; &#125; for (int i = right;i &gt;= left + 1; --i) &#123; arr[bottom][i] = num++; &#125; for (int i = bottom;i &gt;= top + 1; --i) &#123; arr[i][left] = num++; &#125; left++; right--; top++; bottom--; &#125; //如果n是奇数矩阵z if(n % 2 == 1) arr[n/2][n/2] = n*n; return arr;&#125; 链表移除链表元素力扣链接 123456789101112131415161718/*\t思路：\t- 创建一个节点指向head节点\t- 只要判断新节点下一个节点即可*/public ListNode removeElements(ListNode head, int val) &#123; ListNode node = new ListNode(); node.next = head; ListNode res = node; while(res.next != null)&#123; if(res.next.val == val)&#123; res.next = res.next.next; &#125;else&#123; res = res.next; &#125; &#125; return node.next;&#125; 设计链表力扣链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*\t思路：\t- 模拟过程，注意边界处理*/class LinkNode&#123; int val; LinkNode next; LinkNode prev; LinkNode(int val)&#123;this.val = val;&#125;&#125;class MyLinkedList &#123; int size = 0; LinkNode head; LinkNode tail; LinkNode next, prev, cur; public MyLinkedList() &#123; head = new LinkNode(0); tail = new LinkNode(0); head.prev = tail; head.next = tail; tail.next = head; tail.prev = head; &#125; public int get(int index) &#123; if (index &lt; 0 || index &gt;= size) return -1; cur = head; if (index + 1 &lt; size - index) for(int i = 0; i &lt; index + 1; ++i) cur = cur.next; else &#123; cur = tail; for(int i = 0; i &lt; size - index; ++i) cur = cur.prev; &#125; return cur.val; &#125; public void addAtHead(int val) &#123; LinkNode newNode = new LinkNode(val); next = head.next; head.next = newNode; newNode.prev = head; newNode.next = next; next.prev = newNode; size++; &#125; public void addAtTail(int val) &#123; LinkNode newNode = new LinkNode(val); prev = tail.prev; next = tail; prev.next = newNode; newNode.prev = prev; newNode.next = next; next.prev = newNode; size++; &#125; public void addAtIndex(int index, int val) &#123; if(index &gt; size) return; if(index &lt; 0) addAtHead(val); LinkNode newNode = new LinkNode(val); cur = head; for (int i = 0; i &lt; index; i++) cur = cur.next; next = cur.next; cur.next = newNode; newNode.prev = cur; newNode.next = next; next.prev = newNode; size++; &#125; public void deleteAtIndex(int index) &#123; if(index &gt;= size || index &lt; 0) return; cur = head.next; for (int i = 0; i &lt; index; i++) cur = cur.next; prev = cur.prev; next = cur.next; prev.next = next; next.prev = prev; size--; &#125;&#125; 两两交换链表中的节点力扣链接 123456789101112131415161718192021222324252627/*\t思路：\t- 创建一个头节点\t- 因为在处理节点时会丢失节点的相关属性*/public ListNode swapPairs(ListNode head) &#123; if(head == null) return null; if(head.next == null) return head; //创建一个头节点 ListNode temp = new ListNode(0); temp.next = head; //res作为返回值 ListNode res = head.next;\t//当第一个节点和第二个节点不为空时处理 while(temp.next != null &amp;&amp; temp.next.next != null)&#123; //指向第一个节点 ListNode node1 = temp.next; //指向第二个节点 ListNode node2 = temp.next.next; //执行交换操作 temp.next = node2; node1.next = node2.next; node2.next = node1; temp = node1; &#125; return res;&#125; 删除链表的倒数第N个节点力扣链接 12345678910111213141516171819202122232425262728/*\t思路：\t- 创建一个头结点指向head\t- 创建快慢指针和pre指针\t- fast先走 n 步，slow再走，记录slow的pre\t- pre.next = slow.next\t- slow == null;\t- 返回tmp.next*/public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head == null || head.next == null) return null; ListNode tmp = new ListNode(); tmp.next = head; ListNode slow = tmp; ListNode fast = tmp; ListNode pre = null; while(n-- &gt; 0)&#123; fast = fast.next; &#125; while(fast != null)&#123; pre = slow; slow = slow.next; fast = fast.next; &#125; pre.next = pre.next.next; slow = null; return tmp.next;&#125; 链表相交力扣链接 12345678910111213141516171819/*\t题目：\t- 给定两个链表，找到两链表相交的第一个节点，没有则返回null\t- 两链表均无环\t思路：\t- 方法一 - 计算两链表长度的差值，长的链表先走差值步，然后两链表一起走\t- 方法二 - 两链表一起走，到尾的一边就跳到另外一条链表的头*///方法二public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode A = headA, B = headB; while(A != B)&#123; A = A != null ? A = A.next : headB; B = B != null ? B = B.next : headA; &#125; return A;&#125; 哈希表有效的字母异位词力扣链接 1234567891011121314151617181920212223242526/*\t题目：\t- 给定两个字符串 s 和 t - 判断 t 是否是 s 的字母异位词\t- 即判断两个字符串字母和个数是否一致\t思路：\t- 方法一 - 将两个字符串转为数组并排序\t- 方法二 - 用一个数组保存每一个字母出现的次数*/public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length()) return false; int[] index = new int[26]; for(int i = 0; i &lt; s.length(); ++i)&#123; index[s.charAt(i) - &#x27;a&#x27;]++; &#125; for(int i = 0; i &lt; t.length(); ++i)&#123; if(index[t.charAt(i) - &#x27;a&#x27;] &gt; 0)&#123; index[t.charAt(i) - &#x27;a&#x27;]--; &#125;else&#123; return false; &#125; &#125; return true; &#125; 两个数组的交集力扣链接 123456789101112131415161718192021222324/*\t思路：\t- 用两个set，一个填充后另一个过滤\t- 或者用Collection中的retainAll - 仅保留此 collection 中那些也包含在指定 collection 的元素*/public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(); for(int i:nums1)&#123; set1.add(i); &#125; for(int i:nums2)&#123; if(set1.contains(i))&#123; set2.add(i); &#125; &#125; int[] arr = new int[set2.size()]; int j=0; for(int i:set2)&#123; arr[j++] = i; &#125; return arr;&#125; 快乐数力扣 1234567891011121314151617181920212223242526272829303132/*\t题目\t- 给一个数，循环每一位的平方相加，结果为1即是快乐数\t思路\t- 判断是否有重复的元素，有重复即发生了循环\t- 不可能有无限大的情况，最999也只会是243*/public static boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); while(n != 1 &amp;&amp; !set.contains(n))&#123; set.add(n); n = change(n+&quot;&quot;); &#125; return n == 1;&#125;public int change(String n) &#123; int sum = 0; for(int i = 0; i &lt; n.length(); ++i)&#123; sum+=(n.charAt(i) - &#x27;0&#x27;) * (n.charAt(i) - &#x27;0&#x27;); &#125; return sum;&#125;//方法二（快慢指针）public boolean isHappy(int n) &#123; int slow = n; int fast = change(n+&quot;&quot;); while (fast != 1 &amp;&amp; slow != fast) &#123; slow = change(slow+&quot;&quot;); fast = change(change(fast)+&quot;&quot;); &#125; return fast == 1;&#125; 两数之和12345678910/*\t使用哈希表解决\t将数值的值和下标封装到map中\t值 = 下标 的形式*/for (int i = 0; i &lt; arr.length; ++i) &#123; if(map.containsKey(target-arr[i])) return new int[]&#123;map.get(target-arr[i]),i&#125;; map.put(arr[i],i);&#125; 四数相加力扣 1234567891011121314151617181920212223/*\t思路\t- a + b 存入 map - key：a+b - value：出现的次数\t- 在map找-(c + d)，有就将其value加入次数*/public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int tmp = 0, count = 0; for(int i : nums1)&#123; for(int j : nums2)&#123; map.put(i + j, map.getOrDefault(i + j,0)+1); &#125; &#125; for(int i : nums3)&#123; for(int j : nums4)&#123; if(map.containsKey(0 - i - j)) count += map.get(-i-j); &#125; &#125; return count;&#125; 三数之和力扣 123456789101112131415161718192021222324252627282930/*\t- 取一个为基准，然后就类似两数之和了，进行一些剪枝操作*/public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); for(int a = 0; a &lt; nums.length - 2; ++a)&#123; if(nums[a] &gt; 0) return results; if (a &gt; 0 &amp;&amp; nums[a] == nums[a - 1]) continue; int b = a + 1; int c = nums.length - 1; while(b &lt; c)&#123; int sum = nums[a] + nums[b] + nums[c]; if (sum &gt; 0) &#123; c--; &#125; else if (sum &lt; 0) &#123; b++; &#125; else &#123; results.add(Arrays.asList(nums[a], nums[b], nums[c])); while (c &gt; b &amp;&amp; nums[c] == nums[c - 1]) c--; while (c &gt; b &amp;&amp; nums[b] == nums[b + 1]) b++; c--; b++; &#125; &#125; &#125; return results;&#125; 四数之和力扣 12345678910111213141516171819202122232425262728293031/*\t- 与三数之和解法类似*/public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); for(int a = 0; a &lt; nums.length - 3; ++a)&#123; for(int b = a + 1; b &lt; nums.length - 2; ++b)&#123; int c = b + 1; int d = nums.length - 1; while(d &gt; c)&#123; int sum = nums[a] + nums[b] + nums[c] + nums[d]; if(sum &lt; target)&#123; c++; &#125;else if(sum &gt; target)&#123; d--; &#125;else&#123; List&lt;Integer&gt; tmp = Arrays.asList(nums[a], nums[b], nums[c],nums[d]); if(!result.contains(tmp))&#123; result.add(tmp); &#125; c++; d--; &#125; &#125; &#125; &#125; return result;&#125; 字符串反转字符串力扣链接 12345678910111213/*\t思路：\t- 双指针指向两端，交换位置*/public void reverseString(char[] s) &#123; int i = 0; int j = s.length-1; for (;i&lt;j;++i,--j)&#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; &#125;&#125; 反转字符串Ⅱ力扣链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*\t题目：\t- 给定一个字符串s和整数k，到2k位置就反转前k个字符 - 如果剩余字符少于 k 个，则将剩余字符全部反转。 - 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符。\t思路：\t- 方法一：模拟过程\t- 方法二：*///解法一public String reverseStr(String s, int k) &#123; char[] ch = s.toCharArray(); // 1. 每隔 2k 个字符的前 k 个字符进行反转 for (int i = 0; i&lt; ch.length; i += 2 * k) &#123; // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if (i + k &lt;= ch.length) &#123; reverse(ch, i, i + k -1); continue; &#125; // 3. 剩余字符少于 k 个，则将剩余字符全部反转 reverse(ch, i, ch.length - 1); &#125; return new String(ch);&#125;// 定义翻转函数public void reverse(char[] ch, int i, int j) &#123; for (; i &lt; j; i++, j--) &#123; char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp; &#125;&#125;//解法二public String reverseStr(String s, int k) &#123; char[] ch = s.toCharArray(); for(int i = 0; i &lt; ch.length; i += 2 * k)&#123; int start = i; //这里是判断尾数够不够k个来取决end指针的位置 int end = Math.min(ch.length - 1, start + k - 1); //用异或运算反转 while(start &lt; end)&#123; ch[start] ^= ch[end]; ch[end] ^= ch[start]; ch[start] ^= ch[end]; start++; end--; &#125; &#125; return new String(ch);&#125; 替换空格力扣链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445//方法一，StringBuilderpublic String replaceSpace(String s) &#123; StringBuilder sb = new StringBuilder(s); int i = 0; while(i &lt; sb.length())&#123; if(sb.charAt(i) == &#x27; &#x27;)&#123; sb.deleteCharAt(i); sb.insert(i, &quot;%20&quot;); &#125; i++; &#125; return sb.toString();&#125;//方式二：双指针法public String replaceSpace(String s) &#123; int len = s.length(); if(s == null || len == 0)&#123; return s; &#125; //扩充空间，空格数量2倍 for (int i = 0; i &lt; len; i++) &#123; if(s.charAt(i) == &#x27; &#x27;)&#123; s = s + &quot; &quot;; &#125; &#125; if(len == s.length())&#123; return s; &#125; //有空格情况 定义两个指针 int left = len - 1;//左指针：指向原始字符串最后一个位置 int right = s.length()-1;//右指针：指向扩展字符串的最后一个位置 char[] chars = s.toCharArray(); while(left&gt;=0)&#123; if(chars[left] == &#x27; &#x27;)&#123; chars[right--] = &#x27;0&#x27;; chars[right--] = &#x27;2&#x27;; chars[right] = &#x27;%&#x27;; &#125;else&#123; chars[right] = chars[left]; &#125; left--; right--; &#125; return new String(chars);&#125; 翻转字符串里的单词力扣 12345678910111213141516171819202122232425262728/*\t题目\t- 思路\t- */public String reverseWords(String s) &#123;\ts = s.trim(); String[] str = s.split(&quot;\\\\s+&quot;); String res = &quot;&quot;; for(int i = str.length - 1; i &gt;= 0; --i)&#123; if(i == 0)&#123; res += str[i]; break; &#125; res += str[i] + &quot; &quot;; &#125; return res;&#125;//使用apipublic String reverseWords(String s)&#123; // 除去开头和末尾的空白字符 s = s.trim(); // 正则匹配连续的空白字符作为分隔符分割 List&lt;String&gt; wordList = Arrays.asList(s.split(&quot;\\\\s+&quot;)); Collections.reverse(wordList); return String.join(&quot; &quot;, wordList);&#125; 左旋转字符串力扣 12345678910111213141516171819/*\t题目\t- 思路\t- *///使用api public String reverseLeftWords(String s, int n) &#123; return s.substring(n) + s.substring(0, n); &#125;//只用Stringpublic String reverseLeftWords(String s, int n) &#123; String res = &quot;&quot;; for(int i = n; i &lt; s.length(); i++) res += s.charAt(i); for(int i = 0; i &lt; n; i++) res += s.charAt(i); return res;&#125; 实现strStr()力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//求哈希相等的public int strStr(String haystack, String needle) &#123; if(needle.length() &gt; haystack.length()) return -1; int numStr2 = 0; int str2Len = needle.length(); Map&lt;Integer, Integer&gt; str1 = new HashMap&lt;&gt;(); for (char str : needle.toCharArray()) &#123; numStr2 += str - &#x27;a&#x27;; &#125; int index = 0; for (int j = 0; j &lt; haystack.length();) &#123; str1.put(index, haystack.charAt(j) - &#x27;a&#x27;); for (int i = j+1; i &lt; j + str2Len &amp;&amp; i &lt; haystack.length() ;i++) &#123; if(str1.get(index) &gt; numStr2) break; str1.put(index, str1.get(index) + haystack.charAt(i) - &#x27;a&#x27;); &#125; j++; if (haystack.length() - j &lt; str2Len) &#123; break; &#125; index++; &#125; for (Map.Entry&lt;Integer, Integer&gt; entry : str1.entrySet()) &#123; if (entry.getValue() == numStr2)&#123; int k = entry.getKey(); int i = 0; while(i &lt; str2Len)&#123; if (haystack.charAt(k++) == needle.charAt(i))&#123; i++; &#125;else&#123; break; &#125; &#125; if(i == str2Len) return entry.getKey(); &#125; &#125; return -1;&#125;//KMPpublic int strStr(String haystack, String needle) &#123; int[] next = getNext(needle); int s1 = 0; int s2 = 0; while(s1 &lt; haystack.length() &amp;&amp; s2 &lt; needle.length())&#123; if(haystack.charAt(s1) == needle.charAt(s2))&#123; s1++; s2++; &#125;else if(next[s2] == -1)&#123; s1++; &#125;else&#123; s2 = next[s2]; &#125; &#125; return s2 == needle.length() ? s1-s2 : -1;&#125;public int[] getNext(String str)&#123; if(str.length() == 1) return new int[]&#123;-1&#125;; int[] res = new int[str.length()]; res[0] = -1; res[1] = 0; int i = 2; int cn = 0; while(i &lt; res.length)&#123; if(str.charAt(i - 1) == str.charAt(cn))&#123; res[i++] = ++cn; &#125;else if(cn &gt; 0)&#123; cn = res[cn]; &#125;else&#123; res[i++] = 0; &#125; &#125; return res; &#125;//使用apipublic int strStr(String haystack, String needle) &#123;\treturn haystack.indexOf(needle);&#125; 重复的子字符串力扣 1234567891011121314151617181920public boolean repeatedSubstringPattern(String s) &#123; int len = s.length(); int[] next = new int[len+1]; int i = 2; int cn = 0; while(i &lt; next.length)&#123; if(s.charAt(i - 1) == s.charAt(cn))&#123; next[i++] = ++cn; &#125;else if(cn &gt; 0)&#123; cn = next[cn]; &#125;else &#123; next[i++] = 0; &#125; &#125; if (next[len] &gt; 0 &amp;&amp; len % (len - next[len]) == 0) &#123; return true; &#125; return false;&#125; 二叉树二叉树的层序遍历自顶向下力扣 1234567891011121314151617181920212223242526272829/* 题目： - 给定一个二叉树根节点root - 逐层遍历 思路： - BFS广度优先遍历 - 用一个队列存放 - 在当前循环时存放下一层节点到队列中 - 下一次循环时取出队列中元素并存放到list中*/public static List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); if (root != null) queue.add(root); while (!queue.isEmpty()) &#123; int n = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; res.add(level); &#125; return res;&#125; 自底向上力扣 12345678910111213141516171819202122/*\t- 将每层节点加入结果时，插入节点头部即可*/public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); if (root != null) queue.add(root); while (!queue.isEmpty()) &#123; int n = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; res.addFirst(level); &#125; return res;&#125; Z型遍历力扣 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); int fac = 1; if (root != null) queue.add(root); while (!queue.isEmpty()) &#123; int n = queue.size(); LinkedList&lt;Integer&gt; level = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; TreeNode node = queue.poll(); if(fac % 2 == 0)&#123; level.addFirst(node.val); &#125;else&#123; level.addLast(node.val); &#125; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; fac++; res.add(level); &#125; return res;&#125; 翻转二叉树力扣链接 123456789101112131415161718/*\t思路：\t- 递归+后序遍历*/public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; invertTree(root.left); invertTree(root.right); swap(root); return root;&#125;public void swap(TreeNode r)&#123; TreeNode tmp = r.left; r.left = r.right; r.right = tmp;&#125; 对称二叉树力扣链接 12345678910111213141516171819202122232425262728293031323334353637383940414243/*\t题目：\t- 判断树是否是轴对称\t思路：\t- 把树看出左右两棵树\t- 判断左孩子是否等于右孩子*///递归public boolean isSymmetric(TreeNode root) &#123; return check(root, root);&#125;public boolean check(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; if (p == null || q == null) return false; return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);&#125;//迭代public boolean isSymmetric(TreeNode root) &#123; return check(root, root);&#125;public boolean check(TreeNode u, TreeNode v) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.offer(u); q.offer(v); while (!q.isEmpty()) &#123; u = q.poll(); v = q.poll(); if (u == null &amp;&amp; v == null) &#123; continue; &#125; if ((u == null || v == null) || (u.val != v.val)) &#123; return false; &#125; q.offer(u.left); q.offer(v.right); q.offer(u.right); q.offer(v.left); &#125; return true;&#125; 二叉树的深度最大力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//递归public int maxdepth(treenode root) &#123; if (root == null) return 0; int leftdepth = maxdepth(root.left); int rightdepth = maxdepth(root.right); return Math.max(leftdepth, rightdepth) + 1;&#125;//层序遍历public int maxdepth(treenode root) &#123; if(root == null) return 0; deque&lt;treenode&gt; deque = new linkedlist&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isempty()) &#123; int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) &#123; treenode poll = deque.poll(); if (poll.left != null) &#123; deque.offer(poll.left); &#125; if (poll.right != null) &#123; deque.offer(poll.right); &#125; &#125; &#125; return depth;&#125;//n叉树//递归public int maxDepth(Node root) &#123; if (root == null) return 0; int depth = 0; if (root.children != null)&#123; for (Node child : root.children)&#123; depth = Math.max(depth, maxDepth(child)); &#125; &#125; return depth + 1; &#125; //层序public int maxDepth(Node root) &#123; if (root == null) return 0; int depth = 0; Queue&lt;Node&gt; que = new LinkedList&lt;&gt;(); que.offer(root); while (!que.isEmpty())&#123; depth++; int len = que.size(); while (len &gt; 0)&#123; Node node = que.poll(); for (int i = 0; i &lt; node.children.size(); i++) if (node.children.get(i) != null) que.offer(node.children.get(i)); len--; &#125; &#125; return depth;&#125; 最小力扣 123456789101112131415161718192021222324252627282930313233343536373839404142//递归int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) &#123; return rightDepth + 1; &#125; if (root.right == null) &#123; return leftDepth + 1; &#125; // 左右结点都不为null return Math.min(leftDepth, rightDepth) + 1;&#125;//层序遍历public int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) &#123; int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) &#123; TreeNode poll = deque.poll(); if (poll.left == null &amp;&amp; poll.right == null) &#123; return depth; &#125; if (poll.left != null) &#123; deque.offer(poll.left); &#125; if (poll.right != null) &#123; deque.offer(poll.right); &#125; &#125; &#125; return depth;&#125; 完全二叉树的节点个数力扣 1234567891011121314151617181920public int countNodes(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; int leftDepth = getDepth(root.left); int rightDepth = getDepth(root.right); if (leftDepth == rightDepth) &#123;// 左子树是满二叉树 return (1 &lt;&lt; leftDepth) + countNodes(root.right); &#125; else &#123;// 右子树是满二叉树 return (1 &lt;&lt; rightDepth) + countNodes(root.left); &#125;&#125;private int getDepth(TreeNode root) &#123; int depth = 0; while (root != null) &#123; root = root.left; depth++; &#125; return depth;&#125; 平衡二叉树力扣 123456789101112131415//求左右高度差public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; int leftDepth = getDepth(root.left); int rightDepth = getDepth(root.right); if(Math.abs(leftDepth - rightDepth) &gt; 1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;public int getDepth(TreeNode node)&#123; if(node == null) return 0; int leftdepth = getDepth(node.left); int rightdepth = getDepth(node.right); return Math.max(leftdepth, rightdepth) + 1;&#125; 二叉树的所有路径力扣 12345678910111213141516171819202122public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; paths = new ArrayList&lt;String&gt;(); constructPaths(root, &quot;&quot;, paths); return paths;&#125;public void constructPaths(TreeNode root, String path, List&lt;String&gt; paths) &#123; if (root != null) &#123; StringBuffer SB = new StringBuffer(path); SB.append(root.val + &quot;&quot;); // 当前节点是叶子节点 if (root.left == null &amp;&amp; root.right == null) &#123; paths.add(SB.toString()); &#125; else &#123;// 当前节点不是叶子节点，继续递归遍历 SB.append(&quot;-&gt;&quot;); constructPaths(root.left, SB.toString(), paths); constructPaths(root.right, SB.toString(), paths); &#125; &#125;&#125; 相同的树力扣 1234567891011public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; else if (p == null || q == null) &#123; return false; &#125; else if (p.val != q.val) &#123; return false; &#125; else &#123; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125;&#125; 左叶子之和力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//递归class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if (root == null) return 0; int leftValue = sumOfLeftLeaves(root.left); // 左 int rightValue = sumOfLeftLeaves(root.right); // 右 int midValue = 0; if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123; midValue = root.left.val; &#125; int sum = midValue + leftValue + rightValue; // 中 return sum; &#125;&#125;//迭代class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if (root == null) return 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt; (); stack.add(root); int result = 0; while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); if (node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null) &#123; result += node.left.val; &#125; if (node.right != null) stack.add(node.right); if (node.left != null) stack.add(node.left); &#125; return result; &#125;&#125;// 层序遍历迭代法class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; int sum = 0; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); while (size -- &gt; 0) &#123; TreeNode node = queue.poll(); if (node.left != null) &#123; // 左节点不为空 queue.offer(node.left); if (node.left.left == null &amp;&amp; node.left.right == null)&#123; // 左叶子节点 sum += node.left.val; &#125; &#125; if (node.right != null) queue.offer(node.right); &#125; &#125; return sum; &#125;&#125; 找树左下角的值力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 递归法class Solution &#123; private int Deep = -1; private int value = 0; public int findBottomLeftValue(TreeNode root) &#123; value = root.val; findLeftValue(root,0); return value; &#125; private void findLeftValue (TreeNode root,int deep) &#123; if (root == null) return; if (root.left == null &amp;&amp; root.right == null) &#123; if (deep &gt; Deep) &#123; value = root.val; Deep = deep; &#125; &#125; if (root.left != null) findLeftValue(root.left,deep + 1); if (root.right != null) findLeftValue(root.right,deep + 1); &#125;&#125;//迭代法class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int res = 0; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode poll = queue.poll(); if (i == 0) &#123; res = poll.val; &#125; if (poll.left != null) &#123; queue.offer(poll.left); &#125; if (poll.right != null) &#123; queue.offer(poll.right); &#125; &#125; &#125; return res; &#125;&#125; 路径总和力扣 1234567891011121314151617181920212223242526272829303132//lc22public boolean haspathsum(treenode root, int targetsum) &#123; if (root == null) return false; // 为空退出 // 叶子节点判断是否符合 if (root.left == null &amp;&amp; root.right == null) return root.val == targetsum; // 求两侧分支的路径和 return haspathsum(root.left, targetsum - root.val) || haspathsum(root.right, targetsum - root.val);&#125;//迭代public boolean haspathsum(treenode root, int targetsum) &#123; if(root==null)return false; stack&lt;treenode&gt; stack1 = new stack&lt;&gt;(); stack&lt;integer&gt; stack2 = new stack&lt;&gt;(); stack1.push(root);stack2.push(root.val); while(!stack1.isempty())&#123; int size = stack1.size(); for(int i=0;i&lt;size;i++)&#123; treenode node = stack1.pop();int sum=stack2.pop(); // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true if(node.left==null &amp;&amp; node.right==null &amp;&amp; sum==targetsum)return true; // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来 if(node.right!=null)&#123; stack1.push(node.right);stack2.push(sum+node.right.val); &#125; // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来 if(node.left!=null)&#123; stack1.push(node.left);stack2.push(sum+node.left.val); &#125; &#125; &#125; return false;&#125; 从中序与后序遍历序列构造二叉树力扣 12345678910111213141516171819202122232425262728293031public TreeNode buildTree(int[] inorder, int[] postorder) &#123; return buildTree1(inorder, 0, inorder.length, postorder, 0, postorder.length);&#125;public TreeNode buildTree1(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123; // 没有元素了 if (inRight - inLeft &lt; 1) &#123; return null; &#125; // 只有一个元素了 if (inRight - inLeft == 1) &#123; return new TreeNode(inorder[inLeft]); &#125; // 后序数组postorder里最后一个即为根结点 int rootVal = postorder[postRight - 1]; TreeNode root = new TreeNode(rootVal); int rootIndex = 0; // 根据根结点的值找到该值在中序数组inorder里的位置 for (int i = inLeft; i &lt; inRight; i++) &#123; if (inorder[i] == rootVal) &#123; rootIndex = i; break; &#125; &#125; // 根据rootIndex划分左右子树 root.left = buildTree1(inorder, inLeft, rootIndex, postorder, postLeft, postLeft + (rootIndex - inLeft)); root.right = buildTree1(inorder, rootIndex + 1, inRight, postorder, postLeft + (rootIndex - inLeft), postRight - 1); return root;&#125; 从前序与中序遍历序列构造二叉树123456789101112131415161718192021222324252627public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);&#125;public TreeNode helper(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123; // 递归终止条件 if (inLeft &gt; inRight || preLeft &gt; preRight) return null; // val 为前序遍历第一个的值，也即是根节点的值 // idx 为根据根节点的值来找中序遍历的下标 int idx = inLeft, val = preorder[preLeft]; TreeNode root = new TreeNode(val); for (int i = inLeft; i &lt;= inRight; i++) &#123; if (inorder[i] == val) &#123; idx = i; break; &#125; &#125; // 根据 idx 来递归找左右子树 root.left = helper(preorder, preLeft + 1, preLeft + (idx - inLeft), inorder, inLeft, idx - 1); root.right = helper(preorder, preLeft + (idx - inLeft) + 1, preRight, inorder, idx + 1, inRight); return root;&#125; 最大二叉树力扣 12345678910111213141516171819202122232425public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return constructMaximumBinaryTree1(nums, 0, nums.length);&#125;public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) &#123; if (rightIndex - leftIndex &lt; 1) &#123;// 没有元素了 return null; &#125; if (rightIndex - leftIndex == 1) &#123;// 只有一个元素 return new TreeNode(nums[leftIndex]); &#125; int maxIndex = leftIndex;// 最大值所在位置 int maxVal = nums[maxIndex];// 最大值 for (int i = leftIndex + 1; i &lt; rightIndex; i++) &#123; if (nums[i] &gt; maxVal)&#123; maxVal = nums[i]; maxIndex = i; &#125; &#125; TreeNode root = new TreeNode(maxVal); // 根据maxIndex划分左右子树 root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex); root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex); return root;&#125; 合并二叉树力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 递归public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if (root1 == null) return root2; if (root2 == null) return root1; TreeNode newRoot = new TreeNode(root1.val + root2.val); newRoot.left = mergeTrees(root1.left,root2.left); newRoot.right = mergeTrees(root1.right,root2.right); return newRoot;&#125;// 使用栈迭代public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if (root1 == null) &#123; return root2; &#125; if (root2 == null) &#123; return root1; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root2); stack.push(root1); while (!stack.isEmpty()) &#123; TreeNode node1 = stack.pop(); TreeNode node2 = stack.pop(); node1.val += node2.val; if (node2.right != null &amp;&amp; node1.right != null) &#123; stack.push(node2.right); stack.push(node1.right); &#125; else &#123; if (node1.right == null) &#123; node1.right = node2.right; &#125; &#125; if (node2.left != null &amp;&amp; node1.left != null) &#123; stack.push(node2.left); stack.push(node1.left); &#125; else &#123; if (node1.left == null) &#123; node1.left = node2.left; &#125; &#125; &#125; return root1;&#125;// 使用队列迭代public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if (root1 == null) return root2; if (root2 ==null) return root1; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root1); queue.offer(root2); while (!queue.isEmpty()) &#123; TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); // 此时两个节点一定不为空，val相加 node1.val = node1.val + node2.val; // 如果两棵树左节点都不为空，加入队列 if (node1.left != null &amp;&amp; node2.left != null) &#123; queue.offer(node1.left); queue.offer(node2.left); &#125; // 如果两棵树右节点都不为空，加入队列 if (node1.right != null &amp;&amp; node2.right != null) &#123; queue.offer(node1.right); queue.offer(node2.right); &#125; // 若node1的左节点为空，直接赋值 if (node1.left == null &amp;&amp; node2.left != null) &#123; node1.left = node2.left; &#125; // 若node2的左节点为空，直接赋值 if (node1.right == null &amp;&amp; node2.right != null) &#123; node1.right = node2.right; &#125; &#125; return root1;&#125; 二叉搜索树中的搜索力扣 123456789101112public TreeNode searchBST(TreeNode root, int val) &#123; while(root != null)&#123; if(val &lt; root.val)&#123; root = root.left; &#125;else if(val &gt; root.val)&#123; root = root.right; &#125;else&#123; return root; &#125; &#125; return null;&#125; 验证二叉搜索树力扣 123456789101112131415161718192021222324//递归public boolean isValidBST(TreeNode root) &#123; return validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);&#125;boolean validBST(long lower, long upper, TreeNode root) &#123; if (root == null) return true; if (root.val &lt;= lower || root.val &gt;= upper) return false; return validBST(lower, root.val, root.left) &amp;&amp; validBST(root.val, upper, root.right);&#125;//中序遍历private long prev = Long.MIN_VALUE;public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (!isValidBST(root.left)) &#123; return false; &#125; if (root.val &lt;= prev) &#123; // 不满足二叉搜索树条件 return false; &#125; prev = root.val; return isValidBST(root.right);&#125; 二叉搜索树的最小绝对差力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//递归class Solution &#123; TreeNode pre;// 记录上一个遍历的结点 int result = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; if(root==null)return 0; traversal(root); return result; &#125; public void traversal(TreeNode root)&#123; if(root==null)return; //左 traversal(root.left); //中 if(pre!=null)&#123; result = Math.min(result,root.val-pre.val); &#125; pre = root; //右 traversal(root.right); &#125;&#125;//中序遍历class Solution &#123; TreeNode pre; Stack&lt;TreeNode&gt; stack; public int getMinimumDifference(TreeNode root) &#123; if (root == null) return 0; stack = new Stack&lt;&gt;(); TreeNode cur = root; int result = Integer.MAX_VALUE; while (cur != null || !stack.isEmpty()) &#123; if (cur != null) &#123; stack.push(cur); // 将访问的节点放进栈 cur = cur.left; // 左 &#125;else &#123; cur = stack.pop(); if (pre != null) &#123; // 中 result = Math.min(result, cur.val - pre.val); &#125; pre = cur; cur = cur.right; // 右 &#125; &#125; return result; &#125;&#125; 二叉搜索树中的众数力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*\t题目：\t- 找出出现频率zu*///中序遍历，利用二叉搜索树特性ArrayList&lt;Integer&gt; resList;int maxCount;int count;TreeNode pre;public int[] findMode(TreeNode root) &#123; resList = new ArrayList&lt;&gt;(); maxCount = 0; count = 0; pre = null; findMode1(root); int[] res = new int[resList.size()]; for (int i = 0; i &lt; resList.size(); i++) &#123; res[i] = resList.get(i); &#125; return res;&#125;public void findMode1(TreeNode root) &#123; if (root == null) &#123; return; &#125; findMode1(root.left); int rootValue = root.val; // 计数 if (pre == null || rootValue != pre.val) &#123; count = 1; &#125; else &#123; count++; &#125; // 更新结果以及maxCount if (count &gt; maxCount) &#123; resList.clear(); resList.add(rootValue); maxCount = count; &#125; else if (count == maxCount) &#123; resList.add(rootValue); &#125; pre = root; findMode1(root.right);&#125;//迭代public int[] findMode(TreeNode root) &#123; TreeNode pre = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int maxCount = 0; int count = 0; TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; if (cur != null) &#123; stack.push(cur); cur =cur.left; &#125;else &#123; cur = stack.pop(); // 计数 if (pre == null || cur.val != pre.val) &#123; count = 1; &#125;else &#123; count++; &#125; // 更新结果 if (count &gt; maxCount) &#123; maxCount = count; result.clear(); result.add(cur.val); &#125;else if (count == maxCount) &#123; result.add(cur.val); &#125; pre = cur; cur = cur.right; &#125; &#125; return result.stream().mapToInt(Integer::intValue).toArray();&#125; 二叉树的最近公共祖先力扣 1234567891011121314151617181920212223242526272829303132333435363738394041/*\t可能出现的情况 情况一 - p 在 q 下 或 q 在 p 下 情况二 - 情况一之外的情况，即需要向上找\t方法一：\t- 遍历这棵树，用一个map保存每一个节点的父节点\t- 用一个set保存从目标节点到root经过的所有节点\t- 另一个目标节点也进行上述操作，记录时如果遇到上述操作中set中有记录的值则返回\t方式二：\t- 如果当前节点下没有目标节点则返回null，有则返回目标节点\t- 对每个节点都进行递归判断\t- 判断该节点的左返回值和右返回值 - 左右都有目标节点，返回当前节点 - 哪边有目标节点就返回哪边*///方式一public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //记录的时每个节点的父节点 HashMap&lt;TreeNode, TreeNode&gt; parent = new HashMap&lt;&gt;(); //递归记录 dg(root,parent); //记录目标节点经过的路径 HashSet&lt;TreeNode&gt; path = new HashSet&lt;&gt;(); //自底向上记录路径 while()&#123;...&#125; //另一个也自底向上，遇到上面存在的路径则放回即可&#125;//方式二public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //当前节点为空或者是目标节点则返回 if(root == null || root == p || root == q) return root; //递归查找 TreeNode left = lowestCommonAncestor(root.left, p , q); TreeNode right = lowestCommonAncestor(root.right, p , q); //当前节点不为空且左右孩子都是目标节点，返回当前节点 if(left != null &amp;&amp; right != null) return root; //左右子树不一定有返回值 return left != null? left: right;&#125; 二叉搜索树的最近公共祖先力扣 12345678910111213141516171819//递归public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root;&#125;//迭代public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; while (true) &#123; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; root = root.left; &#125; else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; root = root.right; &#125; else &#123; break; &#125; &#125; return root;&#125; 二叉搜索树中的插入操作力扣 1234567891011121314151617181920public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) return new TreeNode(val); TreeNode newRoot = root; TreeNode pre = root; while (root != null) &#123; pre = root; if (root.val &gt; val) &#123; root = root.left; &#125; else if (root.val &lt; val) &#123; root = root.right; &#125; &#125; if (pre.val &gt; val) &#123; pre.left = new TreeNode(val); &#125; else &#123; pre.right = new TreeNode(val); &#125; return newRoot;&#125; 删除二叉搜索树中的节点力扣 123456789101112131415161718192021222324public TreeNode deleteNode(TreeNode root, int key) &#123; root = delete(root,key); return root;&#125;private TreeNode delete(TreeNode root, int key) &#123; if (root == null) return null; if (root.val &gt; key) &#123; root.left = delete(root.left,key); &#125; else if (root.val &lt; key) &#123; root.right = delete(root.right,key); &#125; else &#123; if (root.left == null) return root.right; if (root.right == null) return root.left; TreeNode tmp = root.right; while (tmp.left != null) &#123; tmp = tmp.left; &#125; root.val = tmp.val; root.right = delete(root.right,tmp.val); &#125; return root;&#125; 修剪二叉搜索树力扣 1234567891011121314151617181920212223/*\t题目：\t- 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high\t- 使得所有节点的值在[low, high]中*/class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if (root == null) &#123; return null; &#125; if (root.val &lt; low) &#123; return trimBST(root.right, low, high); &#125; if (root.val &gt; high) &#123; return trimBST(root.left, low, high); &#125; // root在[low,high]范围内 root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; &#125;&#125; 将有序数组转换为二叉搜索树力扣 12345678910111213141516171819202122232425/*\t题目：\t- 给你一个整数数组 nums ，其中元素已经按 升序 排列\t- 转换为一棵 高度平衡 二叉搜索树\t- 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。*/class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; return sortedArrayToBST(nums, 0, nums.length); &#125; public TreeNode sortedArrayToBST(int[] nums, int left, int right) &#123; if (left &gt;= right) &#123; return null; &#125; if (right - left == 1) &#123; return new TreeNode(nums[left]); &#125; int mid = left + (right - left) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = sortedArrayToBST(nums, left, mid); root.right = sortedArrayToBST(nums, mid + 1, right); return root; &#125;&#125; 把二叉搜索树转换为累加树力扣 12345678910111213141516171819202122232425/*\t题目：\t- 给出二叉 搜索 树的根节点，该树的节点值各不相同\t- 请你将其转换为累加树\t- 每个节点 node 的新值等于原树中大于或等于 node.val 的值之和*/class Solution &#123; int sum; public TreeNode convertBST(TreeNode root) &#123; sum = 0; convertBST1(root); return root; &#125; // 按右中左顺序遍历，累加即可 public void convertBST1(TreeNode root) &#123; if (root == null) &#123; return; &#125; convertBST1(root.right); sum += root.val; root.val = sum; convertBST1(root.left); &#125;&#125; 栈与队列用栈实现队列力扣链接 12345678910111213141516171819202122232425262728293031323334353637383940/*\t题目：\t- 用两个栈实现队列\t思路：\t- 创建两个栈，一个输入栈一个输出栈\t- 元素入队列则把元素加入输入栈\t- 元素出队列则把输入栈的元素弹出并加入输出栈，然后输出栈弹出*/Stack&lt;Integer&gt; insert;Stack&lt;Integer&gt; outside;public MyQueue()&#123; insert = new Stack&lt;&gt;(); outside = new Stack&lt;&gt;();&#125;public void push(int x) &#123; insert.push(x);&#125;public int pop() &#123; //如果输出栈不为空则输出即可 if(!outside.isEmpty())&#123; return outside.pop(); &#125; //输出栈为空则把输入栈的元素弹出并y while (!insert.isEmpty()) &#123; outside.push(insert.pop()); &#125; return outside.pop();&#125;public int peek() &#123; if(!outside.isEmpty())&#123; return outside.peek(); &#125; while (!insert.isEmpty()) &#123; outside.push(insert.pop()); &#125; return outside.peek();&#125;public boolean empty() &#123; return insert.isEmpty() &amp;&amp; outside.isEmpty();&#125; 用队列实现栈力扣链接 1234567891011121314151617181920212223242526class MyStack &#123; Queue&lt;Integer&gt; queue1;//输入队列 public MyStack() &#123; queue1 = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; queue1.add(x); int n = queue1.size(); for(int i = 1; i &lt; n; ++i)&#123; queue1.add(queue1.poll()); &#125; &#125; public int pop() &#123; return queue1.poll(); &#125; public int top() &#123; return queue1.peek(); &#125; public boolean empty() &#123; return queue1.isEmpty(); &#125;&#125; 有效的括号力扣 123456789101112131415161718192021222324252627282930/*\t题目：\t- 给定一个只包含括号的字符串，判断是否符合格式\t思路：\t- 遍历字符串，把遇到的左括号的另一边入栈\t- 遇到右括号判断栈尾是否是其左括号，是就出栈\t- 最后判断是否栈空\t思路二：\t- 可以用字符串的replce方法替换&#123;&#125;[]()为空\t- 在判断s*/public boolean isValid(String s) &#123; Deque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;(); char ch; for (int i = 0; i &lt; s.length(); i++) &#123; ch = s.charAt(i); //碰到左括号，就把相应的右括号入栈 if (ch == &#x27;(&#x27;) &#123; deque.push(&#x27;)&#x27;); &#125;else if (ch == &#x27;&#123;&#x27;) &#123; deque.push(&#x27;&#125;&#x27;); &#125;else if (ch == &#x27;[&#x27;) &#123; deque.push(&#x27;]&#x27;); &#125; else if(deque.isEmpty() || deque.pop() != ch) &#123; return false; &#125; &#125; //最后判断栈中元素是否匹配 return deque.isEmpty();&#125; 删除字符串中的所有相邻重复项力扣 12345678910111213141516171819202122232425/*\t题目：\t- 由小写字母组成的字符串 S\t- 反复删除相邻且相同的字母*/public String removeDuplicates(String S) &#123; //ArrayDeque会比LinkedList在除了删除元素这一点外会快一点 //参考：https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist ArrayDeque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;(); char ch; for (int i = 0; i &lt; S.length(); i++) &#123; ch = S.charAt(i); if (deque.isEmpty() || deque.peek() != ch) &#123; deque.push(ch); &#125; else &#123; deque.pop(); &#125; &#125; String str = &quot;&quot;; //剩余的元素即为不重复的元素 while (!deque.isEmpty()) &#123; str = deque.pop() + str; &#125; return str;&#125; 逆波兰表达式求值力扣 12345678910111213141516171819202122232425262728/*\t题目：\t- 有效的算符包括 +、-、*、/\t- 每个运算对象可以是整数，也可以是另一个逆波兰表达式。\t- 示例 1： 输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9*/public int evalRPN(String[] tokens) &#123; Deque&lt;Integer&gt; stack = new LinkedList(); for (int i = 0; i &lt; tokens.length; ++i) &#123; if (&quot;+&quot;.equals(tokens[i])) &#123; // leetcode 内置jdk的问题，不能使用==判断字符串是否相等 stack.push(stack.pop() + stack.pop()); // 注意 - 和/ 需要特殊处理 &#125; else if (&quot;-&quot;.equals(tokens[i])) &#123; stack.push(-stack.pop() + stack.pop()); &#125; else if (&quot;*&quot;.equals(tokens[i])) &#123; stack.push(stack.pop() * stack.pop()); &#125; else if (&quot;/&quot;.equals(tokens[i])) &#123; int temp1 = stack.pop(); int temp2 = stack.pop(); stack.push(temp2 / temp1); &#125; else &#123; stack.push(Integer.valueOf(tokens[i])); &#125; &#125; return stack.pop();&#125; 滑动窗口的最大值力扣 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/*\t题目：\t- 有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧\t- 只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位\t- 返回 滑动窗口中的最大值 *///解法一//自定义数组class MyQueue &#123; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出 //同时判断队列当前是否为空 void poll(int val) &#123; if (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123; deque.poll(); &#125; &#125; //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出 //保证队列元素单调递减 //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2 void add(int val) &#123; while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123; deque.removeLast(); &#125; deque.add(val); &#125; //队列队顶元素始终为最大值 int peek() &#123; return deque.peek(); &#125;&#125;class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums.length == 1) &#123; return nums; &#125; int len = nums.length - k + 1; //存放结果元素的数组 int[] res = new int[len]; int num = 0; //自定义队列 MyQueue myQueue = new MyQueue(); //先将前k的元素放入队列 for (int i = 0; i &lt; k; i++) &#123; myQueue.add(nums[i]); &#125; res[num++] = myQueue.peek(); for (int i = k; i &lt; nums.length; i++) &#123; //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列 myQueue.poll(nums[i - k]); //滑动窗口加入最后面的元素 myQueue.add(nums[i]); //记录对应的最大值 res[num++] = myQueue.peek(); &#125; return res; &#125;&#125;//解法二//利用双端队列手动实现单调队列/** * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可 * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标) */class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); int n = nums.length; int[] res = new int[n - k + 1]; int idx = 0; for(int i = 0; i &lt; n; i++) &#123; // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点 // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出 while(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1)&#123; deque.poll(); &#125; // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出 while(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123; deque.pollLast(); &#125; deque.offer(i); // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了 if(i &gt;= k - 1)&#123; res[idx++] = nums[deque.peek()]; &#125; &#125; return res; &#125;&#125; 前k个高频元素力扣 12345678910111213141516171819202122232425/*\t题目：\t- 返回其中出现频率前 k 高的元素*/public int[] topKFrequent(int[] nums, int k) &#123; int[] result = new int[k]; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet(); // 根据map的value值正序排，相当于一个小顶堆 PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue()); for (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123; queue.offer(entry); if (queue.size() &gt; k) &#123; queue.poll(); &#125; &#125; for (int i = k - 1; i &gt;= 0; i--) &#123; result[i] = queue.poll().getKey(); &#125; return result;&#125; 回溯组合问题组合Ⅰ力扣链接 12345678910111213141516171819202122232425262728293031323334353637/*\t题目：\t- 给定n和k，返回[1，n]中所有可能的k个数的组合\t思路：\t- 回溯 + 剪枝\t- 一个集合存放各种情况*///存放总结果static List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();//存放单次的结果static LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;();public static List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; dfs(n, k, 1); return results;&#125;/*\t- n：1-n上组合\t- k：组合几个\t- startIndex：从哪开始找组合*/private static void dfs(int n, int k, int startIndex) &#123; //终止条件 //当符合组合条件时返回 if (result.size() == k)&#123; results.add(new ArrayList&lt;&gt;(result)); return; &#125; //剪枝优化 //k - result.size() 是还需要的结果个数 for (int i = startIndex; i &lt;= n - (k - result.size()) + 1; i++)&#123; result.add(i); dfs(n, k, i + 1); //把上一轮的组合删除 result.removeLast(); &#125;&#125; 组合总和Ⅰ力扣 12345678910111213141516171819202122List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;\tbackTracking(candidates, target, 0); return results;&#125;public void backTracking(int[] candidates, int target, int startIndex)&#123; if(target &lt; 0) return; if(target == 0) &#123; results.add(new ArrayList&lt;&gt;(result)); return; &#125; for (int i = startIndex; i &lt; candidates.length; i++) &#123; result.add(candidates[i]); target -= candidates[i]; backTracking(candidates,target,i); result.removeLast(); target += candidates[i]; &#125;&#125; 组合总和Ⅱ力扣 123456789101112131415161718192021222324List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backTracking(candidates, target, 0); return results;&#125;public void backTracking(int[] candidates, int target, int startIndex)&#123; if(target &lt; 0) return; if(target == 0) &#123; results.add(new ArrayList&lt;&gt;(result)); return; &#125; for (int i = startIndex; i &lt; candidates.length; i++) &#123; if(i&gt;startIndex &amp;&amp; candidates[i] == candidates[i-1]) continue; result.add(candidates[i]); target -= candidates[i]; backTracking(candidates,target,i+1); result.removeLast(); target += candidates[i]; &#125;&#125; 组合总和Ⅲ力扣链接 123456789101112131415161718192021222324252627282930313233343536373839/*\t题目：\t- z\t- 找出所有相加之和为 n 的 k 个数的组合\t思路：\t- 主要在回溯时处理相关逻辑*/List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();//n是总和的值//k是组合的个数public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backTracking(n, k, 1, 0); return result;&#125;private void backTracking(int targetSum, int k, int startIndex, int sum) &#123; // 减枝 // sum大于目标值返回，减去加上的i，进行下一轮循环 if (sum &gt; targetSum) return; // 当前组合个数达到要求 if (path.size() == k) &#123; // 当前的组合满足sum等于targetSum加入结果集中 if (sum == targetSum) result.add(new ArrayList&lt;&gt;(path)); // 当前的组合不满足则返回删除，进行下一轮循环 return; &#125; // 减枝 9 - (k - path.size()) + 1 for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) &#123; path.add(i); sum += i; backTracking(targetSum, k, i + 1, sum); //只要执行了return操下面的代码都会执行 //回溯 path.removeLast(); //回溯 sum -= i; &#125;&#125; 电话号码的字母组合链接 1234567891011121314151617181920212223242526272829303132333435363738394041/*\t题目：\t- 给几个数字，返回能够组成的字母组合\t思路：\t- 由于数字越多要拼接的个数越多，嵌套的循环越多\t- 所以要想到回溯算法*///设置全局列表存储最后的结果List&lt;String&gt; list = new ArrayList&lt;&gt;();public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || digits.length() == 0) &#123; return list; &#125; //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串&quot;&quot; String[] numString = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; //迭代处理 backTracking(digits, numString, 0); return list;&#125;//每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuildStringBuilder temp = new StringBuilder();//比如digits如果为&quot;23&quot;,num 为0，则str表示2对应的 abcpublic void backTracking(String digits, String[] numString, int num) &#123; //遍历全部一次记录一次得到的字符串 if (num == digits.length()) &#123; list.add(temp.toString()); return; &#125; //str 表示当前num对应的字符串 String str = numString[digits.charAt(num) - &#x27;0&#x27;]; for (int i = 0; i &lt; str.length(); i++) &#123; temp.append(str.charAt(i)); //c backTracking(digits, numString, num + 1); //剔除末尾的继续尝试 temp.deleteCharAt(temp.length() - 1); &#125;&#125; 分割回文串力扣 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backTracking(s, 0); return lists; &#125; private void backTracking(String s, int startIndex) &#123; //如果起始位置大于s的大小，说明找到了一组分割方案 if (startIndex &gt;= s.length()) &#123; lists.add(new ArrayList(deque)); return; &#125; for (int i = startIndex; i &lt; s.length(); i++) &#123; //如果是回文子串，则记录 if (isPalindrome(s, startIndex, i)) &#123; String str = s.substring(startIndex, i + 1); deque.addLast(str); &#125; else &#123; continue; &#125; //起始位置后移，保证不重复 backTracking(s, i + 1); deque.removeLast(); &#125; &#125; //判断是否是回文串 private boolean isPalindrome(String s, int startIndex, int end) &#123; for (int i = startIndex, j = end; i &lt; j; i++, j--) &#123; if (s.charAt(i) != s.charAt(j)) &#123; return false; &#125; &#125; return true; &#125;&#125; 复原IP地址力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class Solution &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s.length() &gt; 12) return result; // 算是剪枝了 backTrack(s, 0, 0); return result; &#125; // startIndex: 搜索的起始位置， pointNum:添加逗点的数量 private void backTrack(String s, int startIndex, int pointNum) &#123; if (pointNum == 3) &#123;// 逗点数量为3时，分隔结束 // 判断第四段⼦字符串是否合法，如果合法就放进result中 if (isValid(s,startIndex,s.length()-1)) &#123; result.add(s); &#125; return; &#125; for (int i = startIndex; i &lt; s.length(); i++) &#123; if (isValid(s, startIndex, i)) &#123; s = s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1); //在str的后⾯插⼊⼀个逗点 pointNum++; backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2 pointNum--;// 回溯 s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点 &#125; else &#123; break; &#125; &#125; &#125; // 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法 private Boolean isValid(String s, int start, int end) &#123; if (start &gt; end) &#123; return false; &#125; if (s.charAt(start) == &#x27;0&#x27; &amp;&amp; start != end) &#123; // 0开头的数字不合法 return false; &#125; int num = 0; for (int i = start; i &lt;= end; i++) &#123; if (s.charAt(i) &gt; &#x27;9&#x27; || s.charAt(i) &lt; &#x27;0&#x27;) &#123; // 遇到⾮数字字符不合法 return false; &#125; num = num * 10 + (s.charAt(i) - &#x27;0&#x27;); if (num &gt; 255) &#123; // 如果⼤于255了不合法 return false; &#125; &#125; return true; &#125;&#125;//方法二：比上面的方法时间复杂度低，更好地剪枝，优化时间复杂度class Solution &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;();\tStringBuilder stringBuilder = new StringBuilder();\tpublic List&lt;String&gt; restoreIpAddresses(String s) &#123; restoreIpAddressesHandler(s, 0, 0); return result;\t&#125;\t// number表示stringbuilder中ip段的数量\tpublic void restoreIpAddressesHandler(String s, int start, int number) &#123; // 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回 if (start == s.length() &amp;&amp; number == 4) &#123; result.add(stringBuilder.toString()); return; &#125; // 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回 if (start == s.length() || number == 4) &#123; return; &#125; // 剪枝：ip段的长度最大是3，并且ip段处于[0,255] for (int i = start; i &lt; s.length() &amp;&amp; i - start &lt; 3 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &gt;= 0 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255; i++) &#123; // 如果ip段的长度大于1，并且第一位为0的话，continue if (i + 1 - start &gt; 1 &amp;&amp; s.charAt(start) - &#x27;0&#x27; == 0) &#123; continue; &#125; stringBuilder.append(s.substring(start, i + 1)); // 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点 if (number &lt; 3) &#123; stringBuilder.append(&quot;.&quot;); &#125; number++; restoreIpAddressesHandler(s, i + 1, number); number--; // 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题 stringBuilder.delete(start + number, i + number + 2); &#125;\t&#125;&#125; 子集力扣 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();// 存放符合条件结果的集合 LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果 public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; if (nums.length == 0)&#123; result.add(new ArrayList&lt;&gt;()); return result; &#125; subsetsHelper(nums, 0); return result; &#125; private void subsetsHelper(int[] nums, int startIndex)&#123; result.add(new ArrayList&lt;&gt;(path));//「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。 if (startIndex &gt;= nums.length)&#123; //终止条件可不加 return; &#125; for (int i = startIndex; i &lt; nums.length; i++)&#123; path.add(nums[i]); subsetsHelper(nums, i + 1); path.removeLast(); &#125; &#125;&#125; 子集II力扣 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();// 存放符合条件结果的集合 LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果 boolean[] used; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; if (nums.length == 0)&#123; result.add(path); return result; &#125; Arrays.sort(nums); used = new boolean[nums.length]; subsetsWithDupHelper(nums, 0); return result; &#125; private void subsetsWithDupHelper(int[] nums, int startIndex)&#123; result.add(new ArrayList&lt;&gt;(path)); if (startIndex &gt;= nums.length)&#123; return; &#125; for (int i = startIndex; i &lt; nums.length; i++)&#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])&#123; continue; &#125; path.add(nums[i]); used[i] = true; subsetsWithDupHelper(nums, i + 1); path.removeLast(); used[i] = false; &#125; &#125;&#125;//不使用used数组class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup( int[] nums ) &#123; Arrays.sort( nums ); subsetsWithDupHelper( nums, 0 ); return res; &#125; private void subsetsWithDupHelper( int[] nums, int start ) &#123; res.add( new ArrayList&lt;&gt;( path ) ); for ( int i = start; i &lt; nums.length; i++ ) &#123; // 跳过当前树层使用过的、相同的元素 if ( i &gt; start &amp;&amp; nums[i - 1] == nums[i] ) &#123; continue; &#125; path.add( nums[i] ); subsetsWithDupHelper( nums, i + 1 ); path.removeLast(); &#125; &#125;&#125; 递增子序列力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; private List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; backtracking(nums,0); return res; &#125; private void backtracking (int[] nums, int start) &#123; if (path.size() &gt; 1) &#123; res.add(new ArrayList&lt;&gt;(path)); &#125; int[] used = new int[201]; for (int i = start; i &lt; nums.length; i++) &#123; if (!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - 1) || (used[nums[i] + 100] == 1)) continue; used[nums[i] + 100] = 1; path.add(nums[i]); backtracking(nums, i + 1); path.remove(path.size() - 1); &#125; &#125;&#125;//法二：使用mapclass Solution &#123; //结果集合 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //路径集合 LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; getSubsequences(nums,0); return res; &#125; private void getSubsequences( int[] nums, int start ) &#123; if(path.size()&gt;1 )&#123; res.add( new ArrayList&lt;&gt;(path) ); // 注意这里不要加return，要取树上的节点 &#125; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=start ;i &lt; nums.length ;i++)&#123; if(!path.isEmpty() &amp;&amp; nums[i]&lt; path.getLast())&#123; continue; &#125; // 使用过了当前数字 if ( map.getOrDefault( nums[i],0 ) &gt;=1 )&#123; continue; &#125; map.put(nums[i],map.getOrDefault( nums[i],0 )+1); path.add( nums[i] ); getSubsequences( nums,i+1 ); path.removeLast(); &#125; &#125;&#125; 全排列力扣 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();// 存放符合条件结果的集合 LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果 boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums.length == 0)&#123; return result; &#125; used = new boolean[nums.length]; permuteHelper(nums); return result; &#125; private void permuteHelper(int[] nums)&#123; if (path.size() == nums.length)&#123; result.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; i++)&#123; if (used[i])&#123; continue; &#125; used[i] = true; path.add(nums[i]); permuteHelper(nums); path.removeLast(); used[i] = false; &#125; &#125;&#125;// 解法2：通过判断path中是否存在数字，排除已经选择的数字class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums.length == 0) return result; backtrack(nums, path); return result; &#125; public void backtrack(int[] nums, LinkedList&lt;Integer&gt; path) &#123; if (path.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(path)); &#125; for (int i =0; i &lt; nums.length; i++) &#123; // 如果path中已有，则跳过 if (path.contains(nums[i])) &#123; continue; &#125; path.add(nums[i]); backtrack(nums, path); path.removeLast(); &#125; &#125;&#125; 全排列 II力扣 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; //存放结果 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //暂存结果 List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; boolean[] used = new boolean[nums.length]; Arrays.fill(used, false); Arrays.sort(nums); backTrack(nums, used); return result; &#125; private void backTrack(int[] nums, boolean[] used) &#123; if (path.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过 // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过 // 如果同⼀树层nums[i - 1]使⽤过则直接跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) &#123; continue; &#125; //如果同⼀树⽀nums[i]没使⽤过开始处理 if (used[i] == false) &#123; used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用 path.add(nums[i]); backTrack(nums, used); path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复 used[i] = false;//回溯 &#125; &#125; &#125;&#125; 重新安排行程力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; private Deque&lt;String&gt; res; private Map&lt;String, Map&lt;String, Integer&gt;&gt; map; private boolean backTracking(int ticketNum)&#123; if(res.size() == ticketNum + 1)&#123; return true; &#125; String last = res.getLast(); if(map.containsKey(last))&#123;//防止出现null for(Map.Entry&lt;String, Integer&gt; target : map.get(last).entrySet())&#123; int count = target.getValue(); if(count &gt; 0)&#123; res.add(target.getKey()); target.setValue(count - 1); if(backTracking(ticketNum)) return true; res.removeLast(); target.setValue(count); &#125; &#125; &#125; return false; &#125; public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123; map = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;(); res = new LinkedList&lt;&gt;(); for(List&lt;String&gt; t : tickets)&#123; Map&lt;String, Integer&gt; temp; if(map.containsKey(t.get(0)))&#123; temp = map.get(t.get(0)); temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1); &#125;else&#123; temp = new TreeMap&lt;&gt;();//升序Map temp.put(t.get(1), 1); &#125; map.put(t.get(0), temp); &#125; res.add(&quot;JFK&quot;); backTracking(tickets.size()); return new ArrayList&lt;&gt;(res); &#125;&#125; N皇后力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] chessboard = new char[n][n]; for (char[] c : chessboard) &#123; Arrays.fill(c, &#x27;.&#x27;); &#125; backTrack(n, 0, chessboard); return res; &#125; public void backTrack(int n, int row, char[][] chessboard) &#123; if (row == n) &#123; res.add(Array2List(chessboard)); return; &#125; for (int col = 0;col &lt; n; ++col) &#123; if (isValid (row, col, n, chessboard)) &#123; chessboard[row][col] = &#x27;Q&#x27;; backTrack(n, row+1, chessboard); chessboard[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; public List Array2List(char[][] chessboard) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (char[] c : chessboard) &#123; list.add(String.copyValueOf(c)); &#125; return list; &#125; public boolean isValid(int row, int col, int n, char[][] chessboard) &#123; // 检查列 for (int i=0; i&lt;row; ++i) &#123; // 相当于剪枝 if (chessboard[i][col] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 检查45度对角线 for (int i=row-1, j=col-1; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 检查135度对角线 for (int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;=n-1; i--, j++) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; return true; &#125;&#125; 解数独力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; public void solveSudoku(char[][] board) &#123; solveSudokuHelper(board); &#125; private boolean solveSudokuHelper(char[][] board)&#123; //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列， // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」 for (int i = 0; i &lt; 9; i++)&#123; // 遍历行 for (int j = 0; j &lt; 9; j++)&#123; // 遍历列 if (board[i][j] != &#x27;.&#x27;)&#123; // 跳过原始数字 continue; &#125; for (char k = &#x27;1&#x27;; k &lt;= &#x27;9&#x27;; k++)&#123; // (i, j) 这个位置放k是否合适 if (isValidSudoku(i, j, k, board))&#123; board[i][j] = k; if (solveSudokuHelper(board))&#123; // 如果找到合适一组立刻返回 return true; &#125; board[i][j] = &#x27;.&#x27;; &#125; &#125; // 9个数都试完了，都不行，那么就返回false return false; // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！ // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」 &#125; &#125; // 遍历完没有返回false，说明找到了合适棋盘位置了 return true; &#125; /** * 判断棋盘是否合法有如下三个维度: * 同行是否重复 * 同列是否重复 * 9宫格里是否重复 */ private boolean isValidSudoku(int row, int col, char val, char[][] board)&#123; // 同行是否重复 for (int i = 0; i &lt; 9; i++)&#123; if (board[row][i] == val)&#123; return false; &#125; &#125; // 同列是否重复 for (int j = 0; j &lt; 9; j++)&#123; if (board[j][col] == val)&#123; return false; &#125; &#125; // 9宫格里是否重复 int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i &lt; startRow + 3; i++)&#123; for (int j = startCol; j &lt; startCol + 3; j++)&#123; if (board[i][j] == val)&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 贪心分发饼干力扣链接 123456789101112131415161718192021222324252627/*\t题目：\t- 给定一个孩子数组g，g[i]表示第i个孩子的胃口值\t- 给定一个饼干数组s，s[i]表示第i个饼干的尺寸\t- 一个小孩只能拿一块饼干\t- s[i] &gt;= g[i] 孩子满足\t- 求最大满足值\t思路：\t- 尺寸最大的饼干给胃口最大的孩子*/public static int findContentChildren(int[] g, int[] s) &#123; int ans = 0; Arrays.sort(g); Arrays.sort(s); int i = g.length-1; int j = s.length-1; while (i &gt;= 0 &amp;&amp; j &gt;= 0)&#123; if(s[j] &gt;= g[i])&#123; j--; i--; ans++; &#125;else&#123; i--; &#125; &#125; return ans;&#125; 摆动序列力扣 1234567891011121314151617181920212223242526/*\t题目：\t- 给定一个数组，\t- 如果 arr[0] &gt; arr[1], arr[1] &lt; arr[2], arr[2] &gt; arr[3] .....\t- 则为摆动序列，例如：8, 1, 5, 3, 8, 2, 6\t思路：\t- 贪心 - 保留上一次的差值 - 判断与当前差值一正一负即可*/public int wiggleMaxLength(int[] nums) &#123; int ans = 1; if(nums.length &lt; 2)&#123; return ans; &#125; int curDiff = 0; int preDiff = 0; for(int i = 1; i &lt; nums.length; ++i)&#123; curDiff = nums[i] - nums[i - 1]; if((preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0))&#123; ans++; preDiff = curDiff; &#125; &#125; return ans;&#125; 最大子序和力扣 123456789101112131415161718192021222324/*\t题目：\t- 找到一组和最大的连续的子数组，\t思路：\t- count保存的是当前连续数组的最大值\t- sum保存的是全局最大值\t- 有种切块的感觉\t- 各个大块中找最大快，即贪心*/public int maxSubArray(int[] nums) &#123;\tif (nums.length == 1) return nums[0]; int sum = nums[0]; int count = 0; for (int i = 0; i &lt; nums.length; i++)&#123; count += nums[i]; // 取区间累计的最大值（相当于不断确定最大子序终止位置） sum = Math.max(sum, count); if (count &lt;= 0)&#123; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 count = 0; &#125; &#125; return sum;&#125; 跳跃游戏跳跃游戏Ⅰ力扣 12345678910111213141516171819/*\t题目：\t- 给定一个非负整数数组，你最初位于数组的第一个位置。\t- 数组中的每个元素代表你在该位置可以跳跃的最大长度。\t- 判断你是否能够到达最后一个位置。*/public boolean canJump(int[] nums) &#123; int rightmost = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; //i最远可以取到的位置由rightmost决定 if (i &lt;= rightmost) &#123; rightmost = Math.max(rightmost, i + nums[i]); if (rightmost &gt;= n - 1) &#123; return true; &#125; &#125; &#125; return false;&#125; 跳跃游戏Ⅱ力扣 12345678910111213141516171819202122232425262728293031323334353637383940/*\t题目：\t- 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。 - 数组中的每个元素代表你在该位置可以跳跃的最大长度。 - 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 - 假设你总是可以到达数组的最后一个位置。 - [2,3,1,1,4] - 7 5 9 4 2 6 8 3 5 4 3 9 1 2 3 7 1 5 9 3 2 1*///从后往前O(N^2)public int jump(int[] nums) &#123;\tint position = nums.length - 1; int steps = 0; while (position &gt; 0) &#123; for (int i = 0; i &lt; position; i++) &#123; if (i + nums[i] &gt;= position) &#123; position = i; steps++; break; &#125; &#125; &#125; return steps;&#125;//从前往后O() [2,3,1,1,4]public int jump(int[] nums) &#123; int end = 0; int maxPosition = 0; int steps = 0; for (int i = 0; i &lt; nums.length - 1; i++) &#123; maxPosition = Math.max(maxPosition, i + nums[i]); if (i == end) &#123; end = maxPosition; steps++; &#125; &#125; return steps;&#125; K次取反后最大化的数组和力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int largestSumAfterKNegations(int[] nums, int K) &#123; // 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小\tnums = IntStream.of(nums) .boxed() .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1)) .mapToInt(Integer::intValue).toArray();\tint len = nums.length; for (int i = 0; i &lt; len; i++) &#123; //从前向后遍历，遇到负数将其变为正数，同时K-- if (nums[i] &lt; 0 &amp;&amp; K &gt; 0) &#123; nums[i] = -nums[i]; K--; &#125;\t&#125;\t// 如果K还大于0，那么反复转变数值最小的元素，将K用完\tif (K % 2 == 1) nums[len - 1] = -nums[len - 1];\treturn Arrays.stream(nums).sum(); &#125;&#125;//二class Solution &#123; public int largestSumAfterKNegations(int[] A, int K) &#123; if (A.length == 1) return k % 2 == 0 ? A[0] : -A[0]; Arrays.sort(A); int sum = 0; int idx = 0; for (int i = 0; i &lt; K; i++) &#123; if (i &lt; A.length - 1 &amp;&amp; A[idx] &lt; 0) &#123; A[idx] = -A[idx]; if (A[idx] &gt;= Math.abs(A[idx + 1])) idx++; continue; &#125; A[idx] = -A[idx]; &#125; for (int i = 0; i &lt; A.length; i++) &#123; sum += A[i]; &#125; return sum; &#125;&#125; 加油站力扣 123456789101112131415161718192021222324252627282930313233343536373839// 解法1class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int sum = 0; int min = 0; for (int i = 0; i &lt; gas.length; i++) &#123; sum += (gas[i] - cost[i]); min = Math.min(sum, min); &#125; if (sum &lt; 0) return -1; if (min &gt;= 0) return 0; for (int i = gas.length - 1; i &gt; 0; i--) &#123; min += (gas[i] - cost[i]); if (min &gt;= 0) return i; &#125; return -1; &#125;&#125;// 解法2class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curSum = 0; int totalSum = 0; int index = 0; for (int i = 0; i &lt; gas.length; i++) &#123; curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) &#123; index = (i + 1) % gas.length ; curSum = 0; &#125; &#125; if (totalSum &lt; 0) return -1; return index; &#125;&#125; 分发糖果力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*\t题目：\t- n个小孩站一排，用一个ratings数组表示孩子的评分\t- 每个孩子至少分配到一个糖果\t- 相邻两个孩子评分高的获得更多的糖果\t- 求最少糖果数\t思路：\t- 用一个left数组记录原始数组第一位与其后一位是否呈递增关系 - 用一个right数组记录原始数组最后一位与其前一位是否呈递增关系 - 取left和right大的为糖果数*/public static int method1(int[] arr)&#123; int count = 0; int[] left = new int[arr.length]; left[0] = 1; int[] right = new int[arr.length]; right[arr.length-1] = 1; for (int i = 1; i &lt; left.length; i++) &#123; if(arr[i] &gt; arr[i-1])&#123; left[i] = left[i-1] + 1; &#125;else&#123; left[i] = 1; &#125; &#125; for (int i = right.length - 2; i &gt;= 0; i--) &#123; if(arr[i] &gt; arr[i+1])&#123; right[i] = right[i+1] + 1; &#125;else&#123; right[i] = 1; &#125; &#125; for (int i = 0; i &lt; left.length; i++) &#123; count += Math.max(left[i],right[i]); &#125; return count;&#125;/*\t拓展：\t- 小孩站成一圈\t思路：\t- 找到原始数组局部最小值，即arr[i-1] &gt;= arr[i] &lt;= arr[i+1] - 创建一个辅助数组，长度为arr+2 - 将局部最小值作为辅助数组的第一个元素和最后一个元素 - 用线性的方法解决即可，结果-1*/ 柠檬水找零力扣 12345678910111213141516171819202122232425class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; int five = 0; int ten = 0; for (int i = 0; i &lt; bills.length; i++) &#123; if (bills[i] == 5) &#123; five++; &#125; else if (bills[i] == 10) &#123; five--; ten++; &#125; else if (bills[i] == 20) &#123; if (ten &gt; 0) &#123; ten--; five--; &#125; else &#123; five -= 3; &#125; &#125; if (five &lt; 0 || ten &lt; 0) return false; &#125; return true; &#125;&#125; 根据身高重建队列力扣 1234567891011121314151617class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; // 身高从大到小排（身高相同k小的站前面） Arrays.sort(people, (a, b) -&gt; &#123; if (a[0] == b[0]) return a[1] - b[1]; return b[0] - a[0]; &#125;); LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;(); //相同位置会插入到前面 for (int[] p : people) &#123; que.add(p[1],p); &#125; return que.toArray(new int[people.length][]); &#125;&#125; 用最少数量的箭引爆气球力扣 1234567891011121314151617class Solution &#123; public int findMinArrowShots(int[][] points) &#123; Arrays.sort(points, (a, b) -&gt; &#123; if(a[0] == b[0]) return Integer.compare(a[1], b[1]); return Integer.compare(a[0], b[0]); &#125;); int count = points.length; for(int i = 1; i &lt; points.length; i++)&#123; if(points[i][0] &lt;= points[i-1][1])&#123; points[i][1] = Math.min(points[i-1][1], points[i][1]); count--; &#125; &#125; return count; &#125;&#125; 无重叠区间力扣 1234567891011121314151617181920212223242526272829303132public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, (a, b) -&gt; &#123; if (a[0] == a[0]) return a[1] - b[1]; return a[0] - b[0]; &#125;); int count = 0; int edge = Integer.MIN_VALUE; for (int i = 0; i &lt; intervals.length; i++) &#123; if (edge &lt;= intervals[i][0]) &#123; edge = intervals[i][1]; &#125; else &#123; count++; &#125; &#125; return count;&#125;//按左边排序，不管右边顺序。相交的时候取最小的右边。public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals,(a,b)-&gt;&#123; return Integer.compare(a[0],b[0]); &#125;); int remove = 0; int pre = intervals[0][1]; for(int i=1;i&lt;intervals.length;i++)&#123; if(pre&gt;intervals[i][0]) &#123; remove++; pre = Math.min(pre,intervals[i][1]); &#125; else pre = intervals[i][1]; &#125; return remove;&#125; 划分字母区间力扣 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; partitionLabels(String s) &#123; int[] last = new int[26]; int len = s.length(); for(int i = 0; i &lt; len; i++)&#123; last[s.charAt(i)-&#x27;a&#x27;] = i; &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int start = 0, end = 0; for(int i = 0; i &lt; len; i++)&#123; end = Math.max(end, last[s.charAt(i) - &#x27;a&#x27;]); if(i == end)&#123; res.add(end - start + 1); start = end + 1; &#125; &#125; return res; &#125;&#125; 合并区间力扣 12345678910111213141516171819202122class Solution &#123; public int[][] merge(int[][] intervals) &#123; List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[0], o2[0])); int start = intervals[0][0]; for (int i = 1; i &lt; intervals.length; i++) &#123; //如果[1][0] &gt; [0][1],说明区间不重合，直接添加进结果 if (intervals[i][0] &gt; intervals[i - 1][1]) &#123; res.add(new int[]&#123;start, intervals[i - 1][1]&#125;); //从后一个位置开始检查 start = intervals[i][0]; //如果[1][0] &lt;= [0][1],说明区间重合，让后者的右边界变成两者中右边界大的 &#125; else &#123; intervals[i][1] = Math.max(intervals[i][1], intervals[i - 1][1]); &#125; &#125; //由于上面的循环最后一个区间没法进行比较，所以直接添加 res.add(new int[]&#123;start, intervals[intervals.length - 1][1]&#125;); return res.toArray(new int[res.size()][]); &#125;&#125; 单调递增的数字力扣 123456789101112131415161718class Solution &#123; public int monotoneIncreasingDigits(int n) &#123; String s = String.valueOf(n); char[] chars = s.toCharArray(); int start = s.length(); for (int i = s.length() - 2; i &gt;= 0; i--) &#123; if (chars[i] &gt; chars[i + 1]) &#123; chars[i]--; start = i+1; &#125; &#125; //如果上面的if没进则这段循环不会进 for (int i = start; i &lt; s.length(); i++) &#123; chars[i] = &#x27;9&#x27;; &#125; return Integer.parseInt(String.valueOf(chars)); &#125;&#125; 监控二叉树力扣 123456789101112131415161718192021222324252627282930313233343536373839/*\t- 在树的节点上安装摄像头\t- 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。\t- 计算监控树的所有节点所需的最小摄像头数量。\t- 节点的状态值： - 0 表示无覆盖 - 1 表示 有摄像头 - 2 表示有覆盖 */class Solution &#123; int res=0; public int minCameraCover(TreeNode root) &#123; // 对根节点的状态做检验,防止根节点是无覆盖状态 . if(minCame(root)==0)&#123; res++; &#125; return res; &#125; public int minCame(TreeNode root)&#123; if(root==null)&#123; // 空节点默认为 有覆盖状态，避免在叶子节点上放摄像头 return 2; &#125; int left=minCame(root.left); int right=minCame(root.right); // 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头 if(left==2&amp;&amp;right==2)&#123; return 0; &#125;else if(left==0||right==0)&#123; // 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头 // 状态值为 1 摄像头数 ++; res++; return 1; &#125;else&#123; // 那么本节点就是处于被覆盖状态 return 2; &#125; &#125;&#125; 动态规划斐波那契数12345678910111213141516171819202122232425262728//动态规划 f(n) = f(n - 1) * f(n - 2)public static int fib(int n) &#123; if (n &lt; 2) return n; //初始时p,q,r 分别对应斐波那契数列前三项 int p = 0, q = 0, r = 1; for (int i = 2; i &lt;= n; ++i) &#123; p = q; q = r; r = p + q; &#125; return r;&#125;//递归实现public static int fib(int n) &#123; if (n &lt; 2) return n; return fib(n-1) + fib(n-2);&#125;//dp实现public int fib(int n) &#123; if (n &lt;= 1) return n; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; for (int index = 2; index &lt;= n; index++)&#123; dp[index] = dp[index - 1] + dp[index - 2]; &#125; return dp[n];&#125; 爬楼梯爬楼梯Ⅰ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*\t题目：\t- 楼梯有N阶\t- 一次可以爬1个或2个台阶\t- 求有多少种爬法\t思路：\t- 爬一层有1种方法，二层有2种方法\t- 类似斐波那契数列\t-*///dp数组public int climbStairs(int n) &#123; if(n == 1) return 1; if(n == 2) return 2; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;//不使用额外空间public int climbStairs(int n) &#123; int p = 0, q = 0, r = 1; for (int i = 1; i &lt;= n; ++i) &#123; p = q; q = r; r = p + q; &#125; return r;&#125;/*\t拓展：\t- 一次可以爬n个台阶*//class Solution &#123; public int climbStairs(int n) &#123; int[] dp = new int[n + 1]; int[] weight = &#123;1,2&#125;; dp[0] = 1; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt; weight.length; j++) &#123; if (i &gt;= weight[j]) dp[i] += dp[i - weight[j]]; &#125; &#125; return dp[n]; &#125;&#125; 使用最小花费爬楼梯力扣链接 123456789101112131415161718192021/*\t题目：\t- 楼梯有N阶，每层台阶都有代价\t- 一次可以爬1个或2个台阶\t- 求有多少种爬法\t思路：\t- 假设自己站在楼顶，那么代价就是 cost[i-1] + cost[i] 或者 cost[i-2] + cost[i]\t- 提取一下便是最小代价 Math.min(dp[i - 2], dp[i - 1]) + cost[i];\t- dp存的是总代价*///1,100,1,1,1,100,1,1,100,1public int minCostClimbingStairs(int[] cost) &#123;\tint[] dp = new int[cost.length]; //这里的dp[0] 相当于第一个台阶的代价 dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; cost.length; i++) &#123; dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i]; &#125; return Math.min(dp[cost.length - 2], dp[cost.length - 1]);&#125; 不同路径不同路径Ⅰ12345678910111213141516171819/*\t题目：\t- 给定一个m，n表示一个m行n列的二维数组\t- 求从左上角到右下角的走法\t- 只能向右和向下走\t思路：\t- 当前位置的走法 = 上方的走法 + 左方的走法*/public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m+1][n+1]; dp[0][1] = 1; dp[1][0] = 0; for(int i = 1; i &lt;= m; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125; 不同路径Ⅱ12345678910111213141516171819202122232425262728/*\t题目：\t- 给定一个二维数组，数组中0代表能走，1不能走\t- 求从左上角到右下角的走法\t- 只能向右和向下走\t思路：\t- 当前位置不能走则设为0即可\t- 当前位置的走法 = 上方的走法 + 左方的走法*/public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; //行 int m = obstacleGrid.length; //列 int n = obstacleGrid[0].length; int[][] dp = new int[m+1][n+1]; dp[0][1] = 1; dp[1][0] = 0; for(int i = 1; i &lt;= m; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(obstacleGrid[i-1][j-1] == 1)&#123; dp[i][j] = 0; continue; &#125; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125; 整数拆分力扣 123456789101112public int integerBreak(int n) &#123;\tint[] dp = new int[n+1]; dp[2] = 1; for(int i = 3; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= i-j; j++)&#123; //j*(i-j) 就是比较2个数 //j*dp[i-j]中dp[i-j]存放的是拆分的数的结果，相当于继续拆分 dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j])); &#125; &#125; return dp[n];&#125; 不同的二叉搜索树力扣 12345678910111213public int numTrees(int n) &#123;\tif(n &lt;= 2) return n; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; //累加每个数都作为根节点的情况 dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n];&#125; 分割等和子集力扣 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117class Solution &#123; public boolean canPartition(int[] nums) &#123; if(nums == null || nums.length == 0) return false; int n = nums.length; int sum = 0; for(int num : nums)&#123; sum += num; &#125; //总和为奇数，不能平分 if(sum % 2 != 0) return false; int target = sum / 2; int[] dp = new int[target + 1]; for(int i = 0; i &lt; n; i++)&#123; for(int j = target; j &gt;= nums[i]; j--)&#123; //物品 i 的重量是 nums[i]，其价值也是 nums[i] dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]); &#125; &#125; return dp[target] == target; &#125;&#125;public class Solution &#123; public static void main(String[] args) &#123; int num[] = &#123;1,5,11,5&#125;; canPartition(num); &#125; public static boolean canPartition(int[] nums) &#123; int len = nums.length; // 题目已经说非空数组，可以不做非空判断 int sum = 0; for (int num : nums) &#123; sum += num; &#125; // 特判：如果是奇数，就不符合要求 if ((sum %2 ) != 0) &#123; return false; &#125; int target = sum / 2; //目标背包容量 // 创建二维状态数组，行：物品索引，列：容量（包括 0） /* dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数 每个数只能用一次，使得这些数的和恰好等于 j。 */ boolean[][] dp = new boolean[len][target + 1]; // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满 （这里的dp[][]数组的含义就是“恰好”，所以就算容积比它大的也不要） if (nums[0] &lt;= target) &#123; dp[0][nums[0]] = true; &#125; // 再填表格后面几行 //外层遍历物品 for (int i = 1; i &lt; len; i++) &#123; //内层遍历背包 for (int j = 0; j &lt;= target; j++) &#123; // 直接从上一行先把结果抄下来，然后再修正 dp[i][j] = dp[i - 1][j]; //如果某个物品单独的重量恰好就等于背包的重量，那么也是满足dp数组的定义的 if (nums[i] == j) &#123; dp[i][j] = true; continue; &#125; //如果某个物品的重量小于j，那就可以看该物品是否放入背包 //dp[i - 1][j]表示该物品不放入背包，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true； //dp[i - 1][j - nums[i]]表示该物品放入背包。如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。 if (nums[i] &lt; j) &#123; dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]; &#125; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt;= target; j++) &#123; System.out.print(dp[i][j]+&quot; &quot;); &#125; System.out.println(); &#125; return dp[len - 1][target]; &#125;&#125;class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; if (sum % 2 == 1) return false; int target = sum / 2; //dp[i][j]代表可装物品为0-i，背包容量为j的情况下，背包内容量的最大价值 int[][] dp = new int[nums.length][target + 1]; //初始化,dp[0][j]的最大价值nums[0](if j &gt; weight[i]) //dp[i][0]均为0，不用初始化 for (int j = nums[0]; j &lt;= target; j++) &#123; dp[0][j] = nums[0]; &#125; //遍历物品，遍历背包 //递推公式: for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt;= target; j++) &#123; //背包容量可以容纳nums[i] if (j &gt;= nums[i]) &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[nums.length - 1][target] == target; &#125;&#125; 最后一块石头的重量 II力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//一维数组版本class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum = 0; for (int i : stones) &#123; sum += i; &#125; int target = sum &gt;&gt; 1; //初始化dp数组 int[] dp = new int[target + 1]; for (int i = 0; i &lt; stones.length; i++) &#123; //采用倒序 for (int j = target; j &gt;= stones[i]; j--) &#123; //两种情况，要么放，要么不放 dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - 2 * dp[target]; &#125;&#125;//二维数组版本（便于理解）class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum = 0; for (int s : stones) &#123; sum += s; &#125; int target = sum / 2; //初始化，dp[i][j]为可以放0-i物品，背包容量为j的情况下背包中的最大价值 int[][] dp = new int[stones.length][target + 1]; //dp[i][0]默认初始化为0 //dp[0][j]取决于stones[0] for (int j = stones[0]; j &lt;= target; j++) &#123; dp[0][j] = stones[0]; &#125; for (int i = 1; i &lt; stones.length; i++) &#123; for (int j = 1; j &lt;= target; j++) &#123;//注意是等于 if (j &gt;= stones[i]) &#123; //不放:dp[i - 1][j] 放:dp[i - 1][j - stones[i]] + stones[i] dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; System.out.println(dp[stones.length - 1][target]); return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target]; &#125;&#125; 目标和力扣 123456789101112131415161718192021222324/*\t题目：\t- 给一个nums和target\t- 元素之间可以加减，算能达到target的组合个数\t思路\t- */class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) sum += nums[i]; if ((target + sum) % 2 != 0) return 0; int size = (target + sum) / 2; if(size &lt; 0) size = -size; int[] dp = new int[size + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = size; j &gt;= nums[i]; j--) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[size]; &#125;&#125; 一和零力扣 12345678910111213141516171819202122232425class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; //dp[i][j]表示i个0和j个1时的最大子集 int[][] dp = new int[m + 1][n + 1]; int oneNum, zeroNum; for (String str : strs) &#123; oneNum = 0; zeroNum = 0; for (char ch : str.toCharArray()) &#123; if (ch == &#x27;0&#x27;) &#123; zeroNum++; &#125; else &#123; oneNum++; &#125; &#125; //倒序遍历 for (int i = m; i &gt;= zeroNum; i--) &#123; for (int j = n; j &gt;= oneNum; j--) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 零钱问题零钱兑换Ⅰ力扣 1234567891011121314public int coinChange(int[] coins, int amount) &#123; // dp的含义时满足目标值的l int[] dp = new int[amount+1]; Arrays.fill(dp, amount+1); dp[0] = 0; for(int rest = 1; rest &lt;= amount; rest++)&#123; for(int index = 0; index &lt; coins.length; index++)&#123; //零钱小于目标值才能计算 if(coins[index] &lt;= rest) dp[rest] = Math.min(dp[rest], dp[rest - coins[index]] +1); &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount];&#125; 零钱兑换 II力扣 123456789101112class Solution &#123; public int change(int amount, int[] coins) &#123; int[] dp = new int[amount + 1]; dp[0] = 1; for (int i = 0; i &lt; coins.length; i++) &#123; for (int j = coins[i]; j &lt;= amount; j++) &#123; dp[j] += dp[j - coins[i]]; &#125; &#125; return dp[amount]; &#125;&#125; 组合总和 Ⅳ力扣 1234567891011121314class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt;= target; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; if (i &gt;= nums[j]) &#123; dp[i] += dp[i - nums[j]]; &#125; &#125; &#125; return dp[target]; &#125;&#125; 完全平方数力扣 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; // 版本一，先遍历物品, 再遍历背包 public int numSquares(int n) &#123; int max = Integer.MAX_VALUE; int[] dp = new int[n + 1]; //初始化 for (int j = 0; j &lt;= n; j++) &#123; dp[j] = max; &#125; //当和为0时，组合的个数为0 dp[0] = 0; // 遍历物品 for (int i = 1; i * i &lt;= n; i++) &#123; // 遍历背包 for (int j = i * i; j &lt;= n; j++) &#123; if (dp[j - i * i] != max) &#123; dp[j] = Math.min(dp[j], dp[j - i * i] + 1); &#125; &#125; &#125; return dp[n]; &#125;&#125;class Solution &#123; // 版本二， 先遍历背包, 再遍历物品 public int numSquares(int n) &#123; int max = Integer.MAX_VALUE; int[] dp = new int[n + 1]; // 初始化 for (int j = 0; j &lt;= n; j++) &#123; dp[j] = max; &#125; // 当和为0时，组合的个数为0 dp[0] = 0; // 遍历背包 for (int j = 1; j &lt;= n; j++) &#123; // 遍历物品 for (int i = 1; i * i &lt;= j; i++) &#123; dp[j] = Math.min(dp[j], dp[j - i * i] + 1); &#125; &#125; return dp[n]; &#125;&#125; 单词拆分力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] valid = new boolean[s.length() + 1]; valid[0] = true; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (wordDict.contains(s.substring(j,i)) &amp;&amp; valid[j]) &#123; valid[i] = true; &#125; &#125; &#125; return valid[s.length()]; &#125;&#125;// 回溯法+记忆化class Solution &#123; private Set&lt;String&gt; set; private int[] memo; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; memo = new int[s.length()]; set = new HashSet&lt;&gt;(wordDict); return backtracking(s, 0); &#125; public boolean backtracking(String s, int startIndex) &#123; // System.out.println(startIndex); if (startIndex == s.length()) &#123; return true; &#125; if (memo[startIndex] == -1) &#123; return false; &#125; for (int i = startIndex; i &lt; s.length(); i++) &#123; String sub = s.substring(startIndex, i + 1); // 拆分出来的单词无法匹配 if (!set.contains(sub)) &#123; continue; &#125; boolean res = backtracking(s, i + 1); if (res) return true; &#125; // 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到 memo[startIndex] = -1; return false; &#125;&#125; 最长递增子序列力扣 1234567891011121314151617class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums.length == 0) return 0; int[] dp = new int[nums.length]; Arrays.fill(dp, 1); int max = 1; for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; max = Math.max(max, dp[i]); &#125; return max; &#125;&#125; 最长连续递增序列力扣 1234567891011121314//dppublic int findLengthOfLCIS(int[] nums) &#123; int[] dp = new int[nums.length]; int max = 1; dp[0] = 1; for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i] &gt; nums[i-1]) dp[i] = dp[i-1] + 1; else dp[i] = 1; max = Math.max(max, dp[i]); &#125; return max;&#125; 最长公共子序列力扣 123456789101112131415public int longestCommonSubsequence(String text1, String text2) &#123; // 先对dp数组做初始化操作 int[][] dp = new int[text1.length() + 1][text2.length() + 1]; for (int i = 1 ; i &lt;= text1.length() ; i++) &#123; for (int j = 1; j &lt;= text2.length(); j++) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; // 开始列出状态转移方程 dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[text1.length()][text2.length()];&#125; 不相交的线力扣 12345678910111213141516class Solution &#123; public int maxUncrossedLines(int[] A, int[] B) &#123; int [][] dp = new int[A.length+1][B.length+1]; for(int i=1;i&lt;=A.length;i++) &#123; for(int j=1;j&lt;=B.length;j++) &#123; if (A[i-1]==B[j-1]) &#123; dp[i][j]=dp[i-1][j-1]+1; &#125; else &#123; dp[i][j]=Math.max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[A.length][B.length]; &#125;&#125; 最大子序和力扣 123456789101112131415161718/*\t题目：\t- 给你一个整数数组 nums ，\t- 找出一个具有最大和的连续子数组，返回其最大和。\t思路：\t- dp数组保存的是当前的最优解\t- ans保存的是全局最优解*/public int maxSubArray(int[] nums) &#123;\tint[] dp = new int[nums.length]; dp[0] = nums[0]; int ans = dp[0]; for(int i = 1; i &lt; nums.length; ++i)&#123; dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); ans = Math.max(dp[i], ans); &#125; return ans;&#125; 判断子序列力扣 123456789101112131415161718192021class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int length1 = s.length(); int length2 = t.length(); int[][] dp = new int[length1+1][length2+1]; for(int i = 1; i &lt;= length1; i++)&#123; for(int j = 1; j &lt;= length2; j++)&#123; if(s.charAt(i-1) == t.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1] + 1; &#125;else&#123; dp[i][j] = dp[i][j-1]; &#125; &#125; &#125; if(dp[length1][length2] == length1)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 不同的子序列力扣 1234567891011121314151617181920class Solution &#123; public int numDistinct(String s, String t) &#123; int[][] dp = new int[s.length() + 1][t.length() + 1]; for (int i = 0; i &lt; s.length() + 1; i++) &#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt; s.length() + 1; i++) &#123; for (int j = 1; j &lt; t.length() + 1; j++) &#123; if (s.charAt(i - 1) == t.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; &#125;else&#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[s.length()][t.length()]; &#125;&#125; 两个字符串的删除操作力扣 1234567891011121314151617181920class Solution &#123; public int minDistance(String word1, String word2) &#123; int[][] dp = new int[word1.length() + 1][word2.length() + 1]; for (int i = 0; i &lt; word1.length() + 1; i++) dp[i][0] = i; for (int j = 0; j &lt; word2.length() + 1; j++) dp[0][j] = j; for (int i = 1; i &lt; word1.length() + 1; i++) &#123; for (int j = 1; j &lt; word2.length() + 1; j++) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125;else&#123; dp[i][j] = Math.min(dp[i - 1][j - 1] + 2, Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)); &#125; &#125; &#125; return dp[word1.length()][word2.length()]; &#125;&#125; 编辑距离力扣 123456789101112131415161718192021222324public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; // 初始化 for (int i = 1; i &lt;= m; i++) &#123; dp[i][0] = i; &#125; for (int j = 1; j &lt;= n; j++) &#123; dp[0][j] = j; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; // 因为dp数组有效位从1开始 // 所以当前遍历到的字符串的位置为i-1 | j-1 if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1; &#125; &#125; &#125; return dp[m][n];&#125; 回文子串力扣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//dpclass Solution &#123; public int countSubstrings(String s) &#123; int len, ans = 0; if (s == null || (len = s.length()) &lt; 1) return 0; //dp[i][j]：s字符串下标i到下标j的字串是否是一个回文串，即s[i, j] boolean[][] dp = new boolean[len][len]; for (int j = 0; j &lt; len; j++) &#123; for (int i = 0; i &lt;= j; i++) &#123; //当两端字母一样时，才可以两端收缩进一步判断 if (s.charAt(i) == s.charAt(j)) &#123; //i++，j--，即两端收缩之后i,j指针指向同一个字符或者i超过j了,必然是一个回文串 if (j - i &lt; 3) &#123; dp[i][j] = true; &#125; else &#123; //否则通过收缩之后的字串判断 dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; else &#123;//两端字符不一样，不是回文串 dp[i][j] = false; &#125; &#125; &#125; //遍历每一个字串，统计回文串个数 for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; if (dp[i][j]) ans++; &#125; &#125; return ans; &#125;&#125;//中心扩散法class Solution &#123; public int countSubstrings(String s) &#123; int len, ans = 0; if (s == null || (len = s.length()) &lt; 1) return 0; //总共有2 * len - 1个中心点 for (int i = 0; i &lt; 2 * len - 1; i++) &#123; //通过遍历每个回文中心，向两边扩散，并判断是否回文字串 //有两种情况，left == right，right = left + 1，这两种回文中心是不一样的 int left = i / 2, right = left + i % 2; while (left &gt;= 0 &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; //如果当前是一个回文串，则记录数量 ans++; left--; right++; &#125; &#125; return ans; &#125;&#125; 最长回文子序列力扣 1234567891011121314151617public class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int len = s.length(); int[][] dp = new int[len + 1][len + 1]; for (int i = len - 1; i &gt;= 0; i--) &#123; // 从后往前遍历 保证情况不漏 dp[i][i] = 1; // 初始化 for (int j = i + 1; j &lt; len; j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; dp[i][j] = dp[i + 1][j - 1] + 2; &#125; else &#123; dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1])); &#125; &#125; &#125; return dp[0][len - 1]; &#125;&#125; 打家劫舍不能抢劫相邻的Ⅰ力扣 1234567891011public int rob(int[] nums) &#123; if(nums.length &lt; 2) return nums[0]; if(nums.length == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for(int i = 2; i &lt; nums.length; i++)&#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1 ];&#125; 围成一圈的Ⅱ力扣 1234567891011121314151617181920212223/*\t- 其实就是把环拆成两个队列\t- 一个是从0到n-1，另一个是从1到n\t-然后返回两个结果最大的。*/public int rob(int[] nums) &#123; if(nums.length &lt; 2) return nums[0]; if(nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(robAction(nums, 0, nums.length - 2), robAction(nums, 1, nums.length - 1));&#125;public int robAction(int[] nums, int start, int end)&#123; int[] dp = new int[nums.length]; dp[start] = nums[start]; dp[start+1] = Math.max(nums[start], nums[start+1]); for(int i = start+ 2; i &lt;= end; i++)&#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[end];&#125; 是一颗树Ⅲ12345678910111213141516public int rob(TreeNode root) &#123; int[] res = robAction(root); return Math.max(res[0], res[1]);&#125;public int[] robAction(TreeNode root) &#123; int res[] = new int[2]; if (root == null) return res; int[] left = robAction(root.left); int[] right = robAction(root.right); //不算根节点 res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); / res[1] = root.val + left[0] + right[0]; return res;&#125; 单调栈每日温度力扣链接 123456789101112131415161718192021/*\t题目：\t- 给定一个温度数组，找比当前温度高的，计算间隔\t思路：\t- 使用单调栈\t- 下标入栈，遇到大于下标对应值的，计算差值*/public static int[] dailyTemperatures(int[] temperatures) &#123; int length = temperatures.length; int[] ans = new int[length]; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; length; i++) &#123; int temperature = temperatures[i]; while (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123; int prevIndex = stack.pop(); ans[prevIndex] = i - prevIndex; &#125; stack.push(i); &#125; return ans;&#125; 下一个更大元素 I力扣 123456789101112131415161718//public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;(); for (int i = nums2.length - 1; i &gt;= 0; --i) &#123; int num = nums2[i]; while (!stack.isEmpty() &amp;&amp; num &gt;= stack.peek()) &#123; stack.pop(); &#125; map.put(num, stack.isEmpty() ? -1 : stack.peek()); stack.push(num); &#125; int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums1.length; ++i) &#123; res[i] = map.get(nums1[i]); &#125; return res;&#125; 下一个更大元素II力扣 1234567891011121314151617181920class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; //边界判断 if(nums == null || nums.length &lt;= 1) &#123; return new int[]&#123;-1&#125;; &#125; int size = nums.length; int[] result = new int[size];//存放结果 Arrays.fill(result,-1);//默认全部初始化为-1 Stack&lt;Integer&gt; st= new Stack&lt;&gt;();//栈中存放的是nums中的元素下标 for(int i = 0; i &lt; 2*size; i++) &#123; while(!st.empty() &amp;&amp; nums[i % size] &gt; nums[st.peek()]) &#123; result[st.peek()] = nums[i % size];//更新result st.pop();//弹出栈顶 &#125; st.push(i % size); &#125; return result; &#125;&#125; 接雨水力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*\t题目：\t- 给定一个数组表示x轴的高度，求feng*///双指针class Solution &#123; public int trap(int[] height) &#123; int leftMax = 0; int rightMax = 0; int left = 0; int right = height.length - 1; int sum = 0; while(left &lt; right)&#123; leftMax = Math.max(leftMax, height[left]); rightMax = Math.max(rightMax, height[right]); if(height[left] &lt; height[right])&#123; sum += leftMax - height[left]; left++; &#125;else&#123; sum += rightMax - height[right]; right--; &#125; &#125; return sum; &#125;&#125;//dpclass Solution &#123; public int trap(int[] height) &#123; int length = height.length; if (length &lt;= 2) return 0; int[] maxLeft = new int[length]; int[] maxRight = new int[length]; // 记录每个柱子左边柱子最大高度 maxLeft[0] = height[0]; for (int i = 1; i&lt; length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]); // 记录每个柱子右边柱子最大高度 maxRight[length - 1] = height[length - 1]; for(int i = length - 2; i &gt;= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]); // 求和 int sum = 0; for (int i = 0; i &lt; length; i++) &#123; int count = Math.min(maxLeft[i], maxRight[i]) - height[i]; if (count &gt; 0) sum += count; &#125; return sum; &#125;&#125;//public int trap(int[] height) &#123; int ans = 0; Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); int n = height.length; for (int i = 0; i &lt; n; ++i) &#123; while (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123; int top = stack.pop(); if (stack.isEmpty()) &#123; break; &#125; int left = stack.peek(); int currWidth = i - left - 1; int currHeight = Math.min(height[left], height[i]) - height[top]; ans += currWidth * currHeight; &#125; stack.push(i); &#125; return ans;&#125; 柱状图中最大的矩形力扣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//dpclass Solution &#123; public int largestRectangleArea(int[] heights) &#123; int length = heights.length; int[] minLeftIndex = new int [length]; int[] maxRigthIndex = new int [length]; // 记录左边第一个小于该柱子的下标 minLeftIndex[0] = -1 ; for (int i = 1; i &lt; length; i++) &#123; int t = i - 1; // 这里不是用if，而是不断向右寻找的过程 while (t &gt;= 0 &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t]; minLeftIndex[i] = t; &#125; // 记录每个柱子 右边第一个小于该柱子的下标 maxRigthIndex[length - 1] = length; for (int i = length - 2; i &gt;= 0; i--) &#123; int t = i + 1; while(t &lt; length &amp;&amp; heights[t] &gt;= heights[i]) t = maxRigthIndex[t]; maxRigthIndex[i] = t; &#125; // 求和 int result = 0; for (int i = 0; i &lt; length; i++) &#123; int sum = heights[i] * (maxRigthIndex[i] - minLeftIndex[i] - 1); result = Math.max(sum, result); &#125; return result; &#125;&#125;//单调栈class Solution &#123; int largestRectangleArea(int[] heights) &#123; Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;(); // 数组扩容，在头和尾各加入一个元素 int [] newHeights = new int[heights.length + 2]; newHeights[0] = 0; newHeights[newHeights.length - 1] = 0; for (int index = 0; index &lt; heights.length; index++)&#123; newHeights[index + 1] = heights[index]; &#125; heights = newHeights; st.push(0); int result = 0; // 第一个元素已经入栈，从下标1开始 for (int i = 1; i &lt; heights.length; i++) &#123; // 注意heights[i] 是和heights[st.top()] 比较 ，st.top()是下标 if (heights[i] &gt; heights[st.peek()]) &#123; st.push(i); &#125; else if (heights[i] == heights[st.peek()]) &#123; st.pop(); // 这个可以加，可以不加，效果一样，思路不同 st.push(i); &#125; else &#123; while (heights[i] &lt; heights[st.peek()]) &#123; // 注意是while int mid = st.peek(); st.pop(); int left = st.peek(); int right = i; int w = right - left - 1; int h = heights[mid]; result = Math.max(result, w * h); &#125; st.push(i); &#125; &#125; return result; &#125;&#125;","tags":["数据结构和算法","代码随想录"],"categories":["算法题"]},{"title":"热题100","path":"/2024/01/18/Note/力扣/2/","content":"题目 备注 提示 两数相加 无重复字符的最长子串 石头颜色问题 救生艇 子数组个数 最长回文子串 两数相加123456789101112131415161718192021222324252627/*\t模拟他的过程即可\t两个链表的节点相加取个位数，如果有进位则保存起来\t创建两个节点，一个head作为返回的头节点，一个tail节点存放数据\t如果两个链表长度不一样，一条为空时只让另外一条移动*/ListNode head = null, tail = null;/int carry = 0;while (l1 != null || l2 != null) &#123; int n1 = l1 != null ? l1.val : 0; int n2 = l2 != null ? l2.val : 0; int sum = n1 + n2 + carry; if (head == null) &#123; //这里的head和tail指向同一个 head = tail = new ListNode(sum % 10); &#125; else &#123; tail.next = new ListNode(sum % 10); tail = tail.next; &#125; carry = sum / 10; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next;&#125;if (carry &gt; 0) tail.next = new ListNode(carry);\treturn head;&#125; 1234/*\t还可以用一个ArrayList集合去存放结果\t最后在复制到链表上*/ 无重复字符的最长子串1234567891011121314151617181920/*\t滑动窗口\t当没遇到重复字符时，窗口一直右移\t当遇到重复字符时，窗口的左边界移动到重复字符之前那个相同字符的前一位*/public static int lengthOfLongestSubstring2(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int max = 0, left = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if(map.containsKey(s.charAt(i))) //为了防止重复字符之后的字符也是重复字符 //比如 abba left要跳到2的位置，因为遇到a时会跳到1 left = Math.max(left,map.get(s.charAt(i)) + 1); map.put(s.charAt(i),i); max = Math.max(max,i-left+1); &#125; return max;&#125; 石头颜色问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*\t题目：\t- [0,4,7] 0表示石头没有颜色，变红代价是4，变蓝代价是7\t- [1,x,x] 1表示石头是红色，不能改变颜色\t- [2,x,x] 2表示石头是蓝色，不能改变颜色\t- 给你一批这样的数组，要求所有石头都要有颜色\t- 且红色和蓝色一样多，返回最小代价\t- 不行则返回-1\t思路：\t- 先遍历一遍，得出红色、蓝色、无色的石头个数 - 先让无色的石头变成一个颜色，计算总代价 - 然后让这些变色的石头红蓝代价相减，取值最大的几个变成另外一个颜色*/public static int method(List&lt;int[]&gt; list)&#123; int redCount = 0, blueCount = 0, costTotal = 0; int noneCount = 0, turnColorCount = 0; //计算出红蓝无色石头个数 for (int[] o : list) &#123; if (o[0] == 1) redCount++; if (o[0] == 2) blueCount++; if (o[0] == 0) &#123; noneCount++; //计算无色石头全变红的代价 costTotal += o[1]; &#125; &#125; //计算需要变色的石头个数 turnColorCount = redCount + noneCount - list.size()/2; //如果红色或蓝色石头超过总石头的一半，则不能实现 if(redCount &gt;= list.size()/2 || blueCount &gt;= list.size()/2)&#123; return -1; &#125;\t//创建辅助数组存放无色石头变红代价-变蓝代价 int[] sort = new int[noneCount]; int i = 0; for (int[] ints : list) &#123; if (ints[0] == 0)&#123; sort[i++] = ints[1] - ints[2]; &#125; &#125; //将无色石头变红代价-变蓝代价p Arrays.sort(sort); i = 0; int j = sort.length-1; for (;i&lt;turnColorCount;i++)&#123; costTotal -= sort[j--]; &#125; return costTotal;&#125; 救生艇12345678910111213141516171819202122232425262728/*\t题目：\t- 给定一个people数组，记录的是每个人的重量\t- limit是每艘船承载的最大重量，一船最多载两人\t- 求承载所有人的最小船数\t思路：\t- 我们应该尽量让体重大的和体重小的坐一艘船\t- left和right分别指向数组两端\t- 能坐一船则left++，right--\t- 不能坐则right--*/public static int numRescueBoats(int[] people, int limit) &#123; Arrays.sort(people); int ans = 0, left = 0, right = people.length - 1; while (left &lt;= right) &#123; if ((people[left] + people[right--]) &lt;= limit) &#123; left++; &#125; ans++; &#125; return ans;&#125;/*\t拓展：\t- 两个人的体重相加是偶数 - 需要把原数组分为奇数体重数组和偶数体重数组 - 再用上面的方法求解即可*/ 子数组个数123456789101112131415161718192021public static int method(int[] arr,int sum)&#123; int ans = 0; int all = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); for (int i = 0; i &lt; arr.length; i++) &#123; all += arr[i]; //总前缀 - 目标前缀 找到子数组个数 if(map.containsKey(all - sum))&#123; ans+=map.get(all - sum); &#125; //如果map中不存在当前前缀和则将其加入 if(!map.containsKey(all))&#123; map.put(all,1); //存在当前前缀和则++ &#125;else&#123; map.put(all,map.get(all) + 1); &#125; &#125; return ans;&#125; 最长回文子串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//动态规划public String longestPalindrome(String s) &#123;\tint len = s.length(); int maxLen = 1; int begin = 0; boolean[][] dp = new boolean[len][len]; //j表示列 for(int j = 1; j &lt; len; ++j)&#123; //i表示行 for(int i = 0; i &lt; j; ++i)&#123; if(s.charAt(i) != s.charAt(j))&#123; dp[i][j] = false; &#125;else &#123; if(j - i &lt; 3)&#123; dp[i][j] = true; &#125;else&#123; dp[i][j] = dp[i+1][j-1]; &#125; &#125; if(dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen)&#123; maxLen = j - i + 1 ; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLen);&#125;//Manacherpublic String longestPalindrome(String s) &#123; if(s.length() &lt; 2) return s; char[] str = manacherString(s); int[] pArr = new int[str.length]; int R = 0; int C = 0; for(int i = 0; i != str.length; i++)&#123; pArr[i] = R &gt; i ? Math.min(pArr[2 * C - i], R - i) : 1; while(i + pArr[i] &lt; str.length &amp;&amp; i - pArr[i] &gt; -1)&#123; if(str[i + pArr[i]] == str[i - pArr[i]])&#123; pArr[i]++; &#125;else&#123; break; &#125; &#125; if(i + pArr[i] &gt; R)&#123; R = i + pArr[i]; C = i; &#125; &#125; int maxLen = 0; int begin = 0; for(int i = 0; i &lt; pArr.length - 1; ++i)&#123; if(pArr[i] &gt; maxLen)&#123; maxLen = pArr[i]; begin = i; &#125; &#125; int start = (begin - maxLen - 1 ) / 2; return s.substring(start + 1, start + maxLen);&#125;public char[] manacherString(String str)&#123; char[] charArr = str.toCharArray(); char[] res = new char[str.length() * 2 + 1]; int index = 0; for(int i = 0; i != res.length; i++)&#123; res[i] = (i &amp; 1) == 0 ? &#x27;#&#x27; : charArr[index++]; &#125; return res;&#125;","tags":["数据结构和算法","力扣热题100"],"categories":["算法题"]},{"path":"/2024/01/18/Note/前端/React /","content":"简介 所有的功能都是以组件的形式存在 用函数作为组件，需要导入导出才能使用 导入组件时可以起别名 组件标签使用驼峰命名法 使用 创建脚手架项目 npx create-react-app client 进入项目 cd client 启动 npm start 格式1234567891011import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;const root = ReactDom.createRoot( document.getElementById(&#x27;root&#x27;) as HTMLElement);root.render( &lt;React.StrictMode&gt; &lt;/React.StrictMode&gt;) 函数形式123456789//创建并导出export default function 函数名(参数名1:参数类型, 参数名2?:参数类型) &#123; return ( html标签/对象 )&#125;//使用import 别名 from &#x27;函数地址/函数名&#x27;;&lt;函数名 参数名=&quot;&quot;&gt;&lt;/函数名&gt; 使用时参数是字符串类型直接使用引号赋值，其他类型使用{}赋值 在参数名后加 ? 表示参数可选，可以有默认值直接在后面加 =默认值 参数可以是对象，也可以是数组，数组对象 数组对象需要在参数位置声明为解构表达式 1234567//格式一interface Student&#123; ... &#125;&#123;student&#125;:&#123;sttudent:Student&#125;//格式二&#123;student&#125;:&#123;sttudent:&#123;属性1:类型，属性2:类型，...&#125;&#125; 放回的html元素如果需要块标签可以直接使用&lt;&gt;html标签/对象&lt;/&gt; 钩子函数 函数名 作用 参数 返回值 备注 useState 为数据赋初始值，改变时会触发重新渲染 数据初始值 数据，数据方法 数据方法可以直接修改值；也可以使用箭头函数修改值，参数为旧值，返回值是新值（不能是旧值 ） useEffect 在html真正渲染之前执行函数 箭头函数，[依赖项] 依赖性变化，函数执行，依赖项为空则函数只执行一次 useContext 存储上下文公共属性 公共属性 公共属性值 使用createContext(属性)创建公共属性，使用&lt;公共属性.Provider value&#x3D;{}&gt;修改公共属性的值 接口1234interface 接口名&#123; 属性名:类型 ...&#125; 可以用于函数参数传递，类似对象传递 修饰符 符号 作用 备注 : 类型定义 &#x2F; 赋值 事件 事件名 说明 React.ChangeEvent 状态改变事件 Axios 方法 参数 备注 get url,[config] config中可以传入参数 post url,[data],[config] AntDesignConfigProvider 国际化 12345678import &#123;ConfigProvider&#125; from &#x27;~antd/dist/antd.css&#x27;import zh_cn from &#x27;antd/es/locale/zh_CN&#x27;root.render( &lt;ConfigProvider locale=&#x27;zh_cn&#x27;&gt; //内容 &lt;/ConfigProvider&gt;) Router"},{"path":"/2024/01/18/Note/前端/JavaScript/","content":"JS函数12345//e 事件对象，ke&#x27;yifunction func(e)&#123; //e.target事件源 e.target.属性&#125; 数据类型 类型名 说明 备注 number 数字 TSJSXTSX数据类型数组 方法 作用 备注 map 遍历， 将数组内的元素映射为新的元素"},{"path":"/2024/01/18/Note/前端/EtherWeb3/","content":"EtherWeb3"},{"path":"/2024/01/18/Note/前端/HTML/","content":"标签 标签名 作用 参数 input 输入框 type、value、onChange、name"},{"path":"/2024/01/18/Note/前端/Css/","content":"单位 单位 px pm rem 大小 标签 作用 参数 备注 width 宽度 high 高度 margin padding 位置 标签 作用 参数 备注 position relative相对 display index align 显示 标签 作用 参数 备注 display grid border shadow cursor 光标"},{"path":"/2024/01/18/Note/人工智能/面试/基础题/","content":"神经网络 梯度消失问题"},{"title":"深度学习算法","path":"/2024/01/18/Note/人工智能/算法/简单算法/","content":"K近邻算法 k-near-neighbor（knn） 计算流程 计算已知类别数据集中的点与当前点的距离 按照距离依次排序 选取与当前点距离最小的k个点 缺点前k个点所在类别的出现概率 返回前k个点出现频率最高的类别作为当前点预测分类 总结- 简单有效，是一种Lazy-Learning算法- 不需要训练，时间复杂度为0，分类时间复杂度与输入数据的大小成正比- k值的选择，距离度量，分类决策规则是该算法的三要素 存在的问题 不适合进行图像分类，因为区分不了主体和背景","tags":["算法"],"categories":["人工智能"]},{"title":"Diffusion","path":"/2024/01/18/Note/人工智能/算法/Difussion/","content":"简介扩散模型","tags":["模型"],"categories":["人工智能"]},{"title":"计算机视觉","path":"/2024/01/18/Note/人工智能/知识点/计算机视觉/","content":"简介 包括图像检测、分类、检索、无人驾驶、人脸识别 使用卷积神经网络实现 使用图像数据当作输入数据，不需要转化为向量 整体架构","tags":["理念"],"categories":["人工智能"]},{"title":"深度学习","path":"/2024/01/18/Note/人工智能/知识点/深度学习/","content":"简介 深度学习最重要的就是解决如何提取特征 深度学习主要应用于计算机视觉和自然语言处理 本质上是输入数据的不同 应用场景 目标检测、人脸识别、图像分类、医学方面、换脸 存在的问题 在移动端的支持会差一些，因为计算量太大了 特征工程 数据特征决定了模型的上限 预处理和特征提取是最核心的 算法与参数选择决定了如何逼近这个上限","tags":["理念"],"categories":["人工智能"]},{"title":"神经网络","path":"/2024/01/18/Note/人工智能/知识点/神经网络/","content":"简介整体架构 数据预处理 输入数据必须先进行预处理操作 标准化、初始化 过拟合解决 可以使用正则化解决数据过拟合问题 可以使用Drop-out解决数据过拟合问题 随机杀死各层级中随机个数的神经元 层卷积层 进行特征提取，用一组权重参数 将图像进行分割 池化层参数 参数名 作用 备注 kernel_size 最大池的窗口大小 n * n stride 步长 默认是kernel_size的大小 padding 填充输入数据的长宽 dilation 空洞 按指定的值间隔取数 ceil_model 数据不完整是否取数 true &#x2F; false(默认) 最大池化 取输入数据中指定区域内的最大值 当池化区域超出输入数据边界上，是否进行取数要看ceil_model的设置 作用 减小输入数据的大小 即取输入数据中的特征值 &#x2F; 重点值 非线性激活层 函数名 作用 特点 场景 RELU 非负 x轴不小于0 隐藏层 Sigmoid 二分类输出层 线性层 公式：y &#x3D; kx + b k：权重 b：偏执 正则化层- Transformer层函数得分函数&#x2F;线性函数 数学表示：f(X,W) &#x3D; WX + b X：类别 W：得分&#x2F;权重&#x2F;特征，是一个矩阵 b：偏执参数，相当于对数值微调，几个w就有几个b 求每个类别对应的得分 损失函数 用于计算实际输出和目标之间的差距 为更新输出提供一定的依据（反向传播） 损失函数的值相同并不意味两个模型相同，需要添加正则化惩罚项 可以简单计算错误得分 - 正确得分 + 容忍值 激活函数 Sigmoid：非线性，已弃用，梯度难以计算，梯度消失问题 Relu：线性，梯度好算 Tanh： 传播正向 &#x2F; 前向传播 通过得分函数计算出损失值 反向传播 通过损失值修改得分函数中的权重w 链式法则 从后往前逐层求偏导 门单元 加法门：均等分配 MAX门：取最大的 乘法门：互换 优化器 优化器名 参数 作用 方法 SGD 随机梯度下降 模型、学习速率 Softmax分类器 步骤 先进行exp运算，放大数据差异化，指数增长，x越大值越大，x越小值越接近0 在进行归一化，得出结果得分的概率值 使用对数函数，传入概率值，求正确项的损失值","tags":["理念"],"categories":["人工智能"]},{"title":"机器学习","path":"/2024/01/18/Note/人工智能/知识点/机器学习/","content":"简介监督学习 回归算法 给予机器算法示例，对于给定的输入，输出想正确的结果 指的是学习x到y的过程，或者说从输入到输出的算法 一般是数字类型的数据 分类算法 基于机器算法示例，对于给定的输入，输出数据的类型 有限的输出 可以是非数据类型的数据，例如图片、视频 无监督学习","tags":["理念"],"categories":["人工智能"]},{"title":"数学","path":"/2024/01/18/Note/人工智能/知识点/数学基础/","content":"函数 函数的定义 量、符号 函数的种类 分段函数、反函数、显函数和隐函数 函数的特性 奇偶性、周期性、单调性 函数的图像 e^x^ 、 函数的极限 定义、符号、无穷大&#x2F;小 函数的连续性 条件、间断点 导数 连续、求导、偏导数、方向导数、梯度","tags":["基础"],"categories":["人工智能"]},{"title":"Python库","path":"/2024/01/18/Note/人工智能/知识点/Python库/","content":"文档Pytorch：https://pytorch.org/docs Image123456#引入from PIL import Image#读取图片，转换为PIL格式image_path = &quot;&quot;img = Image.open(image_path); Numpy1234#引入import numpy as np#处理PIL类型的图像img_array = np.array(i) TensorboardSummaryWriter 用于绘制坐标图 12345#下载（pytorch环境下下载）conda activate pytorchpip install tensorboard#可视化界面tensorboard --logdir=logs --port=6006 1234567891011121314151617181920212223#引入from torch.utils.tensorboard import SummaryWriter#实例化writer = SummaryWriter(&quot;事件文件存储路径&quot;)#添加一张图片\t#tag：标题\t#img_tensor：图像数据类型（torch.Tensor、numpy.array）\t#global_step：步数 / x轴\t#walltimewriter.add_image(tag, img_tensor, global_step, walltime)#添加多张图片writer.add_images(tag, img_tensor, global_step, walltime)#添加标量数据\t#tag：标题\t#scalar_value：数值 / y轴\t#global_step：步数 / x轴writer.add_scalar(tag, scalar_value, global_step)#关闭writer.close() TransForms123456789101112131415161718192021222324252627282930#引入from torchvision import transforms#将PIL类型的图片转换为Tensor类型trans_totensor = transforms.ToTensor()img_tensor = trans_totensor(img)#将tensor类型的图片标准化 （-1 ~ 1）trans_norm = transforms.Normalize([0.5,0.5,0.5],[0.5,0.5,0.5])#需要传入tensor类型的图片img_norm = trans_norm(img_tensor)#Resize图片#1trans_resize = transforms.Resize((长,宽))#传入PIL类型的图片，输出的也是PILleimg_resize = trans_resize(img)#2#传入PIL类型的图片，然后resize后输出为tensor类型的图片trans_resize = transforms.Resize((长,宽))#相当于把想要执行的操作都作为参数传入，按顺序执行，前一步的返回值必须和后一步的参数匹配，否则报错trans_compose = transforms.compose(trans_resize, trans_totensor)#此时输出的就是tensor类型的图片img_resize = trans_compose(img)#随机裁剪 RandomCroptrans_random = transforms.RandomCrop((长,宽))trans_compose = transforms.compose(trans_random, trans_totensor)img_random = trans_compose(img) opencv12345#引入import cv2#传入图片路径，转化为narrays类型cv_img = cv2.im torchvision12345678910#引入import torchvision#训练数据集train_set = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=True, download=True)#测试数据集test_set = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, download=True)#输出的格式为：(图片，识别的结果)print(train_set[0]) dataloader1234567891011121314#引入from torch.utils.data import DataLoader#测试数据集test_set = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, download=True)#loader\t#dataset 数据集 #batch_size 一次取多少个数据并打包 #shuffle 是否打乱 #sampler cai&#x27;yang&#x27;q #batch_sampler #num_worker 多进程加载（window下 &gt; 0时可能有问题） #drop_last 余数是否舍去test_loader = DataLoader(dataset=test_set, batch_size=4, shuffle=True, num_worker=0, drop_last=False) 神经网络框架(torch.nn)module 定义1234567891011121314151617#引入from torch import nnimport torch#定义神经网络模板class Test(nn.module): def __init__(self): super().__init__() #父类中的__call__函数执行了该方法 def forward(self, input): output = input + 1 return ouput #使用神经网络模板test = Test()x = torch.tensor(1.0)output = test(x) conv2d 卷积12345678910111213141516171819202122232425262728#引入import torchimport torch.nn.functional as F#输入数据input = torch.tensor(\t[1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5])kernel = torch.tensor(\t[1,2,3] [1,2,3], [1,2,3])#因为输入数据和卷积为二维数组，所以需要升维\t#数据，size, channel, width, highinput = torch.reshape(input, 1, 1, 5, 5)kernel = torch.reshape(kernel, 1, 1, 3, 3)#conv2d #input 输入三维类型的数据 #weight 权重/卷积核 #bias 偏置\t#stride 步长 #padding 填充输入数据的长宽ouput = F.conv2d(input, kernel, stride=1) maxpool2D 最大池化12345678910111213141516171819202122232425262728#引入import torchfrom torch import nnfrom torch.nn import MaxPool2d#输入数据input = torch.tensor(\t[1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], dtype=float)#定义神经网络class Test(nn.module): def __init__(self): super(Test, self).__init__() self.maxpool1 = MaxPool2d(kernel_size=3, ceil_model=True) def forward(self, input): output = self.maxpool1(input) return ouput#调用test = Test()output = test(input)#输出[3, 5][3, 5] 非线性激活ReLU12345678910111213141516171819202122232425262728#引入import torchfrom torch import nnfrom torch.nn import ReLU#输入数据input = torch.tensor( [[1,-0.5], [-1,3]])input = torch.reshape(input, (-1,1,2,2))#定义神经网络class Test(nn.module): def __init__(self): super(Test, self).__init__() self.relu1 = ReLU() def forward(self, input): output = self.relu1(input) return ouput #调用test = Test()output = test(input)#输出[1, 0][0, 3] Sigmoid12345678910111213141516171819202122232425262728#引入import torchfrom torch import nnfrom torch.nn import Sigmoid#输入数据input = torch.tensor( [[1,-0.5], [-1,3]])input = torch.reshape(input, (-1,1,2,2))#定义神经网络class Test(nn.module): def __init__(self): super(Test, self).__init__() self.sigmoid1 = Sigmoid() def forward(self, input): output = self.sigmoid1(input) return ouput #调用test = Test()output = test(input)#输出[1, 0][0, 3] 线性层1234567891011121314151617181920212223242526272829303132import torchimport torchvisionfrom torch import nnfrom torch.nn import Linearfromfrom torch.utils.data import DataLoaderdataset = torchvision.datasets.CIFAR10( &quot;../data&quot;, train=False, transform=torchvision.transforms,ToTensor(), download=True)dataloader = DataLoader(dataset， batch_size=64)class Tudui(nn.Module):\tdef __init__(self): super(Tudui，self).__init__() self.linear1 = Linear(196608，10)\tdef forward(self，input): output = self.linear1(input) return output tudui_= Tudui()for data in dataloader: imgs， targets = data print(imgs.shape) #摊平数据 output = torch.flatten(imgs) print(output.shape) output = tudui(output) print(output.shape)","tags":["库"],"categories":["人工智能"]},{"title":"Pytorch","path":"/2024/01/18/Note/人工智能/框架/Pytorch/","content":"简介- TensorBoard简介-","tags":["框架"],"categories":["人工智能"]},{"path":"/2024/01/18/Note/人工智能/学习路线/","content":"Python 神经网络 深度学习 机器学习"}]